"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/services/filesService.js":
/*!**************************************!*\
  !*** ./app/services/filesService.js ***!
  \**************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   filesService: () => (/* binding */ filesService)\n/* harmony export */ });\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/supabase */ \"(app-pages-browser)/./app/lib/supabase.js\");\n/**\r\n * Service for handling file operations with Supabase\r\n */ \n// Flag to disable PDF text extraction if it causes issues\nconst SKIP_PDF_TEXT_EXTRACTION = false;\n/**\r\n * Formats file size in a human-readable format\r\n */ const formatFileSize = (bytes)=>{\n    if (bytes < 1024) return bytes + ' bytes';\n    else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';\n    else return (bytes / 1048576).toFixed(1) + ' MB';\n};\n/**\r\n * Extract text from PDF file\r\n */ const extractTextFromPDF = async (file)=>{\n    try {\n        // Import the PDF.js library dynamically\n        const pdfjsLib = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pdfjs-dist_build_pdf_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! pdfjs-dist */ \"(app-pages-browser)/./node_modules/pdfjs-dist/build/pdf.js\", 19));\n        // Set the worker source\n        pdfjsLib.GlobalWorkerOptions.workerSrc = \"//cdnjs.cloudflare.com/ajax/libs/pdf.js/\".concat(pdfjsLib.version, \"/pdf.worker.min.js\");\n        const arrayBuffer = await file.arrayBuffer();\n        console.log(\"Starting PDF extraction for: \".concat(file.name, \", size: \").concat(file.size, \" bytes\"));\n        try {\n            // Load the PDF document\n            const pdf = await pdfjsLib.getDocument({\n                data: arrayBuffer\n            }).promise;\n            console.log(\"PDF loaded successfully with \".concat(pdf.numPages, \" pages\"));\n            let fullText = '';\n            // Process each page\n            for(let i = 1; i <= pdf.numPages; i++){\n                try {\n                    const page = await pdf.getPage(i);\n                    const textContent = await page.getTextContent();\n                    const pageText = textContent.items.map((item)=>item.str).join(' ');\n                    console.log(\"Extracted \".concat(pageText.length, \" characters from page \").concat(i));\n                    fullText += \"--- Page \".concat(i, \" ---\\n\").concat(pageText, \"\\n\\n\");\n                } catch (pageError) {\n                    console.error(\"Error extracting page \".concat(i, \":\"), pageError);\n                    fullText += \"--- Page \".concat(i, \" ---\\n[Error extracting content]\\n\\n\");\n                }\n            }\n            console.log(\"Total extracted text length: \".concat(fullText.length, \" characters\"));\n            // If text extraction appears to have failed\n            if (fullText.trim().length < 100) {\n                console.warn(\"Very little text extracted from PDF. The file may be scanned or image-based.\");\n                fullText += \"\\n[Note: This PDF appears to contain mostly images or scanned content that couldn't be extracted as text.]\";\n            }\n            return fullText;\n        } catch (pdfError) {\n            console.error('PDF parsing error:', pdfError);\n            return \"Error extracting text from PDF: \".concat(pdfError.message);\n        }\n    } catch (error) {\n        console.error('PDF extraction error:', error);\n        return \"Error processing PDF: \".concat(error.message);\n    }\n};\n/**\r\n * Extract data from Excel file\r\n */ const extractTextFromExcel = async (file)=>{\n    try {\n        console.log(\"Starting Excel extraction for: \".concat(file.name, \", size: \").concat(file.size, \" bytes\"));\n        // Import XLSX library dynamically\n        const XLSX = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! xlsx */ \"(app-pages-browser)/./node_modules/xlsx/xlsx.mjs\"));\n        // Get array buffer from the file\n        const arrayBuffer = await file.arrayBuffer();\n        // Read the workbook\n        const workbook = XLSX.read(arrayBuffer, {\n            type: 'array'\n        });\n        let fullText = '';\n        // Process each sheet in the workbook\n        workbook.SheetNames.forEach((sheetName)=>{\n            // Add sheet name as header\n            fullText += \"--- Sheet: \".concat(sheetName, \" ---\\n\\n\");\n            const sheet = workbook.Sheets[sheetName];\n            // Convert sheet to JSON with headers\n            const jsonData = XLSX.utils.sheet_to_json(sheet, {\n                header: 1\n            });\n            // Calculate column widths for better formatting\n            const columnWidths = [];\n            jsonData.forEach((row)=>{\n                row.forEach((cell, j)=>{\n                    const cellValue = String(cell || '');\n                    if (!columnWidths[j] || cellValue.length > columnWidths[j]) {\n                        columnWidths[j] = Math.min(cellValue.length, 30); // Limit width to 30 chars\n                    }\n                });\n            });\n            // Convert JSON data to formatted text\n            jsonData.forEach((row, rowIndex)=>{\n                if (row.length > 0 && row.some((cell)=>cell !== null && cell !== undefined && String(cell).trim() !== '')) {\n                    // Format each row with consistent spacing\n                    const formattedRow = row.map((cell, colIndex)=>{\n                        const cellValue = String(cell || '');\n                        return cellValue.padEnd(columnWidths[colIndex] + 3);\n                    }).join('');\n                    fullText += formattedRow + '\\n';\n                    // Add a separator after header row\n                    if (rowIndex === 0) {\n                        fullText += '-'.repeat(formattedRow.length) + '\\n';\n                    }\n                }\n            });\n            fullText += '\\n\\n';\n        });\n        console.log(\"Excel extraction complete, processed \".concat(workbook.SheetNames.length, \" sheets, extracted \").concat(fullText.length, \" characters\"));\n        return fullText;\n    } catch (error) {\n        console.error('Excel extraction error:', error);\n        return \"Error extracting data from Excel file: \".concat(error.message);\n    }\n};\n/**\r\n * Uploads a document to Supabase storage and database\r\n */ const uploadDocument = async (file)=>{\n    try {\n        console.log(\"Processing document: \".concat(file.name, \", type: \").concat(file.type, \", size: \").concat(file.size, \" bytes\"));\n        // Extract text content from PDF\n        let textContent = '';\n        if (file.type === 'application/pdf' && !SKIP_PDF_TEXT_EXTRACTION) {\n            console.log('Processing as PDF...');\n            try {\n                textContent = await extractTextFromPDF(file);\n                console.log(\"PDF processing complete, extracted \".concat(textContent.length, \" characters\"));\n                if (textContent.length < 100) {\n                    console.warn('Minimal text extracted from PDF, it may contain mostly images or be encrypted');\n                }\n                // Limit the text content size to prevent database issues\n                // PostgreSQL has a limit on text column size\n                if (textContent.length > 1000000) {\n                    console.log(\"Text content too large (\".concat(textContent.length, \" chars), truncating...\"));\n                    textContent = textContent.substring(0, 1000000) + '... [content truncated]';\n                }\n            } catch (pdfError) {\n                console.error('PDF extraction error:', pdfError);\n                textContent = \"Error extracting PDF content: \".concat(pdfError.message);\n            }\n        } else if (file.type === 'application/pdf') {\n            console.log('PDF text extraction skipped due to SKIP_PDF_TEXT_EXTRACTION flag');\n            textContent = 'PDF content extraction skipped';\n        } else {\n            console.log(\"Unsupported document type: \".concat(file.type, \", no text extraction performed\"));\n        }\n        // Upload file to Supabase Storage\n        const fileName = \"\".concat(Date.now(), \"-\").concat(file.name);\n        console.log(\"Uploading file to Supabase storage bucket 'documents' with name: \".concat(fileName));\n        const { error: uploadError, data: storageData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.storage.from('documents').upload(fileName, file, {\n            cacheControl: '3600',\n            upsert: false\n        });\n        if (uploadError) {\n            console.error('Storage upload error:', JSON.stringify(uploadError));\n            throw new Error(\"Storage upload error: \".concat(JSON.stringify(uploadError)));\n        }\n        console.log('File successfully uploaded to storage, getting public URL');\n        // Get the public URL\n        const { data: { publicUrl } } = _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.storage.from('documents').getPublicUrl(fileName);\n        console.log(\"Public URL generated: \".concat(publicUrl));\n        // Create database record\n        console.log('Creating database record for the uploaded file');\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('documents').insert([\n            {\n                title: file.name,\n                file_path: fileName,\n                file_type: file.type,\n                file_size: file.size,\n                content: textContent,\n                public_url: publicUrl\n            }\n        ]).select();\n        if (error) {\n            console.error('Database insert error:', JSON.stringify(error));\n            throw new Error(\"Database insert error: \".concat(JSON.stringify(error)));\n        }\n        console.log('Document successfully uploaded and recorded in database');\n        return {\n            id: data[0].id,\n            name: data[0].title,\n            type: 'document',\n            content: textContent,\n            size: formatFileSize(data[0].file_size),\n            uploadDate: new Date(data[0].created_at),\n            url: data[0].public_url\n        };\n    } catch (error) {\n        console.error('Upload document error:', error);\n        throw error;\n    }\n};\n/**\r\n * Uploads a spreadsheet to Supabase storage and database\r\n */ const uploadSpreadsheet = async (file)=>{\n    try {\n        console.log(\"Processing spreadsheet: \".concat(file.name, \", type: \").concat(file.type, \", size: \").concat(file.size, \" bytes\"));\n        // Extract content from Excel\n        let textContent = '';\n        let structuredData = null;\n        if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls') || file.type.includes('excel')) {\n            console.log('Processing as Excel...');\n            try {\n                textContent = await extractTextFromExcel(file);\n                console.log(\"Excel processing complete, extracted \".concat(textContent.length, \" characters\"));\n                // Generate structured data from the text content\n                try {\n                    // Parse the text content into a simple structured format\n                    // This is a simplified version - in a real app, you would do more sophisticated parsing\n                    const lines = textContent.split('\\n').filter((line)=>line.trim());\n                    const parsedData = [];\n                    let currentSheet = null;\n                    let currentSheetData = [];\n                    for (const line of lines){\n                        if (line.startsWith('--- Sheet:')) {\n                            // New sheet found, save the previous sheet if it exists\n                            if (currentSheet && currentSheetData.length > 0) {\n                                parsedData.push({\n                                    name: currentSheet,\n                                    data: currentSheetData\n                                });\n                            }\n                            // Start a new sheet\n                            currentSheet = line.replace('--- Sheet:', '').replace('---', '').trim();\n                            currentSheetData = [];\n                        } else if (currentSheet && line.trim()) {\n                            // Add data row to current sheet\n                            const rowData = line.split(/\\s{3,}/).map((cell)=>cell.trim());\n                            if (rowData.length > 0) {\n                                currentSheetData.push(rowData);\n                            }\n                        }\n                    }\n                    // Add the last sheet if it exists\n                    if (currentSheet && currentSheetData.length > 0) {\n                        parsedData.push({\n                            name: currentSheet,\n                            data: currentSheetData\n                        });\n                    }\n                    structuredData = JSON.stringify(parsedData);\n                } catch (parseError) {\n                    console.error('Error parsing Excel data into structured format:', parseError);\n                    structuredData = JSON.stringify([\n                        {\n                            name: 'Sheet1',\n                            data: [\n                                [\n                                    'Error parsing data'\n                                ]\n                            ]\n                        }\n                    ]);\n                }\n                // Limit the text content size\n                if (textContent.length > 1000000) {\n                    console.log(\"Text content too large (\".concat(textContent.length, \" chars), truncating...\"));\n                    textContent = textContent.substring(0, 1000000) + '... [content truncated]';\n                }\n            } catch (excelError) {\n                console.error('Excel extraction error:', excelError);\n                textContent = \"Error extracting Excel content: \".concat(excelError.message);\n                structuredData = JSON.stringify([\n                    {\n                        name: 'Error',\n                        data: [\n                            [\n                                'Failed to extract data'\n                            ]\n                        ]\n                    }\n                ]);\n            }\n        } else {\n            console.log(\"Unsupported spreadsheet type: \".concat(file.type, \", no text extraction performed\"));\n            structuredData = JSON.stringify([\n                {\n                    name: 'Unknown',\n                    data: [\n                        [\n                            'No Data'\n                        ],\n                        [\n                            'Unsupported file format'\n                        ]\n                    ]\n                }\n            ]);\n        }\n        // Upload file to Supabase Storage\n        const fileName = \"\".concat(Date.now(), \"-\").concat(file.name);\n        console.log(\"Uploading file to Supabase storage bucket 'spreadsheets' with name: \".concat(fileName));\n        const { error: uploadError, data: storageData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.storage.from('spreadsheets').upload(fileName, file, {\n            cacheControl: '3600',\n            upsert: false\n        });\n        if (uploadError) {\n            console.error('Storage upload error:', JSON.stringify(uploadError));\n            throw new Error(\"Storage upload error: \".concat(JSON.stringify(uploadError)));\n        }\n        console.log('File successfully uploaded to storage, getting public URL');\n        // Get the public URL\n        const { data: { publicUrl } } = _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.storage.from('spreadsheets').getPublicUrl(fileName);\n        console.log(\"Public URL generated: \".concat(publicUrl));\n        // Create database record\n        console.log('Creating database record for the uploaded file');\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('documents').insert([\n            {\n                title: file.name,\n                file_path: fileName,\n                file_type: \"spreadsheet/\".concat(file.type),\n                file_size: file.size,\n                content: textContent,\n                structured_data: structuredData,\n                public_url: publicUrl\n            }\n        ]).select();\n        if (error) {\n            console.error('Database insert error:', JSON.stringify(error));\n            throw new Error(\"Database insert error: \".concat(JSON.stringify(error)));\n        }\n        console.log('Spreadsheet successfully uploaded and recorded in database');\n        // Return formatted spreadsheet with content\n        return {\n            id: data[0].id,\n            name: data[0].title,\n            type: 'spreadsheet',\n            content: textContent,\n            data: JSON.parse(data[0].structured_data || '[[]]'),\n            size: formatFileSize(data[0].file_size),\n            uploadDate: new Date(data[0].created_at),\n            url: data[0].public_url\n        };\n    } catch (error) {\n        console.error('Upload spreadsheet error:', error);\n        throw error;\n    }\n};\n/**\r\n * Retrieves all files from Supabase\r\n */ const getFiles = async ()=>{\n    try {\n        console.log('Fetching all files from database');\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('documents').select('*').order('created_at', {\n            ascending: false\n        });\n        if (error) {\n            console.error('Error fetching files:', error);\n            throw error;\n        }\n        console.log(\"Retrieved \".concat(data.length, \" files from database\"));\n        return data.map((file)=>{\n            if (file.file_type && file.file_type.includes('spreadsheet')) {\n                // Log for debugging\n                console.log(\"Processing spreadsheet: \".concat(file.title, \", content length: \").concat(file.content ? file.content.length : 0));\n                // Return as Spreadsheet type\n                return {\n                    id: file.id,\n                    name: file.title || file.name || 'Unnamed Spreadsheet',\n                    type: 'spreadsheet',\n                    content: file.content || '',\n                    data: file.structured_data ? JSON.parse(file.structured_data) : [\n                        []\n                    ],\n                    size: formatFileSize(file.file_size || 0),\n                    uploadDate: new Date(file.created_at),\n                    url: file.public_url\n                };\n            } else {\n                // Log for debugging\n                console.log(\"Processing document: \".concat(file.title, \", content length: \").concat(file.content ? file.content.length : 0));\n                // Return as Document type\n                return {\n                    id: file.id,\n                    name: file.title || file.name || 'Unnamed Document',\n                    type: 'document',\n                    content: file.content || '',\n                    size: formatFileSize(file.file_size || 0),\n                    uploadDate: new Date(file.created_at),\n                    url: file.public_url\n                };\n            }\n        });\n    } catch (e) {\n        console.error('Could not fetch files from Supabase:', e);\n        return [];\n    }\n};\n/**\r\n * Deletes a file by ID\r\n */ const deleteFile = async (id)=>{\n    try {\n        // First get the file info to get the storage path\n        const { data: file } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('documents').select('file_path, file_type').eq('id', id).single();\n        if (file) {\n            // Determine the storage bucket based on file type\n            const bucket = file.file_type.includes('spreadsheet') ? 'spreadsheets' : 'documents';\n            // Delete from storage\n            const { error: storageError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.storage.from(bucket).remove([\n                file.file_path\n            ]);\n            if (storageError) {\n                console.error('Storage delete error:', storageError);\n            }\n        }\n        // Delete from database\n        const { error: dbError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('documents').delete().eq('id', id);\n        if (dbError) throw dbError;\n        return true;\n    } catch (error) {\n        console.error('Error deleting file:', error);\n        throw error;\n    }\n};\nconst filesService = {\n    uploadDocument,\n    uploadSpreadsheet,\n    getFiles,\n    deleteFile,\n    extractTextFromPDF,\n    extractTextFromExcel\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zZXJ2aWNlcy9maWxlc1NlcnZpY2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Q0FFQyxHQUMwQztBQUUzQywwREFBMEQ7QUFDMUQsTUFBTUMsMkJBQTJCO0FBRWpDOztDQUVDLEdBQ0QsTUFBTUMsaUJBQWlCLENBQUNDO0lBQ3RCLElBQUlBLFFBQVEsTUFBTSxPQUFPQSxRQUFRO1NBQzVCLElBQUlBLFFBQVEsU0FBUyxPQUFPLENBQUNBLFFBQVEsSUFBRyxFQUFHQyxPQUFPLENBQUMsS0FBSztTQUN4RCxPQUFPLENBQUNELFFBQVEsT0FBTSxFQUFHQyxPQUFPLENBQUMsS0FBSztBQUM3QztBQUVBOztDQUVDLEdBQ0QsTUFBTUMscUJBQXFCLE9BQU9DO0lBQ2hDLElBQUk7UUFDRix3Q0FBd0M7UUFDeEMsTUFBTUMsV0FBVyxNQUFNLDBPQUFvQjtRQUUzQyx3QkFBd0I7UUFDeEJBLFNBQVNDLG1CQUFtQixDQUFDQyxTQUFTLEdBQUcsMkNBQTRELE9BQWpCRixTQUFTRyxPQUFPLEVBQUM7UUFFckcsTUFBTUMsY0FBYyxNQUFNTCxLQUFLSyxXQUFXO1FBRTFDQyxRQUFRQyxHQUFHLENBQUMsZ0NBQW9EUCxPQUFwQkEsS0FBS1EsSUFBSSxFQUFDLFlBQW9CLE9BQVZSLEtBQUtTLElBQUksRUFBQztRQUUxRSxJQUFJO1lBQ0Ysd0JBQXdCO1lBQ3hCLE1BQU1DLE1BQU0sTUFBTVQsU0FBU1UsV0FBVyxDQUFDO2dCQUFDQyxNQUFNUDtZQUFXLEdBQUdRLE9BQU87WUFDbkVQLFFBQVFDLEdBQUcsQ0FBQyxnQ0FBNkMsT0FBYkcsSUFBSUksUUFBUSxFQUFDO1lBRXpELElBQUlDLFdBQVc7WUFFZixvQkFBb0I7WUFDcEIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLEtBQUtOLElBQUlJLFFBQVEsRUFBRUUsSUFBSztnQkFDdEMsSUFBSTtvQkFDRixNQUFNQyxPQUFPLE1BQU1QLElBQUlRLE9BQU8sQ0FBQ0Y7b0JBQy9CLE1BQU1H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QU81RixPQUFPO1FBQ2R2QixRQUFRdUIsS0FBSyxDQUFDLHdCQUF3QkE7UUFDdEMsTUFBTUE7SUFDUjtBQUNGO0FBRU8sTUFBTThGLGVBQWU7SUFDMUI1RDtJQUNBNkI7SUFDQW1CO0lBQ0FJO0lBQ0FwSDtJQUNBbUM7QUFDRixFQUFFIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGh3ZXRoXFxPbmVEcml2ZVxcRGVza3RvcFxcSW5ub3ZlcmFcXEhpZ2dpbnNcXE1pbmRWYXVsdFxcTWluZFZhdWx0LTFcXG1pbmR2YXVsdFxcYXBwXFxzZXJ2aWNlc1xcZmlsZXNTZXJ2aWNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBTZXJ2aWNlIGZvciBoYW5kbGluZyBmaWxlIG9wZXJhdGlvbnMgd2l0aCBTdXBhYmFzZVxyXG4gKi9cclxuaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tICcuLi9saWIvc3VwYWJhc2UnO1xyXG5cclxuLy8gRmxhZyB0byBkaXNhYmxlIFBERiB0ZXh0IGV4dHJhY3Rpb24gaWYgaXQgY2F1c2VzIGlzc3Vlc1xyXG5jb25zdCBTS0lQX1BERl9URVhUX0VYVFJBQ1RJT04gPSBmYWxzZTtcclxuXHJcbi8qKlxyXG4gKiBGb3JtYXRzIGZpbGUgc2l6ZSBpbiBhIGh1bWFuLXJlYWRhYmxlIGZvcm1hdFxyXG4gKi9cclxuY29uc3QgZm9ybWF0RmlsZVNpemUgPSAoYnl0ZXMpID0+IHtcclxuICBpZiAoYnl0ZXMgPCAxMDI0KSByZXR1cm4gYnl0ZXMgKyAnIGJ5dGVzJztcclxuICBlbHNlIGlmIChieXRlcyA8IDEwNDg1NzYpIHJldHVybiAoYnl0ZXMgLyAxMDI0KS50b0ZpeGVkKDEpICsgJyBLQic7XHJcbiAgZWxzZSByZXR1cm4gKGJ5dGVzIC8gMTA0ODU3NikudG9GaXhlZCgxKSArICcgTUInO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEV4dHJhY3QgdGV4dCBmcm9tIFBERiBmaWxlXHJcbiAqL1xyXG5jb25zdCBleHRyYWN0VGV4dEZyb21QREYgPSBhc3luYyAoZmlsZSkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBJbXBvcnQgdGhlIFBERi5qcyBsaWJyYXJ5IGR5bmFtaWNhbGx5XHJcbiAgICBjb25zdCBwZGZqc0xpYiA9IGF3YWl0IGltcG9ydCgncGRmanMtZGlzdCcpO1xyXG4gICAgXHJcbiAgICAvLyBTZXQgdGhlIHdvcmtlciBzb3VyY2VcclxuICAgIHBkZmpzTGliLkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjID0gYC8vY2RuanMuY2xvdWRmbGFyZS5jb20vYWpheC9saWJzL3BkZi5qcy8ke3BkZmpzTGliLnZlcnNpb259L3BkZi53b3JrZXIubWluLmpzYDtcclxuICAgIFxyXG4gICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBmaWxlLmFycmF5QnVmZmVyKCk7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGBTdGFydGluZyBQREYgZXh0cmFjdGlvbiBmb3I6ICR7ZmlsZS5uYW1lfSwgc2l6ZTogJHtmaWxlLnNpemV9IGJ5dGVzYCk7XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIExvYWQgdGhlIFBERiBkb2N1bWVudFxyXG4gICAgICBjb25zdCBwZGYgPSBhd2FpdCBwZGZqc0xpYi5nZXREb2N1bWVudCh7ZGF0YTogYXJyYXlCdWZmZXJ9KS5wcm9taXNlO1xyXG4gICAgICBjb25zb2xlLmxvZyhgUERGIGxvYWRlZCBzdWNjZXNzZnVsbHkgd2l0aCAke3BkZi5udW1QYWdlc30gcGFnZXNgKTtcclxuICAgICAgXHJcbiAgICAgIGxldCBmdWxsVGV4dCA9ICcnO1xyXG5cclxuICAgICAgLy8gUHJvY2VzcyBlYWNoIHBhZ2VcclxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gcGRmLm51bVBhZ2VzOyBpKyspIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgcGFnZSA9IGF3YWl0IHBkZi5nZXRQYWdlKGkpO1xyXG4gICAgICAgICAgY29uc3QgdGV4dENvbnRlbnQgPSBhd2FpdCBwYWdlLmdldFRleHRDb250ZW50KCk7XHJcbiAgICAgICAgICBjb25zdCBwYWdlVGV4dCA9IHRleHRDb250ZW50Lml0ZW1zXHJcbiAgICAgICAgICAgIC5tYXAoaXRlbSA9PiBpdGVtLnN0cilcclxuICAgICAgICAgICAgLmpvaW4oJyAnKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc29sZS5sb2coYEV4dHJhY3RlZCAke3BhZ2VUZXh0Lmxlbmd0aH0gY2hhcmFjdGVycyBmcm9tIHBhZ2UgJHtpfWApO1xyXG4gICAgICAgICAgZnVsbFRleHQgKz0gYC0tLSBQYWdlICR7aX0gLS0tXFxuJHtwYWdlVGV4dH1cXG5cXG5gO1xyXG4gICAgICAgIH0gY2F0Y2ggKHBhZ2VFcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZXh0cmFjdGluZyBwYWdlICR7aX06YCwgcGFnZUVycm9yKTtcclxuICAgICAgICAgIGZ1bGxUZXh0ICs9IGAtLS0gUGFnZSAke2l9IC0tLVxcbltFcnJvciBleHRyYWN0aW5nIGNvbnRlbnRdXFxuXFxuYDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGBUb3RhbCBleHRyYWN0ZWQgdGV4dCBsZW5ndGg6ICR7ZnVsbFRleHQubGVuZ3RofSBjaGFyYWN0ZXJzYCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBJZiB0ZXh0IGV4dHJhY3Rpb24gYXBwZWFycyB0byBoYXZlIGZhaWxlZFxyXG4gICAgICBpZiAoZnVsbFRleHQudHJpbSgpLmxlbmd0aCA8IDEwMCkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIlZlcnkgbGl0dGxlIHRleHQgZXh0cmFjdGVkIGZyb20gUERGLiBUaGUgZmlsZSBtYXkgYmUgc2Nhbm5lZCBvciBpbWFnZS1iYXNlZC5cIik7XHJcbiAgICAgICAgZnVsbFRleHQgKz0gXCJcXG5bTm90ZTogVGhpcyBQREYgYXBwZWFycyB0byBjb250YWluIG1vc3RseSBpbWFnZXMgb3Igc2Nhbm5lZCBjb250ZW50IHRoYXQgY291bGRuJ3QgYmUgZXh0cmFjdGVkIGFzIHRleHQuXVwiO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gZnVsbFRleHQ7XHJcbiAgICB9IGNhdGNoIChwZGZFcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdQREYgcGFyc2luZyBlcnJvcjonLCBwZGZFcnJvcik7XHJcbiAgICAgIHJldHVybiBgRXJyb3IgZXh0cmFjdGluZyB0ZXh0IGZyb20gUERGOiAke3BkZkVycm9yLm1lc3NhZ2V9YDtcclxuICAgIH1cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignUERGIGV4dHJhY3Rpb24gZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIGBFcnJvciBwcm9jZXNzaW5nIFBERjogJHtlcnJvci5tZXNzYWdlfWA7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEV4dHJhY3QgZGF0YSBmcm9tIEV4Y2VsIGZpbGVcclxuICovXHJcbmNvbnN0IGV4dHJhY3RUZXh0RnJvbUV4Y2VsID0gYXN5bmMgKGZpbGUpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc29sZS5sb2coYFN0YXJ0aW5nIEV4Y2VsIGV4dHJhY3Rpb24gZm9yOiAke2ZpbGUubmFtZX0sIHNpemU6ICR7ZmlsZS5zaXplfSBieXRlc2ApO1xyXG4gICAgXHJcbiAgICAvLyBJbXBvcnQgWExTWCBsaWJyYXJ5IGR5bmFtaWNhbGx5XHJcbiAgICBjb25zdCBYTFNYID0gYXdhaXQgaW1wb3J0KCd4bHN4Jyk7XHJcbiAgICBcclxuICAgIC8vIEdldCBhcnJheSBidWZmZXIgZnJvbSB0aGUgZmlsZVxyXG4gICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBmaWxlLmFycmF5QnVmZmVyKCk7XHJcbiAgICBcclxuICAgIC8vIFJlYWQgdGhlIHdvcmtib29rXHJcbiAgICBjb25zdCB3b3JrYm9vayA9IFhMU1gucmVhZChhcnJheUJ1ZmZlciwgeyB0eXBlOiAnYXJyYXknIH0pO1xyXG4gICAgXHJcbiAgICBsZXQgZnVsbFRleHQgPSAnJztcclxuICAgIFxyXG4gICAgLy8gUHJvY2VzcyBlYWNoIHNoZWV0IGluIHRoZSB3b3JrYm9va1xyXG4gICAgd29ya2Jvb2suU2hlZXROYW1lcy5mb3JFYWNoKHNoZWV0TmFtZSA9PiB7XHJcbiAgICAgIC8vIEFkZCBzaGVldCBuYW1lIGFzIGhlYWRlclxyXG4gICAgICBmdWxsVGV4dCArPSBgLS0tIFNoZWV0OiAke3NoZWV0TmFtZX0gLS0tXFxuXFxuYDtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHNoZWV0ID0gd29ya2Jvb2suU2hlZXRzW3NoZWV0TmFtZV07XHJcbiAgICAgIFxyXG4gICAgICAvLyBDb252ZXJ0IHNoZWV0IHRvIEpTT04gd2l0aCBoZWFkZXJzXHJcbiAgICAgIGNvbnN0IGpzb25EYXRhID0gWExTWC51dGlscy5zaGVldF90b19qc29uKHNoZWV0LCB7IGhlYWRlcjogMSB9KTtcclxuICAgICAgXHJcbiAgICAgIC8vIENhbGN1bGF0ZSBjb2x1bW4gd2lkdGhzIGZvciBiZXR0ZXIgZm9ybWF0dGluZ1xyXG4gICAgICBjb25zdCBjb2x1bW5XaWR0aHMgPSBbXTtcclxuICAgICAganNvbkRhdGEuZm9yRWFjaChyb3cgPT4ge1xyXG4gICAgICAgIHJvdy5mb3JFYWNoKChjZWxsLCBqKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBjZWxsVmFsdWUgPSBTdHJpbmcoY2VsbCB8fCAnJyk7XHJcbiAgICAgICAgICBpZiAoIWNvbHVtbldpZHRoc1tqXSB8fCBjZWxsVmFsdWUubGVuZ3RoID4gY29sdW1uV2lkdGhzW2pdKSB7XHJcbiAgICAgICAgICAgIGNvbHVtbldpZHRoc1tqXSA9IE1hdGgubWluKGNlbGxWYWx1ZS5sZW5ndGgsIDMwKTsgLy8gTGltaXQgd2lkdGggdG8gMzAgY2hhcnNcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDb252ZXJ0IEpTT04gZGF0YSB0byBmb3JtYXR0ZWQgdGV4dFxyXG4gICAgICBqc29uRGF0YS5mb3JFYWNoKChyb3csIHJvd0luZGV4KSA9PiB7XHJcbiAgICAgICAgaWYgKHJvdy5sZW5ndGggPiAwICYmIHJvdy5zb21lKGNlbGwgPT4gY2VsbCAhPT0gbnVsbCAmJiBjZWxsICE9PSB1bmRlZmluZWQgJiYgU3RyaW5nKGNlbGwpLnRyaW0oKSAhPT0gJycpKSB7XHJcbiAgICAgICAgICAvLyBGb3JtYXQgZWFjaCByb3cgd2l0aCBjb25zaXN0ZW50IHNwYWNpbmdcclxuICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZFJvdyA9IHJvdy5tYXAoKGNlbGwsIGNvbEluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbGxWYWx1ZSA9IFN0cmluZyhjZWxsIHx8ICcnKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNlbGxWYWx1ZS5wYWRFbmQoY29sdW1uV2lkdGhzW2NvbEluZGV4XSArIDMpO1xyXG4gICAgICAgICAgfSkuam9pbignJyk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGZ1bGxUZXh0ICs9IGZvcm1hdHRlZFJvdyArICdcXG4nO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBBZGQgYSBzZXBhcmF0b3IgYWZ0ZXIgaGVhZGVyIHJvd1xyXG4gICAgICAgICAgaWYgKHJvd0luZGV4ID09PSAwKSB7XHJcbiAgICAgICAgICAgIGZ1bGxUZXh0ICs9ICctJy5yZXBlYXQoZm9ybWF0dGVkUm93Lmxlbmd0aCkgKyAnXFxuJztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgZnVsbFRleHQgKz0gJ1xcblxcbic7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYEV4Y2VsIGV4dHJhY3Rpb24gY29tcGxldGUsIHByb2Nlc3NlZCAke3dvcmtib29rLlNoZWV0TmFtZXMubGVuZ3RofSBzaGVldHMsIGV4dHJhY3RlZCAke2Z1bGxUZXh0Lmxlbmd0aH0gY2hhcmFjdGVyc2ApO1xyXG4gICAgcmV0dXJuIGZ1bGxUZXh0O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFeGNlbCBleHRyYWN0aW9uIGVycm9yOicsIGVycm9yKTtcclxuICAgIHJldHVybiBgRXJyb3IgZXh0cmFjdGluZyBkYXRhIGZyb20gRXhjZWwgZmlsZTogJHtlcnJvci5tZXNzYWdlfWA7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVwbG9hZHMgYSBkb2N1bWVudCB0byBTdXBhYmFzZSBzdG9yYWdlIGFuZCBkYXRhYmFzZVxyXG4gKi9cclxuY29uc3QgdXBsb2FkRG9jdW1lbnQgPSBhc3luYyAoZmlsZSkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZyhgUHJvY2Vzc2luZyBkb2N1bWVudDogJHtmaWxlLm5hbWV9LCB0eXBlOiAke2ZpbGUudHlwZX0sIHNpemU6ICR7ZmlsZS5zaXplfSBieXRlc2ApO1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IHRleHQgY29udGVudCBmcm9tIFBERlxyXG4gICAgbGV0IHRleHRDb250ZW50ID0gJyc7XHJcbiAgICBpZiAoZmlsZS50eXBlID09PSAnYXBwbGljYXRpb24vcGRmJyAmJiAhU0tJUF9QREZfVEVYVF9FWFRSQUNUSU9OKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdQcm9jZXNzaW5nIGFzIFBERi4uLicpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRleHRDb250ZW50ID0gYXdhaXQgZXh0cmFjdFRleHRGcm9tUERGKGZpbGUpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBQREYgcHJvY2Vzc2luZyBjb21wbGV0ZSwgZXh0cmFjdGVkICR7dGV4dENvbnRlbnQubGVuZ3RofSBjaGFyYWN0ZXJzYCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHRleHRDb250ZW50Lmxlbmd0aCA8IDEwMCkge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCdNaW5pbWFsIHRleHQgZXh0cmFjdGVkIGZyb20gUERGLCBpdCBtYXkgY29udGFpbiBtb3N0bHkgaW1hZ2VzIG9yIGJlIGVuY3J5cHRlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBMaW1pdCB0aGUgdGV4dCBjb250ZW50IHNpemUgdG8gcHJldmVudCBkYXRhYmFzZSBpc3N1ZXNcclxuICAgICAgICAvLyBQb3N0Z3JlU1FMIGhhcyBhIGxpbWl0IG9uIHRleHQgY29sdW1uIHNpemVcclxuICAgICAgICBpZiAodGV4dENvbnRlbnQubGVuZ3RoID4gMTAwMDAwMCkgeyAgLy8gMU1CIGxpbWl0XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgVGV4dCBjb250ZW50IHRvbyBsYXJnZSAoJHt0ZXh0Q29udGVudC5sZW5ndGh9IGNoYXJzKSwgdHJ1bmNhdGluZy4uLmApO1xyXG4gICAgICAgICAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5zdWJzdHJpbmcoMCwgMTAwMDAwMCkgKyAnLi4uIFtjb250ZW50IHRydW5jYXRlZF0nO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAocGRmRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdQREYgZXh0cmFjdGlvbiBlcnJvcjonLCBwZGZFcnJvcik7XHJcbiAgICAgICAgdGV4dENvbnRlbnQgPSBgRXJyb3IgZXh0cmFjdGluZyBQREYgY29udGVudDogJHtwZGZFcnJvci5tZXNzYWdlfWA7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoZmlsZS50eXBlID09PSAnYXBwbGljYXRpb24vcGRmJykge1xyXG4gICAgICBjb25zb2xlLmxvZygnUERGIHRleHQgZXh0cmFjdGlvbiBza2lwcGVkIGR1ZSB0byBTS0lQX1BERl9URVhUX0VYVFJBQ1RJT04gZmxhZycpO1xyXG4gICAgICB0ZXh0Q29udGVudCA9ICdQREYgY29udGVudCBleHRyYWN0aW9uIHNraXBwZWQnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5sb2coYFVuc3VwcG9ydGVkIGRvY3VtZW50IHR5cGU6ICR7ZmlsZS50eXBlfSwgbm8gdGV4dCBleHRyYWN0aW9uIHBlcmZvcm1lZGApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBVcGxvYWQgZmlsZSB0byBTdXBhYmFzZSBTdG9yYWdlXHJcbiAgICBjb25zdCBmaWxlTmFtZSA9IGAke0RhdGUubm93KCl9LSR7ZmlsZS5uYW1lfWA7XHJcbiAgICBjb25zb2xlLmxvZyhgVXBsb2FkaW5nIGZpbGUgdG8gU3VwYWJhc2Ugc3RvcmFnZSBidWNrZXQgJ2RvY3VtZW50cycgd2l0aCBuYW1lOiAke2ZpbGVOYW1lfWApO1xyXG4gICAgY29uc3QgeyBlcnJvcjogdXBsb2FkRXJyb3IsIGRhdGE6IHN0b3JhZ2VEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZS5zdG9yYWdlXHJcbiAgICAgIC5mcm9tKCdkb2N1bWVudHMnKVxyXG4gICAgICAudXBsb2FkKGZpbGVOYW1lLCBmaWxlLCB7XHJcbiAgICAgICAgY2FjaGVDb250cm9sOiAnMzYwMCcsXHJcbiAgICAgICAgdXBzZXJ0OiBmYWxzZVxyXG4gICAgICB9KTtcclxuXHJcbiAgICBpZiAodXBsb2FkRXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignU3RvcmFnZSB1cGxvYWQgZXJyb3I6JywgSlNPTi5zdHJpbmdpZnkodXBsb2FkRXJyb3IpKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdG9yYWdlIHVwbG9hZCBlcnJvcjogJHtKU09OLnN0cmluZ2lmeSh1cGxvYWRFcnJvcil9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coJ0ZpbGUgc3VjY2Vzc2Z1bGx5IHVwbG9hZGVkIHRvIHN0b3JhZ2UsIGdldHRpbmcgcHVibGljIFVSTCcpO1xyXG4gICAgLy8gR2V0IHRoZSBwdWJsaWMgVVJMXHJcbiAgICBjb25zdCB7IGRhdGE6IHsgcHVibGljVXJsIH0gfSA9IHN1cGFiYXNlLnN0b3JhZ2VcclxuICAgICAgLmZyb20oJ2RvY3VtZW50cycpXHJcbiAgICAgIC5nZXRQdWJsaWNVcmwoZmlsZU5hbWUpO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKGBQdWJsaWMgVVJMIGdlbmVyYXRlZDogJHtwdWJsaWNVcmx9YCk7XHJcbiAgICBcclxuICAgIC8vIENyZWF0ZSBkYXRhYmFzZSByZWNvcmRcclxuICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBkYXRhYmFzZSByZWNvcmQgZm9yIHRoZSB1cGxvYWRlZCBmaWxlJyk7XHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnZG9jdW1lbnRzJylcclxuICAgICAgLmluc2VydChbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgdGl0bGU6IGZpbGUubmFtZSxcclxuICAgICAgICAgIGZpbGVfcGF0aDogZmlsZU5hbWUsXHJcbiAgICAgICAgICBmaWxlX3R5cGU6IGZpbGUudHlwZSxcclxuICAgICAgICAgIGZpbGVfc2l6ZTogZmlsZS5zaXplLFxyXG4gICAgICAgICAgY29udGVudDogdGV4dENvbnRlbnQsXHJcbiAgICAgICAgICBwdWJsaWNfdXJsOiBwdWJsaWNVcmxcclxuICAgICAgICB9XHJcbiAgICAgIF0pXHJcbiAgICAgIC5zZWxlY3QoKTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRGF0YWJhc2UgaW5zZXJ0IGVycm9yOicsIEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YWJhc2UgaW5zZXJ0IGVycm9yOiAke0pTT04uc3RyaW5naWZ5KGVycm9yKX1gKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ0RvY3VtZW50IHN1Y2Nlc3NmdWxseSB1cGxvYWRlZCBhbmQgcmVjb3JkZWQgaW4gZGF0YWJhc2UnKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkOiBkYXRhWzBdLmlkLFxyXG4gICAgICBuYW1lOiBkYXRhWzBdLnRpdGxlLFxyXG4gICAgICB0eXBlOiAnZG9jdW1lbnQnLFxyXG4gICAgICBjb250ZW50OiB0ZXh0Q29udGVudCxcclxuICAgICAgc2l6ZTogZm9ybWF0RmlsZVNpemUoZGF0YVswXS5maWxlX3NpemUpLFxyXG4gICAgICB1cGxvYWREYXRlOiBuZXcgRGF0ZShkYXRhWzBdLmNyZWF0ZWRfYXQpLFxyXG4gICAgICB1cmw6IGRhdGFbMF0ucHVibGljX3VybFxyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignVXBsb2FkIGRvY3VtZW50IGVycm9yOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBVcGxvYWRzIGEgc3ByZWFkc2hlZXQgdG8gU3VwYWJhc2Ugc3RvcmFnZSBhbmQgZGF0YWJhc2VcclxuICovXHJcbmNvbnN0IHVwbG9hZFNwcmVhZHNoZWV0ID0gYXN5bmMgKGZpbGUpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc29sZS5sb2coYFByb2Nlc3Npbmcgc3ByZWFkc2hlZXQ6ICR7ZmlsZS5uYW1lfSwgdHlwZTogJHtmaWxlLnR5cGV9LCBzaXplOiAke2ZpbGUuc2l6ZX0gYnl0ZXNgKTtcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBjb250ZW50IGZyb20gRXhjZWxcclxuICAgIGxldCB0ZXh0Q29udGVudCA9ICcnO1xyXG4gICAgbGV0IHN0cnVjdHVyZWREYXRhID0gbnVsbDtcclxuICAgIFxyXG4gICAgaWYgKGZpbGUubmFtZS5lbmRzV2l0aCgnLnhsc3gnKSB8fCBmaWxlLm5hbWUuZW5kc1dpdGgoJy54bHMnKSB8fCBmaWxlLnR5cGUuaW5jbHVkZXMoJ2V4Y2VsJykpIHtcclxuICAgICAgY29uc29sZS5sb2coJ1Byb2Nlc3NpbmcgYXMgRXhjZWwuLi4nKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB0ZXh0Q29udGVudCA9IGF3YWl0IGV4dHJhY3RUZXh0RnJvbUV4Y2VsKGZpbGUpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBFeGNlbCBwcm9jZXNzaW5nIGNvbXBsZXRlLCBleHRyYWN0ZWQgJHt0ZXh0Q29udGVudC5sZW5ndGh9IGNoYXJhY3RlcnNgKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBHZW5lcmF0ZSBzdHJ1Y3R1cmVkIGRhdGEgZnJvbSB0aGUgdGV4dCBjb250ZW50XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8vIFBhcnNlIHRoZSB0ZXh0IGNvbnRlbnQgaW50byBhIHNpbXBsZSBzdHJ1Y3R1cmVkIGZvcm1hdFxyXG4gICAgICAgICAgLy8gVGhpcyBpcyBhIHNpbXBsaWZpZWQgdmVyc2lvbiAtIGluIGEgcmVhbCBhcHAsIHlvdSB3b3VsZCBkbyBtb3JlIHNvcGhpc3RpY2F0ZWQgcGFyc2luZ1xyXG4gICAgICAgICAgY29uc3QgbGluZXMgPSB0ZXh0Q29udGVudC5zcGxpdCgnXFxuJykuZmlsdGVyKGxpbmUgPT4gbGluZS50cmltKCkpO1xyXG4gICAgICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IFtdO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBsZXQgY3VycmVudFNoZWV0ID0gbnVsbDtcclxuICAgICAgICAgIGxldCBjdXJyZW50U2hlZXREYXRhID0gW107XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xyXG4gICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKCctLS0gU2hlZXQ6JykpIHtcclxuICAgICAgICAgICAgICAvLyBOZXcgc2hlZXQgZm91bmQsIHNhdmUgdGhlIHByZXZpb3VzIHNoZWV0IGlmIGl0IGV4aXN0c1xyXG4gICAgICAgICAgICAgIGlmIChjdXJyZW50U2hlZXQgJiYgY3VycmVudFNoZWV0RGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZWREYXRhLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICBuYW1lOiBjdXJyZW50U2hlZXQsXHJcbiAgICAgICAgICAgICAgICAgIGRhdGE6IGN1cnJlbnRTaGVldERhdGFcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBTdGFydCBhIG5ldyBzaGVldFxyXG4gICAgICAgICAgICAgIGN1cnJlbnRTaGVldCA9IGxpbmUucmVwbGFjZSgnLS0tIFNoZWV0OicsICcnKS5yZXBsYWNlKCctLS0nLCAnJykudHJpbSgpO1xyXG4gICAgICAgICAgICAgIGN1cnJlbnRTaGVldERhdGEgPSBbXTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50U2hlZXQgJiYgbGluZS50cmltKCkpIHtcclxuICAgICAgICAgICAgICAvLyBBZGQgZGF0YSByb3cgdG8gY3VycmVudCBzaGVldFxyXG4gICAgICAgICAgICAgIGNvbnN0IHJvd0RhdGEgPSBsaW5lLnNwbGl0KC9cXHN7Myx9LykubWFwKGNlbGwgPT4gY2VsbC50cmltKCkpO1xyXG4gICAgICAgICAgICAgIGlmIChyb3dEYXRhLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRTaGVldERhdGEucHVzaChyb3dEYXRhKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gQWRkIHRoZSBsYXN0IHNoZWV0IGlmIGl0IGV4aXN0c1xyXG4gICAgICAgICAgaWYgKGN1cnJlbnRTaGVldCAmJiBjdXJyZW50U2hlZXREYXRhLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcGFyc2VkRGF0YS5wdXNoKHtcclxuICAgICAgICAgICAgICBuYW1lOiBjdXJyZW50U2hlZXQsXHJcbiAgICAgICAgICAgICAgZGF0YTogY3VycmVudFNoZWV0RGF0YVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgc3RydWN0dXJlZERhdGEgPSBKU09OLnN0cmluZ2lmeShwYXJzZWREYXRhKTtcclxuICAgICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIEV4Y2VsIGRhdGEgaW50byBzdHJ1Y3R1cmVkIGZvcm1hdDonLCBwYXJzZUVycm9yKTtcclxuICAgICAgICAgIHN0cnVjdHVyZWREYXRhID0gSlNPTi5zdHJpbmdpZnkoW3sgbmFtZTogJ1NoZWV0MScsIGRhdGE6IFtbJ0Vycm9yIHBhcnNpbmcgZGF0YSddXSB9XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIExpbWl0IHRoZSB0ZXh0IGNvbnRlbnQgc2l6ZVxyXG4gICAgICAgIGlmICh0ZXh0Q29udGVudC5sZW5ndGggPiAxMDAwMDAwKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgVGV4dCBjb250ZW50IHRvbyBsYXJnZSAoJHt0ZXh0Q29udGVudC5sZW5ndGh9IGNoYXJzKSwgdHJ1bmNhdGluZy4uLmApO1xyXG4gICAgICAgICAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5zdWJzdHJpbmcoMCwgMTAwMDAwMCkgKyAnLi4uIFtjb250ZW50IHRydW5jYXRlZF0nO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXhjZWxFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0V4Y2VsIGV4dHJhY3Rpb24gZXJyb3I6JywgZXhjZWxFcnJvcik7XHJcbiAgICAgICAgdGV4dENvbnRlbnQgPSBgRXJyb3IgZXh0cmFjdGluZyBFeGNlbCBjb250ZW50OiAke2V4Y2VsRXJyb3IubWVzc2FnZX1gO1xyXG4gICAgICAgIHN0cnVjdHVyZWREYXRhID0gSlNPTi5zdHJpbmdpZnkoW3sgbmFtZTogJ0Vycm9yJywgZGF0YTogW1snRmFpbGVkIHRvIGV4dHJhY3QgZGF0YSddXSB9XSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBVbnN1cHBvcnRlZCBzcHJlYWRzaGVldCB0eXBlOiAke2ZpbGUudHlwZX0sIG5vIHRleHQgZXh0cmFjdGlvbiBwZXJmb3JtZWRgKTtcclxuICAgICAgc3RydWN0dXJlZERhdGEgPSBKU09OLnN0cmluZ2lmeShbeyBuYW1lOiAnVW5rbm93bicsIGRhdGE6IFtbJ05vIERhdGEnXSwgWydVbnN1cHBvcnRlZCBmaWxlIGZvcm1hdCddXSB9XSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFVwbG9hZCBmaWxlIHRvIFN1cGFiYXNlIFN0b3JhZ2VcclxuICAgIGNvbnN0IGZpbGVOYW1lID0gYCR7RGF0ZS5ub3coKX0tJHtmaWxlLm5hbWV9YDtcclxuICAgIGNvbnNvbGUubG9nKGBVcGxvYWRpbmcgZmlsZSB0byBTdXBhYmFzZSBzdG9yYWdlIGJ1Y2tldCAnc3ByZWFkc2hlZXRzJyB3aXRoIG5hbWU6ICR7ZmlsZU5hbWV9YCk7XHJcbiAgICBjb25zdCB7IGVycm9yOiB1cGxvYWRFcnJvciwgZGF0YTogc3RvcmFnZURhdGEgfSA9IGF3YWl0IHN1cGFiYXNlLnN0b3JhZ2VcclxuICAgICAgLmZyb20oJ3NwcmVhZHNoZWV0cycpXHJcbiAgICAgIC51cGxvYWQoZmlsZU5hbWUsIGZpbGUsIHtcclxuICAgICAgICBjYWNoZUNvbnRyb2w6ICczNjAwJyxcclxuICAgICAgICB1cHNlcnQ6IGZhbHNlXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGlmICh1cGxvYWRFcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdTdG9yYWdlIHVwbG9hZCBlcnJvcjonLCBKU09OLnN0cmluZ2lmeSh1cGxvYWRFcnJvcikpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0b3JhZ2UgdXBsb2FkIGVycm9yOiAke0pTT04uc3RyaW5naWZ5KHVwbG9hZEVycm9yKX1gKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZygnRmlsZSBzdWNjZXNzZnVsbHkgdXBsb2FkZWQgdG8gc3RvcmFnZSwgZ2V0dGluZyBwdWJsaWMgVVJMJyk7XHJcbiAgICAvLyBHZXQgdGhlIHB1YmxpYyBVUkxcclxuICAgIGNvbnN0IHsgZGF0YTogeyBwdWJsaWNVcmwgfSB9ID0gc3VwYWJhc2Uuc3RvcmFnZVxyXG4gICAgICAuZnJvbSgnc3ByZWFkc2hlZXRzJylcclxuICAgICAgLmdldFB1YmxpY1VybChmaWxlTmFtZSk7XHJcblxyXG4gICAgY29uc29sZS5sb2coYFB1YmxpYyBVUkwgZ2VuZXJhdGVkOiAke3B1YmxpY1VybH1gKTtcclxuICAgIFxyXG4gICAgLy8gQ3JlYXRlIGRhdGFiYXNlIHJlY29yZFxyXG4gICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIGRhdGFiYXNlIHJlY29yZCBmb3IgdGhlIHVwbG9hZGVkIGZpbGUnKTtcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdkb2N1bWVudHMnKVxyXG4gICAgICAuaW5zZXJ0KFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICB0aXRsZTogZmlsZS5uYW1lLFxyXG4gICAgICAgICAgZmlsZV9wYXRoOiBmaWxlTmFtZSxcclxuICAgICAgICAgIGZpbGVfdHlwZTogYHNwcmVhZHNoZWV0LyR7ZmlsZS50eXBlfWAsXHJcbiAgICAgICAgICBmaWxlX3NpemU6IGZpbGUuc2l6ZSxcclxuICAgICAgICAgIGNvbnRlbnQ6IHRleHRDb250ZW50LFxyXG4gICAgICAgICAgc3RydWN0dXJlZF9kYXRhOiBzdHJ1Y3R1cmVkRGF0YSxcclxuICAgICAgICAgIHB1YmxpY191cmw6IHB1YmxpY1VybFxyXG4gICAgICAgIH1cclxuICAgICAgXSlcclxuICAgICAgLnNlbGVjdCgpO1xyXG5cclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdEYXRhYmFzZSBpbnNlcnQgZXJyb3I6JywgSlNPTi5zdHJpbmdpZnkoZXJyb3IpKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhYmFzZSBpbnNlcnQgZXJyb3I6ICR7SlNPTi5zdHJpbmdpZnkoZXJyb3IpfWApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnU3ByZWFkc2hlZXQgc3VjY2Vzc2Z1bGx5IHVwbG9hZGVkIGFuZCByZWNvcmRlZCBpbiBkYXRhYmFzZScpO1xyXG4gICAgLy8gUmV0dXJuIGZvcm1hdHRlZCBzcHJlYWRzaGVldCB3aXRoIGNvbnRlbnRcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkOiBkYXRhWzBdLmlkLFxyXG4gICAgICBuYW1lOiBkYXRhWzBdLnRpdGxlLFxyXG4gICAgICB0eXBlOiAnc3ByZWFkc2hlZXQnLFxyXG4gICAgICBjb250ZW50OiB0ZXh0Q29udGVudCxcclxuICAgICAgZGF0YTogSlNPTi5wYXJzZShkYXRhWzBdLnN0cnVjdHVyZWRfZGF0YSB8fCAnW1tdXScpLFxyXG4gICAgICBzaXplOiBmb3JtYXRGaWxlU2l6ZShkYXRhWzBdLmZpbGVfc2l6ZSksXHJcbiAgICAgIHVwbG9hZERhdGU6IG5ldyBEYXRlKGRhdGFbMF0uY3JlYXRlZF9hdCksXHJcbiAgICAgIHVybDogZGF0YVswXS5wdWJsaWNfdXJsXHJcbiAgICB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdVcGxvYWQgc3ByZWFkc2hlZXQgZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHJpZXZlcyBhbGwgZmlsZXMgZnJvbSBTdXBhYmFzZVxyXG4gKi9cclxuY29uc3QgZ2V0RmlsZXMgPSBhc3luYyAoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBhbGwgZmlsZXMgZnJvbSBkYXRhYmFzZScpO1xyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ2RvY3VtZW50cycpXHJcbiAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XHJcblxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGZpbGVzOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coYFJldHJpZXZlZCAke2RhdGEubGVuZ3RofSBmaWxlcyBmcm9tIGRhdGFiYXNlYCk7XHJcbiAgICBcclxuICAgIHJldHVybiBkYXRhLm1hcChmaWxlID0+IHtcclxuICAgICAgaWYgKGZpbGUuZmlsZV90eXBlICYmIGZpbGUuZmlsZV90eXBlLmluY2x1ZGVzKCdzcHJlYWRzaGVldCcpKSB7XHJcbiAgICAgICAgLy8gTG9nIGZvciBkZWJ1Z2dpbmdcclxuICAgICAgICBjb25zb2xlLmxvZyhgUHJvY2Vzc2luZyBzcHJlYWRzaGVldDogJHtmaWxlLnRpdGxlfSwgY29udGVudCBsZW5ndGg6ICR7ZmlsZS5jb250ZW50ID8gZmlsZS5jb250ZW50Lmxlbmd0aCA6IDB9YCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUmV0dXJuIGFzIFNwcmVhZHNoZWV0IHR5cGVcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgaWQ6IGZpbGUuaWQsXHJcbiAgICAgICAgICBuYW1lOiBmaWxlLnRpdGxlIHx8IGZpbGUubmFtZSB8fCAnVW5uYW1lZCBTcHJlYWRzaGVldCcsXHJcbiAgICAgICAgICB0eXBlOiAnc3ByZWFkc2hlZXQnLFxyXG4gICAgICAgICAgY29udGVudDogZmlsZS5jb250ZW50IHx8ICcnLCAvLyBJbXBvcnRhbnQ6IGluY2x1ZGUgY29udGVudFxyXG4gICAgICAgICAgZGF0YTogZmlsZS5zdHJ1Y3R1cmVkX2RhdGEgPyBKU09OLnBhcnNlKGZpbGUuc3RydWN0dXJlZF9kYXRhKSA6IFtbXV0sXHJcbiAgICAgICAgICBzaXplOiBmb3JtYXRGaWxlU2l6ZShmaWxlLmZpbGVfc2l6ZSB8fCAwKSxcclxuICAgICAgICAgIHVwbG9hZERhdGU6IG5ldyBEYXRlKGZpbGUuY3JlYXRlZF9hdCksXHJcbiAgICAgICAgICB1cmw6IGZpbGUucHVibGljX3VybFxyXG4gICAgICAgIH07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gTG9nIGZvciBkZWJ1Z2dpbmdcclxuICAgICAgICBjb25zb2xlLmxvZyhgUHJvY2Vzc2luZyBkb2N1bWVudDogJHtmaWxlLnRpdGxlfSwgY29udGVudCBsZW5ndGg6ICR7ZmlsZS5jb250ZW50ID8gZmlsZS5jb250ZW50Lmxlbmd0aCA6IDB9YCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUmV0dXJuIGFzIERvY3VtZW50IHR5cGVcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgaWQ6IGZpbGUuaWQsXHJcbiAgICAgICAgICBuYW1lOiBmaWxlLnRpdGxlIHx8IGZpbGUubmFtZSB8fCAnVW5uYW1lZCBEb2N1bWVudCcsXHJcbiAgICAgICAgICB0eXBlOiAnZG9jdW1lbnQnLFxyXG4gICAgICAgICAgY29udGVudDogZmlsZS5jb250ZW50IHx8ICcnLCAvLyBNYWtlIHN1cmUgY29udGVudCBpcyByZXR1cm5lZFxyXG4gICAgICAgICAgc2l6ZTogZm9ybWF0RmlsZVNpemUoZmlsZS5maWxlX3NpemUgfHwgMCksXHJcbiAgICAgICAgICB1cGxvYWREYXRlOiBuZXcgRGF0ZShmaWxlLmNyZWF0ZWRfYXQpLFxyXG4gICAgICAgICAgdXJsOiBmaWxlLnB1YmxpY191cmxcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdDb3VsZCBub3QgZmV0Y2ggZmlsZXMgZnJvbSBTdXBhYmFzZTonLCBlKTtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRGVsZXRlcyBhIGZpbGUgYnkgSURcclxuICovXHJcbmNvbnN0IGRlbGV0ZUZpbGUgPSBhc3luYyAoaWQpID0+IHtcclxuICB0cnkge1xyXG4gICAgLy8gRmlyc3QgZ2V0IHRoZSBmaWxlIGluZm8gdG8gZ2V0IHRoZSBzdG9yYWdlIHBhdGhcclxuICAgIGNvbnN0IHsgZGF0YTogZmlsZSB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ2RvY3VtZW50cycpXHJcbiAgICAgIC5zZWxlY3QoJ2ZpbGVfcGF0aCwgZmlsZV90eXBlJylcclxuICAgICAgLmVxKCdpZCcsIGlkKVxyXG4gICAgICAuc2luZ2xlKCk7XHJcblxyXG4gICAgaWYgKGZpbGUpIHtcclxuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBzdG9yYWdlIGJ1Y2tldCBiYXNlZCBvbiBmaWxlIHR5cGVcclxuICAgICAgY29uc3QgYnVja2V0ID0gZmlsZS5maWxlX3R5cGUuaW5jbHVkZXMoJ3NwcmVhZHNoZWV0JykgPyAnc3ByZWFkc2hlZXRzJyA6ICdkb2N1bWVudHMnO1xyXG4gICAgICBcclxuICAgICAgLy8gRGVsZXRlIGZyb20gc3RvcmFnZVxyXG4gICAgICBjb25zdCB7IGVycm9yOiBzdG9yYWdlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLnN0b3JhZ2VcclxuICAgICAgICAuZnJvbShidWNrZXQpXHJcbiAgICAgICAgLnJlbW92ZShbZmlsZS5maWxlX3BhdGhdKTtcclxuXHJcbiAgICAgIGlmIChzdG9yYWdlRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdTdG9yYWdlIGRlbGV0ZSBlcnJvcjonLCBzdG9yYWdlRXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGVsZXRlIGZyb20gZGF0YWJhc2VcclxuICAgIGNvbnN0IHsgZXJyb3I6IGRiRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdkb2N1bWVudHMnKVxyXG4gICAgICAuZGVsZXRlKClcclxuICAgICAgLmVxKCdpZCcsIGlkKTtcclxuXHJcbiAgICBpZiAoZGJFcnJvcikgdGhyb3cgZGJFcnJvcjtcclxuICAgIFxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIGZpbGU6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGZpbGVzU2VydmljZSA9IHtcclxuICB1cGxvYWREb2N1bWVudCxcclxuICB1cGxvYWRTcHJlYWRzaGVldCxcclxuICBnZXRGaWxlcyxcclxuICBkZWxldGVGaWxlLFxyXG4gIGV4dHJhY3RUZXh0RnJvbVBERixcclxuICBleHRyYWN0VGV4dEZyb21FeGNlbFxyXG59OyAiXSwibmFtZXMiOlsic3VwYWJhc2UiLCJTS0lQX1BERl9URVhUX0VYVFJBQ1RJT04iLCJmb3JtYXRGaWxlU2l6ZSIsImJ5dGVzIiwidG9GaXhlZCIsImV4dHJhY3RUZXh0RnJvbVBERiIsImZpbGUiLCJwZGZqc0xpYiIsIkdsb2JhbFdvcmtlck9wdGlvbnMiLCJ3b3JrZXJTcmMiLCJ2ZXJzaW9uIiwiYXJyYXlCdWZmZXIiLCJjb25zb2xlIiwibG9nIiwibmFtZSIsInNpemUiLCJwZGYiLCJnZXREb2N1bWVudCIsImRhdGEiLCJwcm9taXNlIiwibnVtUGFnZXMiLCJmdWxsVGV4dCIsImkiLCJwYWdlIiwiZ2V0UGFnZSIsInRleHRDb250ZW50IiwiZ2V0VGV4dENvbnRlbnQiLCJwYWdlVGV4dCIsIml0ZW1zIiwibWFwIiwiaXRlbSIsInN0ciIsImpvaW4iLCJsZW5ndGgiLCJwYWdlRXJyb3IiLCJlcnJvciIsInRyaW0iLCJ3YXJuIiwicGRmRXJyb3IiLCJtZXNzYWdlIiwiZXh0cmFjdFRleHRGcm9tRXhjZWwiLCJYTFNYIiwid29ya2Jvb2siLCJyZWFkIiwidHlwZSIsIlNoZWV0TmFtZXMiLCJmb3JFYWNoIiwic2hlZXROYW1lIiwic2hlZXQiLCJTaGVldHMiLCJqc29uRGF0YSIsInV0aWxzIiwic2hlZXRfdG9fanNvbiIsImhlYWRlciIsImNvbHVtbldpZHRocyIsInJvdyIsImNlbGwiLCJqIiwiY2VsbFZhbHVlIiwiU3RyaW5nIiwiTWF0aCIsIm1pbiIsInJvd0luZGV4Iiwic29tZSIsInVuZGVmaW5lZCIsImZvcm1hdHRlZFJvdyIsImNvbEluZGV4IiwicGFkRW5kIiwicmVwZWF0IiwidXBsb2FkRG9jdW1lbnQiLCJzdWJzdHJpbmciLCJmaWxlTmFtZSIsIkRhdGUiLCJub3ciLCJ1cGxvYWRFcnJvciIsInN0b3JhZ2VEYXRhIiwic3RvcmFnZSIsImZyb20iLCJ1cGxvYWQiLCJjYWNoZUNvbnRyb2wiLCJ1cHNlcnQiLCJKU09OIiwic3RyaW5naWZ5IiwiRXJyb3IiLCJwdWJsaWNVcmwiLCJnZXRQdWJsaWNVcmwiLCJpbnNlcnQiLCJ0aXRsZSIsImZpbGVfcGF0aCIsImZpbGVfdHlwZSIsImZpbGVfc2l6ZSIsImNvbnRlbnQiLCJwdWJsaWNfdXJsIiwic2VsZWN0IiwiaWQiLCJ1cGxvYWREYXRlIiwiY3JlYXRlZF9hdCIsInVybCIsInVwbG9hZFNwcmVhZHNoZWV0Iiwic3RydWN0dXJlZERhdGEiLCJlbmRzV2l0aCIsImluY2x1ZGVzIiwibGluZXMiLCJzcGxpdCIsImZpbHRlciIsImxpbmUiLCJwYXJzZWREYXRhIiwiY3VycmVudFNoZWV0IiwiY3VycmVudFNoZWV0RGF0YSIsInN0YXJ0c1dpdGgiLCJwdXNoIiwicmVwbGFjZSIsInJvd0RhdGEiLCJwYXJzZUVycm9yIiwiZXhjZWxFcnJvciIsInN0cnVjdHVyZWRfZGF0YSIsInBhcnNlIiwiZ2V0RmlsZXMiLCJvcmRlciIsImFzY2VuZGluZyIsImUiLCJkZWxldGVGaWxlIiwiZXEiLCJzaW5nbGUiLCJidWNrZXQiLCJzdG9yYWdlRXJyb3IiLCJyZW1vdmUiLCJkYkVycm9yIiwiZGVsZXRlIiwiZmlsZXNTZXJ2aWNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/services/filesService.js\n"));

/***/ })

});