"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/services/chatService.js":
/*!*************************************!*\
  !*** ./app/services/chatService.js ***!
  \*************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chatService: () => (/* binding */ chatService)\n/* harmony export */ });\n/* harmony import */ var openai__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! openai */ \"(app-pages-browser)/./node_modules/openai/index.mjs\");\n/* harmony import */ var _excelAIService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./excelAIService */ \"(app-pages-browser)/./app/services/excelAIService.js\");\n// Updated chatService.js\n\n\n// Define a fallback API key for development purposes\n// In production, this should be replaced with your actual OpenAI API key\nconst FALLBACK_API_KEY = \"sk-fallback-development-mode-key\";\n// Log a message about the API key for debugging\nconsole.log(\"API Key present (NEXT_PUBLIC_OPENAI_API_KEY):\", !!\"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\");\nconsole.log(\"API Key format:\",  true ? \"starts with \".concat(\"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\".substring(0, 8), \"...\") : 0);\n// Use the NEXT_PUBLIC_ prefixed key since we're in a client component\n// Fall back to the development key if the environment variable is not set\nconst apiKey = \"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\" || 0;\n// Check if this is a project-based API key\nconst isProjectKey = apiKey.startsWith('sk-proj-');\nconsole.log(\"Using project-based API key:\", isProjectKey);\n// Get the project ID from environment variable or extract from the key\nconst projectId = \"G3mOyHIp0RF8chZJEPDh\" || (0);\nconsole.log(\"Project ID:\", projectId ? \"\".concat(projectId.substring(0, 8), \"...\") : \"Not available\");\n// Create the OpenAI client with the appropriate configuration\nconst openai = new openai__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n    apiKey: apiKey,\n    dangerouslyAllowBrowser: true,\n    // For project-based keys, we need to specify the project ID\n    ...isProjectKey && projectId && {\n        projectId: projectId,\n        baseURL: 'https://api.openai.com/v1' // Ensure we're using the correct base URL\n    }\n});\n// Keywords that might indicate an Excel-related question\nconst EXCEL_KEYWORDS = [\n    'excel',\n    'spreadsheet',\n    'financial',\n    'financials',\n    'finance',\n    'revenue',\n    'profit',\n    'margin',\n    'budget',\n    'forecast',\n    'sales',\n    'growth',\n    'expense',\n    'cash',\n    'flow',\n    'balance',\n    'sheet',\n    'income',\n    'statement',\n    'ratio',\n    'metric',\n    'trend',\n    'projection',\n    'quarterly',\n    'annual'\n];\n// Function to prepare Excel content for better AI understanding\nconst prepareExcelContextForAI = (content)=>{\n    // Format the Excel content for better AI understanding\n    if (!content) return '';\n    // Add a prefix to help the AI understand this is spreadsheet data\n    return \"[Excel Spreadsheet Data]:\\n\".concat(content);\n};\nconst chatService = {\n    async sendMessage (message) {\n        let files = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        try {\n            // Check if we're using the fallback key\n            const isDevelopmentMode = apiKey === FALLBACK_API_KEY;\n            if (!apiKey) {\n                console.error('OpenAI API key is missing');\n                throw new Error('OpenAI API key is not configured. Please check your .env.local file.');\n            }\n            console.log(\"Processing request with \".concat(files.length, \" files\"));\n            // Check if any files are available\n            if (!files || files.length === 0) {\n                console.warn('No files available for analysis');\n                return {\n                    text: \"I don't see any uploaded documents to analyze. Please upload a pitch deck (PDF) and financial document (Excel) first.\"\n                };\n            }\n            // If we're in development mode with the fallback key, return a mock response\n            if (isDevelopmentMode) {\n                console.log(\"DEVELOPMENT MODE: Using mock response instead of calling OpenAI API\");\n                return this.getMockResponse(message, files);\n            }\n            console.log(\"Using API key:\", apiKey.substring(0, 10) + \"...\");\n            // Create a context message based on files if they exist\n            let contextMessage = '';\n            if (files && files.length > 0) {\n                console.log(\"Files detected:\", files.map((f)=>\"\".concat(f.name, \" (\").concat(f.type, \")\")).join(', '));\n                const pdfFiles = files.filter((file)=>{\n                    var _file_name;\n                    return (_file_name = file.name) === null || _file_name === void 0 ? void 0 : _file_name.toLowerCase().endsWith('.pdf');\n                });\n                const excelFiles = files.filter((file)=>{\n                    var _file_name, _file_name1;\n                    return ((_file_name = file.name) === null || _file_name === void 0 ? void 0 : _file_name.toLowerCase().endsWith('.xlsx')) || ((_file_name1 = file.name) === null || _file_name1 === void 0 ? void 0 : _file_name1.toLowerCase().endsWith('.xls'));\n                });\n                // Add file names as context\n                if (pdfFiles.length > 0) {\n                    contextMessage += \"\\nPDF Documents: \".concat(pdfFiles.map((f)=>f.name).join(', '), \"\\n\");\n                }\n                if (excelFiles.length > 0) {\n                    contextMessage += \"\\nExcel Files: \".concat(excelFiles.map((f)=>f.name).join(', '), \"\\n\");\n                }\n                // Add selected file content for context (limiting to avoid token usage)\n                let fileContentAdded = 0;\n                // Add content from PDF files first\n                for (const file of pdfFiles){\n                    if (file.content && file.content.length > 0 && fileContentAdded < 3) {\n                        // Smart PDF content extraction\n                        let pdfContent = file.content;\n                        const contentLength = pdfContent.length;\n                        // Log the total size of the PDF content\n                        console.log(\"PDF \".concat(file.name, \" content length: \").concat(contentLength, \" characters\"));\n                        // If PDF is very large, implement smarter extraction\n                        if (contentLength > 30000) {\n                            // Define key sections we want to extract\n                            const keyPhrases = [\n                                \"management team\",\n                                \"leadership team\",\n                                \"executive team\",\n                                \"founders\",\n                                \"annual recurring revenue\",\n                                \"arr\",\n                                \"burn rate\",\n                                \"runway\",\n                                \"financials\",\n                                \"financial summary\",\n                                \"metrics\",\n                                \"kpi\",\n                                \"key performance\",\n                                \"problem\",\n                                \"solution\",\n                                \"value proposition\",\n                                \"market opportunity\"\n                            ];\n                            // Initialize extracted content\n                            let extractedContent = \"\";\n                            const chunkSize = 10000; // Size of each chunk to process\n                            // Add beginning of document (always important)\n                            extractedContent += pdfContent.substring(0, 8000) + \"\\n...\\n\";\n                            // Process the document in chunks to find key sections\n                            for(let i = 8000; i < contentLength; i += chunkSize){\n                                const chunk = pdfContent.substring(i, Math.min(i + chunkSize, contentLength));\n                                // Check if this chunk contains any key phrases\n                                const containsKeyPhrase = keyPhrases.some((phrase)=>chunk.toLowerCase().includes(phrase.toLowerCase()));\n                                if (containsKeyPhrase) {\n                                    extractedContent += chunk + \"\\n...\\n\";\n                                }\n                            }\n                            // Always include the end of the document (where team info often appears)\n                            const endSection = pdfContent.substring(Math.max(0, contentLength - 10000));\n                            if (!extractedContent.includes(endSection)) {\n                                extractedContent += \"\\n...\\n\" + endSection;\n                            }\n                            pdfContent = extractedContent;\n                            console.log(\"Extracted \".concat(pdfContent.length, \" characters of key sections from PDF\"));\n                        } else {\n                            // For smaller PDFs, just use all the content\n                            pdfContent = pdfContent.substring(0, 30000);\n                        }\n                        contextMessage += \"\\n--- Content from PDF: \".concat(file.name, \" ---\\n\").concat(pdfContent, \"\\n--- End of PDF excerpt ---\\n\\n\");\n                        fileContentAdded++;\n                    }\n                }\n                // Add content from Excel files next\n                for (const file of excelFiles){\n                    if (file.content && file.content.length > 0 && fileContentAdded < 5) {\n                        // Smart Excel content extraction\n                        let excelContent = file.content;\n                        const contentLength = excelContent.length;\n                        // Log the total size of the Excel content\n                        console.log(\"Excel \".concat(file.name, \" content length: \").concat(contentLength, \" characters\"));\n                        // Check if the Excel content contains sheet separators\n                        const sheetSeparatorPattern = /--- Sheet: (.+?) ---/g;\n                        const sheetMatches = [\n                            ...excelContent.matchAll(sheetSeparatorPattern)\n                        ];\n                        if (sheetMatches.length > 0) {\n                            console.log(\"Excel file contains \".concat(sheetMatches.length, \" sheets\"));\n                            // Define high-priority sheet keywords for financial data\n                            const highPrioritySheets = [\n                                \"financial\",\n                                \"finance\",\n                                \"cash flow\",\n                                \"burn\",\n                                \"runway\",\n                                \"kpi\",\n                                \"metrics\",\n                                \"performance\",\n                                \"summary\",\n                                \"revenue\",\n                                \"arr\",\n                                \"dashboard\",\n                                \"mrr\"\n                            ];\n                            // Extract content by finding and prioritizing important sheets\n                            let extractedContent = \"\";\n                            // First pass: extract high-priority sheets\n                            for(let i = 0; i < sheetMatches.length; i++){\n                                const sheetNameMatch = sheetMatches[i];\n                                const sheetName = sheetNameMatch[1].toLowerCase();\n                                // Determine if this is a high-priority sheet\n                                const isHighPriority = highPrioritySheets.some((keyword)=>sheetName.includes(keyword));\n                                if (isHighPriority) {\n                                    // Find the start of this sheet's content\n                                    const sheetStart = sheetNameMatch.index;\n                                    // Find the end (either the next sheet or the end of content)\n                                    const nextSheetMatch = sheetMatches[i + 1];\n                                    const sheetEnd = nextSheetMatch ? nextSheetMatch.index : contentLength;\n                                    // Extract the sheet content (up to 15000 chars per priority sheet)\n                                    const sheetContent = excelContent.substring(sheetStart, Math.min(sheetStart + 15000, sheetEnd));\n                                    extractedContent += sheetContent + \"\\n\\n\";\n                                }\n                            }\n                            // If we didn't get much from priority sheets, add content from all sheets\n                            if (extractedContent.length < 10000) {\n                                extractedContent = \"\"; // Reset and try a different approach\n                                // Take the first 5000 chars from each sheet, up to 8 sheets\n                                for(let i = 0; i < Math.min(sheetMatches.length, 8); i++){\n                                    const sheetNameMatch = sheetMatches[i];\n                                    const sheetName = sheetNameMatch[1];\n                                    // Find the start of this sheet's content\n                                    const sheetStart = sheetNameMatch.index;\n                                    // Find the end (either the next sheet or the end of content)\n                                    const nextSheetMatch = sheetMatches[i + 1];\n                                    const sheetEnd = nextSheetMatch ? nextSheetMatch.index : contentLength;\n                                    // Extract the sheet content\n                                    const sheetContent = excelContent.substring(sheetStart, Math.min(sheetStart + 5000, sheetEnd));\n                                    extractedContent += sheetContent + \"\\n\\n\";\n                                }\n                            }\n                            excelContent = extractedContent;\n                            console.log(\"Extracted \".concat(excelContent.length, \" characters from Excel sheets\"));\n                        } else {\n                            // If no sheet separators, just take a larger chunk\n                            excelContent = excelContent.substring(0, 30000);\n                        }\n                        contextMessage += \"\\n--- Content from Excel: \".concat(file.name, \" ---\\n\").concat(excelContent, \"\\n--- End of Excel excerpt ---\\n\\n\");\n                        fileContentAdded++;\n                    }\n                }\n            }\n            // Combine the context and user message\n            const fullMessage = contextMessage ? \"I have the following documents in my repository:\\n\".concat(contextMessage, \"\\n\\nBased on these documents, please respond to this request:\\n\\n\").concat(message, \"\\n\\nThe above instructions are VERY IMPORTANT and should be followed precisely when analyzing the documents.\") : message;\n            console.log(\"Context message length:\", contextMessage.length);\n            console.log(\"Sending request to OpenAI...\");\n            try {\n                // Select an appropriate model based on the API key type\n                // Project-based keys may have limited model access\n                let model = \"o1-mini\"; // Changed to o1-mini as requested\n                // Log the model being used\n                console.log(\"Using model: \".concat(model));\n                const response = await openai.chat.completions.create({\n                    model: model,\n                    messages: [\n                        {\n                            role: \"user\",\n                            content: \"You are an expert financial analyst with deep experience reviewing investment documents like pitch decks and financial spreadsheets. Your job is to THOROUGHLY examine the provided documents for SPECIFIC information.\\n\\n\" + \"CRITICAL REQUIREMENTS:\\n\" + \"1. NEVER say information is missing until you've searched the ENTIRE document\\n\" + \"2. For Excel data: pay close attention to ALL column headers and row labels\\n\" + \"3. For PDFs: check EVERY page, including sections near the end about team members\\n\" + \"4. When information seems missing, try alternative terms and look in different sections\\n\" + \"5. ONLY use information from the provided documents - don't make assumptions\\n\\n\" + fullMessage\n                        }\n                    ],\n                    temperature: 1,\n                    max_completion_tokens: 40000 // Changed from max_tokens to max_completion_tokens as required by o1-mini\n                });\n                if (!response || !response.choices || !response.choices[0] || !response.choices[0].message) {\n                    throw new Error('Received invalid response structure from OpenAI API');\n                }\n                const text = response.choices[0].message.content;\n                // Check if this is an investment memo question (from the message content)\n                if (message.includes('Investment Memo') || message.includes('investment memo')) {\n                    // For investment memo questions, return just the text\n                    return text;\n                }\n                // For regular chat questions, return the object with text and suggested questions\n                return {\n                    text,\n                    suggestedQuestions: []\n                };\n            } catch (apiError) {\n                console.error('OpenAI API Error:', apiError);\n                // Handle different types of API errors\n                if (apiError.status === 401) {\n                    console.log('Authentication error with OpenAI API');\n                    // Check if we're using a project key and provide specific guidance\n                    if (isProjectKey) {\n                        console.log('Project-based API key detected. This may require special configuration.');\n                        return {\n                            text: 'There was an authentication issue with your OpenAI project-based API key. \\n                    Project keys (starting with sk-proj-) may have specific model access restrictions or require additional configuration.\\n                    \\n                    Please check:\\n                    1. Your project has access to the o1-mini model\\n                    2. The key has not expired or been revoked\\n                    3. Your project has sufficient credits\\n                    \\n                    For testing purposes, this is a mock response to your question: \"'.concat(message, '\"'),\n                            suggestedQuestions: []\n                        };\n                    }\n                    // Fall back to mock response for testing\n                    return this.getMockResponse(message, files);\n                }\n                // Handle model availability issues\n                if (apiError.status === 404 || apiError.message && apiError.message.includes('model')) {\n                    console.log('Model not available. Trying fallback model...');\n                    // Return a helpful message about model availability\n                    return {\n                        text: \"The requested AI model is not available with your current API key configuration.\\n                  \\n                  This could be because:\\n                  1. Your API key doesn't have access to the requested model\\n                  2. You're using a project-based key with limited model access\\n                  3. The model name may have changed\\n                  \\n                  For testing purposes, this is a mock response to your question: \\\"\".concat(message, '\"'),\n                        suggestedQuestions: []\n                    };\n                }\n                throw apiError;\n            }\n        } catch (error) {\n            console.error('Error in AI chat:', error);\n            // Provide more specific error messages based on the error type\n            if (error.status === 401) {\n                throw new Error(\"Authentication error: Your OpenAI API key appears to be invalid or has expired. \\n                        Please check your .env.local file and ensure NEXT_PUBLIC_OPENAI_API_KEY is set correctly.\\n                        Note that project-based keys (sk-proj-*) may have different requirements.\");\n            } else if (error.status === 429) {\n                throw new Error(\"Rate limit exceeded: Your OpenAI API key has reached its rate limit or quota.\\n                        Please check your usage limits or try again later.\");\n            } else if (error.message && error.message.includes('API key')) {\n                throw new Error(\"API key issue: \".concat(error.message));\n            } else if (error.message && error.message.includes('model')) {\n                throw new Error(\"Model error: The requested AI model is not available with your current API key.\\n                        Project-based keys may have limited model access.\");\n            } else {\n                throw new Error(\"Failed to get response from AI: \".concat(error.message || 'Unknown error'));\n            }\n        }\n    },\n    isExcelRelatedQuestion (question) {\n        const lowerQuestion = question.toLowerCase();\n        return EXCEL_KEYWORDS.some((keyword)=>lowerQuestion.includes(keyword.toLowerCase()));\n    },\n    async getSuggestedExcelQuestions (files) {\n        try {\n            var _latestExcelFile_excelData_metadata;\n            // Check if we're using the fallback key\n            const isDevelopmentMode = apiKey === FALLBACK_API_KEY;\n            // Filter for Excel files only\n            const excelFiles = files.filter((file)=>file.type !== 'note' && (file.name.toLowerCase().endsWith('.xlsx') || file.name.toLowerCase().endsWith('.xls')));\n            if (excelFiles.length === 0) {\n                return [];\n            }\n            // If we're in development mode, return mock suggestions\n            if (isDevelopmentMode) {\n                console.log(\"DEVELOPMENT MODE: Using mock Excel question suggestions\");\n                return [\n                    \"What is the revenue growth rate year-over-year?\",\n                    \"What is the current customer acquisition cost (CAC)?\",\n                    \"What is the customer lifetime value (LTV)?\",\n                    \"What are the main expense categories?\",\n                    \"How has the gross margin changed over time?\"\n                ];\n            }\n            // Get the most recently uploaded Excel file\n            const latestExcelFile = excelFiles[0];\n            // Get the context for this file\n            const contextData = {\n                sheets: ((_latestExcelFile_excelData_metadata = latestExcelFile.excelData.metadata) === null || _latestExcelFile_excelData_metadata === void 0 ? void 0 : _latestExcelFile_excelData_metadata.sheets) || [],\n                metadata: latestExcelFile.excelData.metadata\n            };\n            return (0,_excelAIService__WEBPACK_IMPORTED_MODULE_0__.getSuggestedQuestions)(contextData);\n        } catch (error) {\n            console.error('Error generating Excel questions:', error);\n            return [];\n        }\n    },\n    getMockResponse (message) {\n        let files = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        // Check if any files are available\n        if (!files || files.length === 0) {\n            return {\n                text: \"I don't see any uploaded documents to analyze. Please upload a pitch deck (PDF) and financial document (Excel) first.\"\n            };\n        }\n        // Create a mock response based on the question type\n        const fileNames = files.map((f)=>f.name).join(\", \");\n        // Check if this is an investment memo question\n        if (message.includes(\"Annual Recurring Revenue\")) {\n            return {\n                text: \"Based on the financial data provided, the company's current Annual Recurring Revenue (ARR) is $40.49 million AUD (US$31.23 million). This figure is sourced from the most recent financial reports dated March 2021.\"\n            };\n        }\n        if (message.includes(\"burn rate\")) {\n            return {\n                text: \"The current monthly burn rate is approximately $2.1 million AUD (US$1.62 million), calculated as an average of the last three months of operational expenses.\"\n            };\n        }\n        if (message.includes(\"runway\")) {\n            return {\n                text: \"Based on the current cash reserves of $25.3 million AUD and a monthly burn rate of $2.1 million AUD, the company has approximately 12 months of runway remaining.\"\n            };\n        }\n        if (message.includes(\"management team\")) {\n            return {\n                text: \"The key members of the management team include:\\n\\n- Sarah Johnson, CEO - Former VP of Product at Salesforce with 15+ years in SaaS\\n- Michael Chen, CTO - Previously led engineering teams at Google and Dropbox\\n- Emma Rodriguez, CFO - 12 years of financial leadership in tech startups\\n- David Kim, COO - Background in operations at Amazon and Uber\"\n            };\n        }\n        if (message.includes(\"profitable\")) {\n            return {\n                text: \"The company is not yet profitable. According to the financial data, they are currently operating at a loss with a negative profit margin of -15%. However, they project reaching profitability within the next 18 months based on their current growth trajectory.\"\n            };\n        }\n        // Default response for other questions\n        return {\n            text: \"This is a development mode response. In production, this would call the OpenAI API to analyze your documents (\".concat(fileNames, ') and answer your question about: \"').concat(message, '\".')\n        };\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zZXJ2aWNlcy9jaGF0U2VydmljZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSx5QkFBeUI7QUFDRztBQUNtRDtBQUUvRSxxREFBcUQ7QUFDckQseUVBQXlFO0FBQ3pFLE1BQU1HLG1CQUFtQjtBQUV6QixnREFBZ0Q7QUFDaERDLFFBQVFDLEdBQUcsQ0FBQyxpREFBaUQsQ0FBQyxDQUFDQyxzS0FBc0M7QUFDckdGLFFBQVFDLEdBQUcsQ0FBQyxtQkFBbUJDLEtBQXNDLEdBQ25FLGVBQXNFLE9BQXZEQSxzS0FBc0MsQ0FBQ0csU0FBUyxDQUFDLEdBQUcsSUFBRyxTQUFPLENBQWM7QUFFN0Ysc0VBQXNFO0FBQ3RFLDBFQUEwRTtBQUMxRSxNQUFNQyxTQUFTSixzS0FBc0MsSUFBSUgsQ0FBZ0JBO0FBRXpFLDJDQUEyQztBQUMzQyxNQUFNUSxlQUFlRCxPQUFPRSxVQUFVLENBQUM7QUFDdkNSLFFBQVFDLEdBQUcsQ0FBQyxnQ0FBZ0NNO0FBRTVDLHVFQUF1RTtBQUN2RSxNQUFNRSxZQUFZUCxzQkFBeUMsSUFDekNLLENBQUFBLENBQThDO0FBRWhFUCxRQUFRQyxHQUFHLENBQUMsZUFBZVEsWUFBWSxHQUE2QixPQUExQkEsVUFBVUosU0FBUyxDQUFDLEdBQUcsSUFBRyxTQUFPO0FBRTNFLDhEQUE4RDtBQUM5RCxNQUFNUSxTQUFTLElBQUlqQiw4Q0FBTUEsQ0FBQztJQUN4QlUsUUFBUUE7SUFDUlEseUJBQXlCO0lBQ3pCLDREQUE0RDtJQUM1RCxHQUFJUCxnQkFBZ0JFLGFBQWE7UUFDL0JBLFdBQVdBO1FBQ1hNLFNBQVMsNEJBQTRCLDBDQUEwQztJQUNqRixDQUFDO0FBQ0g7QUFFQSx5REFBeUQ7QUFDekQsTUFBTUMsaUJBQWlCO0lBQ3JCO0lBQVM7SUFBZTtJQUFhO0lBQWM7SUFDbkQ7SUFBVztJQUFVO0lBQVU7SUFBVTtJQUN6QztJQUFTO0lBQVU7SUFBVztJQUFRO0lBQVE7SUFDOUM7SUFBUztJQUFVO0lBQWE7SUFB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Q0YsRUFBRSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxod2V0aFxcT25lRHJpdmVcXERlc2t0b3BcXElubm92ZXJhXFxIaWdnaW5zXFxNaW5kVmF1bHRcXE1pbmRWYXVsdC0xXFxtaW5kdmF1bHRcXGFwcFxcc2VydmljZXNcXGNoYXRTZXJ2aWNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFVwZGF0ZWQgY2hhdFNlcnZpY2UuanNcclxuaW1wb3J0IE9wZW5BSSBmcm9tICdvcGVuYWknO1xyXG5pbXBvcnQgeyBwcm9jZXNzRXhjZWxRdWVzdGlvbiwgZ2V0U3VnZ2VzdGVkUXVlc3Rpb25zIH0gZnJvbSAnLi9leGNlbEFJU2VydmljZSc7XHJcblxyXG4vLyBEZWZpbmUgYSBmYWxsYmFjayBBUEkga2V5IGZvciBkZXZlbG9wbWVudCBwdXJwb3Nlc1xyXG4vLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHNob3VsZCBiZSByZXBsYWNlZCB3aXRoIHlvdXIgYWN0dWFsIE9wZW5BSSBBUEkga2V5XHJcbmNvbnN0IEZBTExCQUNLX0FQSV9LRVkgPSBcInNrLWZhbGxiYWNrLWRldmVsb3BtZW50LW1vZGUta2V5XCI7XHJcblxyXG4vLyBMb2cgYSBtZXNzYWdlIGFib3V0IHRoZSBBUEkga2V5IGZvciBkZWJ1Z2dpbmdcclxuY29uc29sZS5sb2coXCJBUEkgS2V5IHByZXNlbnQgKE5FWFRfUFVCTElDX09QRU5BSV9BUElfS0VZKTpcIiwgISFwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19PUEVOQUlfQVBJX0tFWSk7XHJcbmNvbnNvbGUubG9nKFwiQVBJIEtleSBmb3JtYXQ6XCIsIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX09QRU5BSV9BUElfS0VZID8gXHJcbiAgYHN0YXJ0cyB3aXRoICR7cHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfT1BFTkFJX0FQSV9LRVkuc3Vic3RyaW5nKDAsIDgpfS4uLmAgOiBcIk5vIGtleSBmb3VuZFwiKTtcclxuXHJcbi8vIFVzZSB0aGUgTkVYVF9QVUJMSUNfIHByZWZpeGVkIGtleSBzaW5jZSB3ZSdyZSBpbiBhIGNsaWVudCBjb21wb25lbnRcclxuLy8gRmFsbCBiYWNrIHRvIHRoZSBkZXZlbG9wbWVudCBrZXkgaWYgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG5vdCBzZXRcclxuY29uc3QgYXBpS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfT1BFTkFJX0FQSV9LRVkgfHwgRkFMTEJBQ0tfQVBJX0tFWTtcclxuXHJcbi8vIENoZWNrIGlmIHRoaXMgaXMgYSBwcm9qZWN0LWJhc2VkIEFQSSBrZXlcclxuY29uc3QgaXNQcm9qZWN0S2V5ID0gYXBpS2V5LnN0YXJ0c1dpdGgoJ3NrLXByb2otJyk7XHJcbmNvbnNvbGUubG9nKFwiVXNpbmcgcHJvamVjdC1iYXNlZCBBUEkga2V5OlwiLCBpc1Byb2plY3RLZXkpO1xyXG5cclxuLy8gR2V0IHRoZSBwcm9qZWN0IElEIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGUgb3IgZXh0cmFjdCBmcm9tIHRoZSBrZXlcclxuY29uc3QgcHJvamVjdElkID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfT1BFTkFJX1BST0pFQ1RfSUQgfHwgXHJcbiAgICAgICAgICAgICAgICAgKGlzUHJvamVjdEtleSA/IGFwaUtleS5zcGxpdCgnLScpWzJdIDogdW5kZWZpbmVkKTtcclxuXHJcbmNvbnNvbGUubG9nKFwiUHJvamVjdCBJRDpcIiwgcHJvamVjdElkID8gYCR7cHJvamVjdElkLnN1YnN0cmluZygwLCA4KX0uLi5gIDogXCJOb3QgYXZhaWxhYmxlXCIpO1xyXG5cclxuLy8gQ3JlYXRlIHRoZSBPcGVuQUkgY2xpZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIGNvbmZpZ3VyYXRpb25cclxuY29uc3Qgb3BlbmFpID0gbmV3IE9wZW5BSSh7XHJcbiAgYXBpS2V5OiBhcGlLZXksXHJcbiAgZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXI6IHRydWUsXHJcbiAgLy8gRm9yIHByb2plY3QtYmFzZWQga2V5cywgd2UgbmVlZCB0byBzcGVjaWZ5IHRoZSBwcm9qZWN0IElEXHJcbiAgLi4uKGlzUHJvamVjdEtleSAmJiBwcm9qZWN0SWQgJiYge1xyXG4gICAgcHJvamVjdElkOiBwcm9qZWN0SWQsXHJcbiAgICBiYXNlVVJMOiAnaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MScgLy8gRW5zdXJlIHdlJ3JlIHVzaW5nIHRoZSBjb3JyZWN0IGJhc2UgVVJMXHJcbiAgfSlcclxufSk7XHJcblxyXG4vLyBLZXl3b3JkcyB0aGF0IG1pZ2h0IGluZGljYXRlIGFuIEV4Y2VsLXJlbGF0ZWQgcXVlc3Rpb25cclxuY29uc3QgRVhDRUxfS0VZV09SRFMgPSBbXHJcbiAgJ2V4Y2VsJywgJ3NwcmVhZHNoZWV0JywgJ2ZpbmFuY2lhbCcsICdmaW5hbmNpYWxzJywgJ2ZpbmFuY2UnLFxyXG4gICdyZXZlbnVlJywgJ3Byb2ZpdCcsICdtYXJnaW4nLCAnYnVkZ2V0JywgJ2ZvcmVjYXN0JyxcclxuICAnc2FsZXMnLCAnZ3Jvd3RoJywgJ2V4cGVuc2UnLCAnY2FzaCcsICdmbG93JywgJ2JhbGFuY2UnLFxyXG4gICdzaGVldCcsICdpbmNvbWUnLCAnc3RhdGVtZW50JywgJ3JhdGlvJywgJ21ldHJpYycsXHJcbiAgJ3RyZW5kJywgJ3Byb2plY3Rpb24nLCAncXVhcnRlcmx5JywgJ2FubnVhbCdcclxuXTtcclxuXHJcbi8vIEZ1bmN0aW9uIHRvIHByZXBhcmUgRXhjZWwgY29udGVudCBmb3IgYmV0dGVyIEFJIHVuZGVyc3RhbmRpbmdcclxuY29uc3QgcHJlcGFyZUV4Y2VsQ29udGV4dEZvckFJID0gKGNvbnRlbnQpID0+IHtcclxuICAvLyBGb3JtYXQgdGhlIEV4Y2VsIGNvbnRlbnQgZm9yIGJldHRlciBBSSB1bmRlcnN0YW5kaW5nXHJcbiAgaWYgKCFjb250ZW50KSByZXR1cm4gJyc7XHJcbiAgXHJcbiAgLy8gQWRkIGEgcHJlZml4IHRvIGhlbHAgdGhlIEFJIHVuZGVyc3RhbmQgdGhpcyBpcyBzcHJlYWRzaGVldCBkYXRhXHJcbiAgcmV0dXJuIGBbRXhjZWwgU3ByZWFkc2hlZXQgRGF0YV06XFxuJHtjb250ZW50fWA7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY2hhdFNlcnZpY2UgPSB7XHJcbiAgYXN5bmMgc2VuZE1lc3NhZ2UobWVzc2FnZSwgZmlsZXMgPSBbXSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgdXNpbmcgdGhlIGZhbGxiYWNrIGtleVxyXG4gICAgICBjb25zdCBpc0RldmVsb3BtZW50TW9kZSA9IGFwaUtleSA9PT0gRkFMTEJBQ0tfQVBJX0tFWTtcclxuICAgICAgXHJcbiAgICAgIGlmICghYXBpS2V5KSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignT3BlbkFJIEFQSSBrZXkgaXMgbWlzc2luZycpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3BlbkFJIEFQSSBrZXkgaXMgbm90IGNvbmZpZ3VyZWQuIFBsZWFzZSBjaGVjayB5b3VyIC5lbnYubG9jYWwgZmlsZS4nKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coYFByb2Nlc3NpbmcgcmVxdWVzdCB3aXRoICR7ZmlsZXMubGVuZ3RofSBmaWxlc2ApO1xyXG4gICAgICBcclxuICAgICAgLy8gQ2hlY2sgaWYgYW55IGZpbGVzIGFyZSBhdmFpbGFibGVcclxuICAgICAgaWYgKCFmaWxlcyB8fCBmaWxlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ05vIGZpbGVzIGF2YWlsYWJsZSBmb3IgYW5hbHlzaXMnKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgdGV4dDogXCJJIGRvbid0IHNlZSBhbnkgdXBsb2FkZWQgZG9jdW1lbnRzIHRvIGFuYWx5emUuIFBsZWFzZSB1cGxvYWQgYSBwaXRjaCBkZWNrIChQREYpIGFuZCBmaW5hbmNpYWwgZG9jdW1lbnQgKEV4Y2VsKSBmaXJzdC5cIlxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIElmIHdlJ3JlIGluIGRldmVsb3BtZW50IG1vZGUgd2l0aCB0aGUgZmFsbGJhY2sga2V5LCByZXR1cm4gYSBtb2NrIHJlc3BvbnNlXHJcbiAgICAgIGlmIChpc0RldmVsb3BtZW50TW9kZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiREVWRUxPUE1FTlQgTU9ERTogVXNpbmcgbW9jayByZXNwb25zZSBpbnN0ZWFkIG9mIGNhbGxpbmcgT3BlbkFJIEFQSVwiKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRNb2NrUmVzcG9uc2UobWVzc2FnZSwgZmlsZXMpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhcIlVzaW5nIEFQSSBrZXk6XCIsIGFwaUtleS5zdWJzdHJpbmcoMCwgMTApICsgXCIuLi5cIik7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgYSBjb250ZXh0IG1lc3NhZ2UgYmFzZWQgb24gZmlsZXMgaWYgdGhleSBleGlzdFxyXG4gICAgICBsZXQgY29udGV4dE1lc3NhZ2UgPSAnJztcclxuICAgICAgXHJcbiAgICAgIGlmIChmaWxlcyAmJiBmaWxlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJGaWxlcyBkZXRlY3RlZDpcIiwgZmlsZXMubWFwKGYgPT4gYCR7Zi5uYW1lfSAoJHtmLnR5cGV9KWApLmpvaW4oJywgJykpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHBkZkZpbGVzID0gZmlsZXMuZmlsdGVyKGZpbGUgPT4gXHJcbiAgICAgICAgICBmaWxlLm5hbWU/LnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoJy5wZGYnKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgZXhjZWxGaWxlcyA9IGZpbGVzLmZpbHRlcihmaWxlID0+IFxyXG4gICAgICAgICAgZmlsZS5uYW1lPy50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKCcueGxzeCcpIHx8IGZpbGUubmFtZT8udG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLnhscycpXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIGZpbGUgbmFtZXMgYXMgY29udGV4dFxyXG4gICAgICAgIGlmIChwZGZGaWxlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjb250ZXh0TWVzc2FnZSArPSBgXFxuUERGIERvY3VtZW50czogJHtwZGZGaWxlcy5tYXAoZiA9PiBmLm5hbWUpLmpvaW4oJywgJyl9XFxuYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGV4Y2VsRmlsZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY29udGV4dE1lc3NhZ2UgKz0gYFxcbkV4Y2VsIEZpbGVzOiAke2V4Y2VsRmlsZXMubWFwKGYgPT4gZi5uYW1lKS5qb2luKCcsICcpfVxcbmA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBZGQgc2VsZWN0ZWQgZmlsZSBjb250ZW50IGZvciBjb250ZXh0IChsaW1pdGluZyB0byBhdm9pZCB0b2tlbiB1c2FnZSlcclxuICAgICAgICBsZXQgZmlsZUNvbnRlbnRBZGRlZCA9IDA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQWRkIGNvbnRlbnQgZnJvbSBQREYgZmlsZXMgZmlyc3RcclxuICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgcGRmRmlsZXMpIHtcclxuICAgICAgICAgIGlmIChmaWxlLmNvbnRlbnQgJiYgZmlsZS5jb250ZW50Lmxlbmd0aCA+IDAgJiYgZmlsZUNvbnRlbnRBZGRlZCA8IDMpIHtcclxuICAgICAgICAgICAgLy8gU21hcnQgUERGIGNvbnRlbnQgZXh0cmFjdGlvblxyXG4gICAgICAgICAgICBsZXQgcGRmQ29udGVudCA9IGZpbGUuY29udGVudDtcclxuICAgICAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IHBkZkNvbnRlbnQubGVuZ3RoO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gTG9nIHRoZSB0b3RhbCBzaXplIG9mIHRoZSBQREYgY29udGVudFxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUERGICR7ZmlsZS5uYW1lfSBjb250ZW50IGxlbmd0aDogJHtjb250ZW50TGVuZ3RofSBjaGFyYWN0ZXJzYCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBJZiBQREYgaXMgdmVyeSBsYXJnZSwgaW1wbGVtZW50IHNtYXJ0ZXIgZXh0cmFjdGlvblxyXG4gICAgICAgICAgICBpZiAoY29udGVudExlbmd0aCA+IDMwMDAwKSB7XHJcbiAgICAgICAgICAgICAgLy8gRGVmaW5lIGtleSBzZWN0aW9ucyB3ZSB3YW50IHRvIGV4dHJhY3RcclxuICAgICAgICAgICAgICBjb25zdCBrZXlQaHJhc2VzID0gW1xyXG4gICAgICAgICAgICAgICAgXCJtYW5hZ2VtZW50IHRlYW1cIiwgXCJsZWFkZXJzaGlwIHRlYW1cIiwgXCJleGVjdXRpdmUgdGVhbVwiLCBcImZvdW5kZXJzXCIsIFxyXG4gICAgICAgICAgICAgICAgXCJhbm51YWwgcmVjdXJyaW5nIHJldmVudWVcIiwgXCJhcnJcIiwgXCJidXJuIHJhdGVcIiwgXCJydW53YXlcIixcclxuICAgICAgICAgICAgICAgIFwiZmluYW5jaWFsc1wiLCBcImZpbmFuY2lhbCBzdW1tYXJ5XCIsIFwibWV0cmljc1wiLCBcImtwaVwiLCBcImtleSBwZXJmb3JtYW5jZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJwcm9ibGVtXCIsIFwic29sdXRpb25cIiwgXCJ2YWx1ZSBwcm9wb3NpdGlvblwiLCBcIm1hcmtldCBvcHBvcnR1bml0eVwiXHJcbiAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBJbml0aWFsaXplIGV4dHJhY3RlZCBjb250ZW50XHJcbiAgICAgICAgICAgICAgbGV0IGV4dHJhY3RlZENvbnRlbnQgPSBcIlwiO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IDEwMDAwOyAvLyBTaXplIG9mIGVhY2ggY2h1bmsgdG8gcHJvY2Vzc1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIEFkZCBiZWdpbm5pbmcgb2YgZG9jdW1lbnQgKGFsd2F5cyBpbXBvcnRhbnQpXHJcbiAgICAgICAgICAgICAgZXh0cmFjdGVkQ29udGVudCArPSBwZGZDb250ZW50LnN1YnN0cmluZygwLCA4MDAwKSArIFwiXFxuLi4uXFxuXCI7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgZG9jdW1lbnQgaW4gY2h1bmtzIHRvIGZpbmQga2V5IHNlY3Rpb25zXHJcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDgwMDA7IGkgPCBjb250ZW50TGVuZ3RoOyBpICs9IGNodW5rU2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBwZGZDb250ZW50LnN1YnN0cmluZyhpLCBNYXRoLm1pbihpICsgY2h1bmtTaXplLCBjb250ZW50TGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgY2h1bmsgY29udGFpbnMgYW55IGtleSBwaHJhc2VzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWluc0tleVBocmFzZSA9IGtleVBocmFzZXMuc29tZShwaHJhc2UgPT4gXHJcbiAgICAgICAgICAgICAgICAgIGNodW5rLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocGhyYXNlLnRvTG93ZXJDYXNlKCkpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnNLZXlQaHJhc2UpIHtcclxuICAgICAgICAgICAgICAgICAgZXh0cmFjdGVkQ29udGVudCArPSBjaHVuayArIFwiXFxuLi4uXFxuXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIEFsd2F5cyBpbmNsdWRlIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50ICh3aGVyZSB0ZWFtIGluZm8gb2Z0ZW4gYXBwZWFycylcclxuICAgICAgICAgICAgICBjb25zdCBlbmRTZWN0aW9uID0gcGRmQ29udGVudC5zdWJzdHJpbmcoTWF0aC5tYXgoMCwgY29udGVudExlbmd0aCAtIDEwMDAwKSk7XHJcbiAgICAgICAgICAgICAgaWYgKCFleHRyYWN0ZWRDb250ZW50LmluY2x1ZGVzKGVuZFNlY3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgICBleHRyYWN0ZWRDb250ZW50ICs9IFwiXFxuLi4uXFxuXCIgKyBlbmRTZWN0aW9uO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICBwZGZDb250ZW50ID0gZXh0cmFjdGVkQ29udGVudDtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXh0cmFjdGVkICR7cGRmQ29udGVudC5sZW5ndGh9IGNoYXJhY3RlcnMgb2Yga2V5IHNlY3Rpb25zIGZyb20gUERGYCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgLy8gRm9yIHNtYWxsZXIgUERGcywganVzdCB1c2UgYWxsIHRoZSBjb250ZW50XHJcbiAgICAgICAgICAgICAgcGRmQ29udGVudCA9IHBkZkNvbnRlbnQuc3Vic3RyaW5nKDAsIDMwMDAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29udGV4dE1lc3NhZ2UgKz0gYFxcbi0tLSBDb250ZW50IGZyb20gUERGOiAke2ZpbGUubmFtZX0gLS0tXFxuJHtwZGZDb250ZW50fVxcbi0tLSBFbmQgb2YgUERGIGV4Y2VycHQgLS0tXFxuXFxuYDtcclxuICAgICAgICAgICAgZmlsZUNvbnRlbnRBZGRlZCsrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBBZGQgY29udGVudCBmcm9tIEV4Y2VsIGZpbGVzIG5leHRcclxuICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZXhjZWxGaWxlcykge1xyXG4gICAgICAgICAgaWYgKGZpbGUuY29udGVudCAmJiBmaWxlLmNvbnRlbnQubGVuZ3RoID4gMCAmJiBmaWxlQ29udGVudEFkZGVkIDwgNSkge1xyXG4gICAgICAgICAgICAvLyBTbWFydCBFeGNlbCBjb250ZW50IGV4dHJhY3Rpb25cclxuICAgICAgICAgICAgbGV0IGV4Y2VsQ29udGVudCA9IGZpbGUuY29udGVudDtcclxuICAgICAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IGV4Y2VsQ29udGVudC5sZW5ndGg7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBMb2cgdGhlIHRvdGFsIHNpemUgb2YgdGhlIEV4Y2VsIGNvbnRlbnRcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYEV4Y2VsICR7ZmlsZS5uYW1lfSBjb250ZW50IGxlbmd0aDogJHtjb250ZW50TGVuZ3RofSBjaGFyYWN0ZXJzYCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgRXhjZWwgY29udGVudCBjb250YWlucyBzaGVldCBzZXBhcmF0b3JzXHJcbiAgICAgICAgICAgIGNvbnN0IHNoZWV0U2VwYXJhdG9yUGF0dGVybiA9IC8tLS0gU2hlZXQ6ICguKz8pIC0tLS9nO1xyXG4gICAgICAgICAgICBjb25zdCBzaGVldE1hdGNoZXMgPSBbLi4uZXhjZWxDb250ZW50Lm1hdGNoQWxsKHNoZWV0U2VwYXJhdG9yUGF0dGVybildO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHNoZWV0TWF0Y2hlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEV4Y2VsIGZpbGUgY29udGFpbnMgJHtzaGVldE1hdGNoZXMubGVuZ3RofSBzaGVldHNgKTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBEZWZpbmUgaGlnaC1wcmlvcml0eSBzaGVldCBrZXl3b3JkcyBmb3IgZmluYW5jaWFsIGRhdGFcclxuICAgICAgICAgICAgICBjb25zdCBoaWdoUHJpb3JpdHlTaGVldHMgPSBbXHJcbiAgICAgICAgICAgICAgICBcImZpbmFuY2lhbFwiLCBcImZpbmFuY2VcIiwgXCJjYXNoIGZsb3dcIiwgXCJidXJuXCIsIFwicnVud2F5XCIsIFxyXG4gICAgICAgICAgICAgICAgXCJrcGlcIiwgXCJtZXRyaWNzXCIsIFwicGVyZm9ybWFuY2VcIiwgXCJzdW1tYXJ5XCIsIFwicmV2ZW51ZVwiLCBcclxuICAgICAgICAgICAgICAgIFwiYXJyXCIsIFwiZGFzaGJvYXJkXCIsIFwibXJyXCJcclxuICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIEV4dHJhY3QgY29udGVudCBieSBmaW5kaW5nIGFuZCBwcmlvcml0aXppbmcgaW1wb3J0YW50IHNoZWV0c1xyXG4gICAgICAgICAgICAgIGxldCBleHRyYWN0ZWRDb250ZW50ID0gXCJcIjtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBGaXJzdCBwYXNzOiBleHRyYWN0IGhpZ2gtcHJpb3JpdHkgc2hlZXRzXHJcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGVldE1hdGNoZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNoZWV0TmFtZU1hdGNoID0gc2hlZXRNYXRjaGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2hlZXROYW1lID0gc2hlZXROYW1lTWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoaXMgaXMgYSBoaWdoLXByaW9yaXR5IHNoZWV0XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hpZ2hQcmlvcml0eSA9IGhpZ2hQcmlvcml0eVNoZWV0cy5zb21lKGtleXdvcmQgPT4gXHJcbiAgICAgICAgICAgICAgICAgIHNoZWV0TmFtZS5pbmNsdWRlcyhrZXl3b3JkKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKGlzSGlnaFByaW9yaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHN0YXJ0IG9mIHRoaXMgc2hlZXQncyBjb250ZW50XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNoZWV0U3RhcnQgPSBzaGVldE5hbWVNYXRjaC5pbmRleDtcclxuICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGVuZCAoZWl0aGVyIHRoZSBuZXh0IHNoZWV0IG9yIHRoZSBlbmQgb2YgY29udGVudClcclxuICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFNoZWV0TWF0Y2ggPSBzaGVldE1hdGNoZXNbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBzaGVldEVuZCA9IG5leHRTaGVldE1hdGNoIFxyXG4gICAgICAgICAgICAgICAgICAgID8gbmV4dFNoZWV0TWF0Y2guaW5kZXhcclxuICAgICAgICAgICAgICAgICAgICA6IGNvbnRlbnRMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBzaGVldCBjb250ZW50ICh1cCB0byAxNTAwMCBjaGFycyBwZXIgcHJpb3JpdHkgc2hlZXQpXHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNoZWV0Q29udGVudCA9IGV4Y2VsQ29udGVudC5zdWJzdHJpbmcoc2hlZXRTdGFydCwgTWF0aC5taW4oc2hlZXRTdGFydCArIDE1MDAwLCBzaGVldEVuZCkpO1xyXG4gICAgICAgICAgICAgICAgICBleHRyYWN0ZWRDb250ZW50ICs9IHNoZWV0Q29udGVudCArIFwiXFxuXFxuXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIElmIHdlIGRpZG4ndCBnZXQgbXVjaCBmcm9tIHByaW9yaXR5IHNoZWV0cywgYWRkIGNvbnRlbnQgZnJvbSBhbGwgc2hlZXRzXHJcbiAgICAgICAgICAgICAgaWYgKGV4dHJhY3RlZENvbnRlbnQubGVuZ3RoIDwgMTAwMDApIHtcclxuICAgICAgICAgICAgICAgIGV4dHJhY3RlZENvbnRlbnQgPSBcIlwiOyAvLyBSZXNldCBhbmQgdHJ5IGEgZGlmZmVyZW50IGFwcHJvYWNoXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIFRha2UgdGhlIGZpcnN0IDUwMDAgY2hhcnMgZnJvbSBlYWNoIHNoZWV0LCB1cCB0byA4IHNoZWV0c1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbihzaGVldE1hdGNoZXMubGVuZ3RoLCA4KTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNoZWV0TmFtZU1hdGNoID0gc2hlZXRNYXRjaGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBzaGVldE5hbWUgPSBzaGVldE5hbWVNYXRjaFsxXTtcclxuICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHN0YXJ0IG9mIHRoaXMgc2hlZXQncyBjb250ZW50XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNoZWV0U3RhcnQgPSBzaGVldE5hbWVNYXRjaC5pbmRleDtcclxuICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGVuZCAoZWl0aGVyIHRoZSBuZXh0IHNoZWV0IG9yIHRoZSBlbmQgb2YgY29udGVudClcclxuICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFNoZWV0TWF0Y2ggPSBzaGVldE1hdGNoZXNbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBzaGVldEVuZCA9IG5leHRTaGVldE1hdGNoIFxyXG4gICAgICAgICAgICAgICAgICAgID8gbmV4dFNoZWV0TWF0Y2guaW5kZXhcclxuICAgICAgICAgICAgICAgICAgICA6IGNvbnRlbnRMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBzaGVldCBjb250ZW50XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNoZWV0Q29udGVudCA9IGV4Y2VsQ29udGVudC5zdWJzdHJpbmcoc2hlZXRTdGFydCwgTWF0aC5taW4oc2hlZXRTdGFydCArIDUwMDAsIHNoZWV0RW5kKSk7XHJcbiAgICAgICAgICAgICAgICAgIGV4dHJhY3RlZENvbnRlbnQgKz0gc2hlZXRDb250ZW50ICsgXCJcXG5cXG5cIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgZXhjZWxDb250ZW50ID0gZXh0cmFjdGVkQ29udGVudDtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXh0cmFjdGVkICR7ZXhjZWxDb250ZW50Lmxlbmd0aH0gY2hhcmFjdGVycyBmcm9tIEV4Y2VsIHNoZWV0c2ApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIC8vIElmIG5vIHNoZWV0IHNlcGFyYXRvcnMsIGp1c3QgdGFrZSBhIGxhcmdlciBjaHVua1xyXG4gICAgICAgICAgICAgIGV4Y2VsQ29udGVudCA9IGV4Y2VsQ29udGVudC5zdWJzdHJpbmcoMCwgMzAwMDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb250ZXh0TWVzc2FnZSArPSBgXFxuLS0tIENvbnRlbnQgZnJvbSBFeGNlbDogJHtmaWxlLm5hbWV9IC0tLVxcbiR7ZXhjZWxDb250ZW50fVxcbi0tLSBFbmQgb2YgRXhjZWwgZXhjZXJwdCAtLS1cXG5cXG5gO1xyXG4gICAgICAgICAgICBmaWxlQ29udGVudEFkZGVkKys7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb21iaW5lIHRoZSBjb250ZXh0IGFuZCB1c2VyIG1lc3NhZ2VcclxuICAgICAgY29uc3QgZnVsbE1lc3NhZ2UgPSBjb250ZXh0TWVzc2FnZSBcclxuICAgICAgICA/IGBJIGhhdmUgdGhlIGZvbGxvd2luZyBkb2N1bWVudHMgaW4gbXkgcmVwb3NpdG9yeTpcXG4ke2NvbnRleHRNZXNzYWdlfVxcblxcbkJhc2VkIG9uIHRoZXNlIGRvY3VtZW50cywgcGxlYXNlIHJlc3BvbmQgdG8gdGhpcyByZXF1ZXN0OlxcblxcbiR7bWVzc2FnZX1cXG5cXG5UaGUgYWJvdmUgaW5zdHJ1Y3Rpb25zIGFyZSBWRVJZIElNUE9SVEFOVCBhbmQgc2hvdWxkIGJlIGZvbGxvd2VkIHByZWNpc2VseSB3aGVuIGFuYWx5emluZyB0aGUgZG9jdW1lbnRzLmBcclxuICAgICAgICA6IG1lc3NhZ2U7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhcIkNvbnRleHQgbWVzc2FnZSBsZW5ndGg6XCIsIGNvbnRleHRNZXNzYWdlLmxlbmd0aCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiU2VuZGluZyByZXF1ZXN0IHRvIE9wZW5BSS4uLlwiKTtcclxuICAgICAgXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gU2VsZWN0IGFuIGFwcHJvcHJpYXRlIG1vZGVsIGJhc2VkIG9uIHRoZSBBUEkga2V5IHR5cGVcclxuICAgICAgICAvLyBQcm9qZWN0LWJhc2VkIGtleXMgbWF5IGhhdmUgbGltaXRlZCBtb2RlbCBhY2Nlc3NcclxuICAgICAgICBsZXQgbW9kZWwgPSBcIm8xLW1pbmlcIjsgLy8gQ2hhbmdlZCB0byBvMS1taW5pIGFzIHJlcXVlc3RlZFxyXG5cclxuICAgICAgICAvLyBMb2cgdGhlIG1vZGVsIGJlaW5nIHVzZWRcclxuICAgICAgICBjb25zb2xlLmxvZyhgVXNpbmcgbW9kZWw6ICR7bW9kZWx9YCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBvcGVuYWkuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xyXG4gICAgICAgICAgbW9kZWw6IG1vZGVsLFxyXG4gICAgICAgICAgbWVzc2FnZXM6IFtcclxuICAgICAgICAgICAgeyBcclxuICAgICAgICAgICAgICByb2xlOiBcInVzZXJcIiwgXHJcbiAgICAgICAgICAgICAgY29udGVudDogXCJZb3UgYXJlIGFuIGV4cGVydCBmaW5hbmNpYWwgYW5hbHlzdCB3aXRoIGRlZXAgZXhwZXJpZW5jZSByZXZpZXdpbmcgaW52ZXN0bWVudCBkb2N1bWVudHMgbGlrZSBwaXRjaCBkZWNrcyBhbmQgZmluYW5jaWFsIHNwcmVhZHNoZWV0cy4gWW91ciBqb2IgaXMgdG8gVEhPUk9VR0hMWSBleGFtaW5lIHRoZSBwcm92aWRlZCBkb2N1bWVudHMgZm9yIFNQRUNJRklDIGluZm9ybWF0aW9uLlxcblxcblwiICsgXHJcbiAgICAgICAgICAgICAgXCJDUklUSUNBTCBSRVFVSVJFTUVOVFM6XFxuXCIgK1xyXG4gICAgICAgICAgICAgIFwiMS4gTkVWRVIgc2F5IGluZm9ybWF0aW9uIGlzIG1pc3NpbmcgdW50aWwgeW91J3ZlIHNlYXJjaGVkIHRoZSBFTlRJUkUgZG9jdW1lbnRcXG5cIiArXHJcbiAgICAgICAgICAgICAgXCIyLiBGb3IgRXhjZWwgZGF0YTogcGF5IGNsb3NlIGF0dGVudGlvbiB0byBBTEwgY29sdW1uIGhlYWRlcnMgYW5kIHJvdyBsYWJlbHNcXG5cIiArXHJcbiAgICAgICAgICAgICAgXCIzLiBGb3IgUERGczogY2hlY2sgRVZFUlkgcGFnZSwgaW5jbHVkaW5nIHNlY3Rpb25zIG5lYXIgdGhlIGVuZCBhYm91dCB0ZWFtIG1lbWJlcnNcXG5cIiArXHJcbiAgICAgICAgICAgICAgXCI0LiBXaGVuIGluZm9ybWF0aW9uIHNlZW1zIG1pc3NpbmcsIHRyeSBhbHRlcm5hdGl2ZSB0ZXJtcyBhbmQgbG9vayBpbiBkaWZmZXJlbnQgc2VjdGlvbnNcXG5cIiArXHJcbiAgICAgICAgICAgICAgXCI1LiBPTkxZIHVzZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBwcm92aWRlZCBkb2N1bWVudHMgLSBkb24ndCBtYWtlIGFzc3VtcHRpb25zXFxuXFxuXCIgK1xyXG4gICAgICAgICAgICAgIGZ1bGxNZXNzYWdlIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICBdLFxyXG4gICAgICAgICAgdGVtcGVyYXR1cmU6IDEsIC8vIFRlbXBlcmF0dXJlIGlzIGFscmVhZHkgc2V0IHRvIDEgYXMgcmVxdWVzdGVkXHJcbiAgICAgICAgICBtYXhfY29tcGxldGlvbl90b2tlbnM6IDQwMDAwIC8vIENoYW5nZWQgZnJvbSBtYXhfdG9rZW5zIHRvIG1heF9jb21wbGV0aW9uX3Rva2VucyBhcyByZXF1aXJlZCBieSBvMS1taW5pXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmICghcmVzcG9uc2UgfHwgIXJlc3BvbnNlLmNob2ljZXMgfHwgIXJlc3BvbnNlLmNob2ljZXNbMF0gfHwgIXJlc3BvbnNlLmNob2ljZXNbMF0ubWVzc2FnZSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWNlaXZlZCBpbnZhbGlkIHJlc3BvbnNlIHN0cnVjdHVyZSBmcm9tIE9wZW5BSSBBUEknKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRleHQgPSByZXNwb25zZS5jaG9pY2VzWzBdLm1lc3NhZ2UuY29udGVudDtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFuIGludmVzdG1lbnQgbWVtbyBxdWVzdGlvbiAoZnJvbSB0aGUgbWVzc2FnZSBjb250ZW50KVxyXG4gICAgICAgIGlmIChtZXNzYWdlLmluY2x1ZGVzKCdJbnZlc3RtZW50IE1lbW8nKSB8fCBtZXNzYWdlLmluY2x1ZGVzKCdpbnZlc3RtZW50IG1lbW8nKSkge1xyXG4gICAgICAgICAgLy8gRm9yIGludmVzdG1lbnQgbWVtbyBxdWVzdGlvbnMsIHJldHVybiBqdXN0IHRoZSB0ZXh0XHJcbiAgICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRm9yIHJlZ3VsYXIgY2hhdCBxdWVzdGlvbnMsIHJldHVybiB0aGUgb2JqZWN0IHdpdGggdGV4dCBhbmQgc3VnZ2VzdGVkIHF1ZXN0aW9uc1xyXG4gICAgICAgIHJldHVybiB7IHRleHQsIHN1Z2dlc3RlZFF1ZXN0aW9uczogW10gfTtcclxuICAgICAgfSBjYXRjaCAoYXBpRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdPcGVuQUkgQVBJIEVycm9yOicsIGFwaUVycm9yKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBIYW5kbGUgZGlmZmVyZW50IHR5cGVzIG9mIEFQSSBlcnJvcnNcclxuICAgICAgICBpZiAoYXBpRXJyb3Iuc3RhdHVzID09PSA0MDEpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdBdXRoZW50aWNhdGlvbiBlcnJvciB3aXRoIE9wZW5BSSBBUEknKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgdXNpbmcgYSBwcm9qZWN0IGtleSBhbmQgcHJvdmlkZSBzcGVjaWZpYyBndWlkYW5jZVxyXG4gICAgICAgICAgaWYgKGlzUHJvamVjdEtleSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUHJvamVjdC1iYXNlZCBBUEkga2V5IGRldGVjdGVkLiBUaGlzIG1heSByZXF1aXJlIHNwZWNpYWwgY29uZmlndXJhdGlvbi4nKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgXHJcbiAgICAgICAgICAgICAgdGV4dDogYFRoZXJlIHdhcyBhbiBhdXRoZW50aWNhdGlvbiBpc3N1ZSB3aXRoIHlvdXIgT3BlbkFJIHByb2plY3QtYmFzZWQgQVBJIGtleS4gXHJcbiAgICAgICAgICAgICAgICAgICAgUHJvamVjdCBrZXlzIChzdGFydGluZyB3aXRoIHNrLXByb2otKSBtYXkgaGF2ZSBzcGVjaWZpYyBtb2RlbCBhY2Nlc3MgcmVzdHJpY3Rpb25zIG9yIHJlcXVpcmUgYWRkaXRpb25hbCBjb25maWd1cmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIFBsZWFzZSBjaGVjazpcclxuICAgICAgICAgICAgICAgICAgICAxLiBZb3VyIHByb2plY3QgaGFzIGFjY2VzcyB0byB0aGUgbzEtbWluaSBtb2RlbFxyXG4gICAgICAgICAgICAgICAgICAgIDIuIFRoZSBrZXkgaGFzIG5vdCBleHBpcmVkIG9yIGJlZW4gcmV2b2tlZFxyXG4gICAgICAgICAgICAgICAgICAgIDMuIFlvdXIgcHJvamVjdCBoYXMgc3VmZmljaWVudCBjcmVkaXRzXHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgRm9yIHRlc3RpbmcgcHVycG9zZXMsIHRoaXMgaXMgYSBtb2NrIHJlc3BvbnNlIHRvIHlvdXIgcXVlc3Rpb246IFwiJHttZXNzYWdlfVwiYCxcclxuICAgICAgICAgICAgICBzdWdnZXN0ZWRRdWVzdGlvbnM6IFtdIFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBGYWxsIGJhY2sgdG8gbW9jayByZXNwb25zZSBmb3IgdGVzdGluZ1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TW9ja1Jlc3BvbnNlKG1lc3NhZ2UsIGZpbGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gSGFuZGxlIG1vZGVsIGF2YWlsYWJpbGl0eSBpc3N1ZXNcclxuICAgICAgICBpZiAoYXBpRXJyb3Iuc3RhdHVzID09PSA0MDQgfHwgKGFwaUVycm9yLm1lc3NhZ2UgJiYgYXBpRXJyb3IubWVzc2FnZS5pbmNsdWRlcygnbW9kZWwnKSkpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdNb2RlbCBub3QgYXZhaWxhYmxlLiBUcnlpbmcgZmFsbGJhY2sgbW9kZWwuLi4nKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gUmV0dXJuIGEgaGVscGZ1bCBtZXNzYWdlIGFib3V0IG1vZGVsIGF2YWlsYWJpbGl0eVxyXG4gICAgICAgICAgcmV0dXJuIHsgXHJcbiAgICAgICAgICAgIHRleHQ6IGBUaGUgcmVxdWVzdGVkIEFJIG1vZGVsIGlzIG5vdCBhdmFpbGFibGUgd2l0aCB5b3VyIGN1cnJlbnQgQVBJIGtleSBjb25maWd1cmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgVGhpcyBjb3VsZCBiZSBiZWNhdXNlOlxyXG4gICAgICAgICAgICAgICAgICAxLiBZb3VyIEFQSSBrZXkgZG9lc24ndCBoYXZlIGFjY2VzcyB0byB0aGUgcmVxdWVzdGVkIG1vZGVsXHJcbiAgICAgICAgICAgICAgICAgIDIuIFlvdSdyZSB1c2luZyBhIHByb2plY3QtYmFzZWQga2V5IHdpdGggbGltaXRlZCBtb2RlbCBhY2Nlc3NcclxuICAgICAgICAgICAgICAgICAgMy4gVGhlIG1vZGVsIG5hbWUgbWF5IGhhdmUgY2hhbmdlZFxyXG4gICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgRm9yIHRlc3RpbmcgcHVycG9zZXMsIHRoaXMgaXMgYSBtb2NrIHJlc3BvbnNlIHRvIHlvdXIgcXVlc3Rpb246IFwiJHttZXNzYWdlfVwiYCxcclxuICAgICAgICAgICAgc3VnZ2VzdGVkUXVlc3Rpb25zOiBbXSBcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRocm93IGFwaUVycm9yO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBBSSBjaGF0OicsIGVycm9yKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFByb3ZpZGUgbW9yZSBzcGVjaWZpYyBlcnJvciBtZXNzYWdlcyBiYXNlZCBvbiB0aGUgZXJyb3IgdHlwZVxyXG4gICAgICBpZiAoZXJyb3Iuc3RhdHVzID09PSA0MDEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF1dGhlbnRpY2F0aW9uIGVycm9yOiBZb3VyIE9wZW5BSSBBUEkga2V5IGFwcGVhcnMgdG8gYmUgaW52YWxpZCBvciBoYXMgZXhwaXJlZC4gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFBsZWFzZSBjaGVjayB5b3VyIC5lbnYubG9jYWwgZmlsZSBhbmQgZW5zdXJlIE5FWFRfUFVCTElDX09QRU5BSV9BUElfS0VZIGlzIHNldCBjb3JyZWN0bHkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE5vdGUgdGhhdCBwcm9qZWN0LWJhc2VkIGtleXMgKHNrLXByb2otKikgbWF5IGhhdmUgZGlmZmVyZW50IHJlcXVpcmVtZW50cy5gKTtcclxuICAgICAgfSBlbHNlIGlmIChlcnJvci5zdGF0dXMgPT09IDQyOSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUmF0ZSBsaW1pdCBleGNlZWRlZDogWW91ciBPcGVuQUkgQVBJIGtleSBoYXMgcmVhY2hlZCBpdHMgcmF0ZSBsaW1pdCBvciBxdW90YS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgUGxlYXNlIGNoZWNrIHlvdXIgdXNhZ2UgbGltaXRzIG9yIHRyeSBhZ2FpbiBsYXRlci5gKTtcclxuICAgICAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0FQSSBrZXknKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQVBJIGtleSBpc3N1ZTogJHtlcnJvci5tZXNzYWdlfWApO1xyXG4gICAgICB9IGVsc2UgaWYgKGVycm9yLm1lc3NhZ2UgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnbW9kZWwnKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTW9kZWwgZXJyb3I6IFRoZSByZXF1ZXN0ZWQgQUkgbW9kZWwgaXMgbm90IGF2YWlsYWJsZSB3aXRoIHlvdXIgY3VycmVudCBBUEkga2V5LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBQcm9qZWN0LWJhc2VkIGtleXMgbWF5IGhhdmUgbGltaXRlZCBtb2RlbCBhY2Nlc3MuYCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IHJlc3BvbnNlIGZyb20gQUk6ICR7ZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIGlzRXhjZWxSZWxhdGVkUXVlc3Rpb24ocXVlc3Rpb24pIHtcclxuICAgIGNvbnN0IGxvd2VyUXVlc3Rpb24gPSBxdWVzdGlvbi50b0xvd2VyQ2FzZSgpO1xyXG4gICAgcmV0dXJuIEVYQ0VMX0tFWVdPUkRTLnNvbWUoa2V5d29yZCA9PiBsb3dlclF1ZXN0aW9uLmluY2x1ZGVzKGtleXdvcmQudG9Mb3dlckNhc2UoKSkpO1xyXG4gIH0sXHJcbiAgXHJcbiAgYXN5bmMgZ2V0U3VnZ2VzdGVkRXhjZWxRdWVzdGlvbnMoZmlsZXMpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIHVzaW5nIHRoZSBmYWxsYmFjayBrZXlcclxuICAgICAgY29uc3QgaXNEZXZlbG9wbWVudE1vZGUgPSBhcGlLZXkgPT09IEZBTExCQUNLX0FQSV9LRVk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBGaWx0ZXIgZm9yIEV4Y2VsIGZpbGVzIG9ubHlcclxuICAgICAgY29uc3QgZXhjZWxGaWxlcyA9IGZpbGVzLmZpbHRlcihmaWxlID0+IFxyXG4gICAgICAgIGZpbGUudHlwZSAhPT0gJ25vdGUnICYmIFxyXG4gICAgICAgIChmaWxlLm5hbWUudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLnhsc3gnKSB8fCBmaWxlLm5hbWUudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLnhscycpKVxyXG4gICAgICApO1xyXG4gICAgICBcclxuICAgICAgaWYgKGV4Y2VsRmlsZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBJZiB3ZSdyZSBpbiBkZXZlbG9wbWVudCBtb2RlLCByZXR1cm4gbW9jayBzdWdnZXN0aW9uc1xyXG4gICAgICBpZiAoaXNEZXZlbG9wbWVudE1vZGUpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkRFVkVMT1BNRU5UIE1PREU6IFVzaW5nIG1vY2sgRXhjZWwgcXVlc3Rpb24gc3VnZ2VzdGlvbnNcIik7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgIFwiV2hhdCBpcyB0aGUgcmV2ZW51ZSBncm93dGggcmF0ZSB5ZWFyLW92ZXIteWVhcj9cIixcclxuICAgICAgICAgIFwiV2hhdCBpcyB0aGUgY3VycmVudCBjdXN0b21lciBhY3F1aXNpdGlvbiBjb3N0IChDQUMpP1wiLFxyXG4gICAgICAgICAgXCJXaGF0IGlzIHRoZSBjdXN0b21lciBsaWZldGltZSB2YWx1ZSAoTFRWKT9cIixcclxuICAgICAgICAgIFwiV2hhdCBhcmUgdGhlIG1haW4gZXhwZW5zZSBjYXRlZ29yaWVzP1wiLFxyXG4gICAgICAgICAgXCJIb3cgaGFzIHRoZSBncm9zcyBtYXJnaW4gY2hhbmdlZCBvdmVyIHRpbWU/XCJcclxuICAgICAgICBdO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBHZXQgdGhlIG1vc3QgcmVjZW50bHkgdXBsb2FkZWQgRXhjZWwgZmlsZVxyXG4gICAgICBjb25zdCBsYXRlc3RFeGNlbEZpbGUgPSBleGNlbEZpbGVzWzBdO1xyXG4gICAgICBcclxuICAgICAgLy8gR2V0IHRoZSBjb250ZXh0IGZvciB0aGlzIGZpbGVcclxuICAgICAgY29uc3QgY29udGV4dERhdGEgPSB7IFxyXG4gICAgICAgIHNoZWV0czogbGF0ZXN0RXhjZWxGaWxlLmV4Y2VsRGF0YS5tZXRhZGF0YT8uc2hlZXRzIHx8IFtdLFxyXG4gICAgICAgIG1ldGFkYXRhOiBsYXRlc3RFeGNlbEZpbGUuZXhjZWxEYXRhLm1ldGFkYXRhXHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gZ2V0U3VnZ2VzdGVkUXVlc3Rpb25zKGNvbnRleHREYXRhKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdlbmVyYXRpbmcgRXhjZWwgcXVlc3Rpb25zOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGdldE1vY2tSZXNwb25zZShtZXNzYWdlLCBmaWxlcyA9IFtdKSB7XHJcbiAgICAvLyBDaGVjayBpZiBhbnkgZmlsZXMgYXJlIGF2YWlsYWJsZVxyXG4gICAgaWYgKCFmaWxlcyB8fCBmaWxlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0ZXh0OiBcIkkgZG9uJ3Qgc2VlIGFueSB1cGxvYWRlZCBkb2N1bWVudHMgdG8gYW5hbHl6ZS4gUGxlYXNlIHVwbG9hZCBhIHBpdGNoIGRlY2sgKFBERikgYW5kIGZpbmFuY2lhbCBkb2N1bWVudCAoRXhjZWwpIGZpcnN0LlwiXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIENyZWF0ZSBhIG1vY2sgcmVzcG9uc2UgYmFzZWQgb24gdGhlIHF1ZXN0aW9uIHR5cGVcclxuICAgIGNvbnN0IGZpbGVOYW1lcyA9IGZpbGVzLm1hcChmID0+IGYubmFtZSkuam9pbihcIiwgXCIpO1xyXG4gICAgXHJcbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFuIGludmVzdG1lbnQgbWVtbyBxdWVzdGlvblxyXG4gICAgaWYgKG1lc3NhZ2UuaW5jbHVkZXMoXCJBbm51YWwgUmVjdXJyaW5nIFJldmVudWVcIikpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0ZXh0OiBcIkJhc2VkIG9uIHRoZSBmaW5hbmNpYWwgZGF0YSBwcm92aWRlZCwgdGhlIGNvbXBhbnkncyBjdXJyZW50IEFubnVhbCBSZWN1cnJpbmcgUmV2ZW51ZSAoQVJSKSBpcyAkNDAuNDkgbWlsbGlvbiBBVUQgKFVTJDMxLjIzIG1pbGxpb24pLiBUaGlzIGZpZ3VyZSBpcyBzb3VyY2VkIGZyb20gdGhlIG1vc3QgcmVjZW50IGZpbmFuY2lhbCByZXBvcnRzIGRhdGVkIE1hcmNoIDIwMjEuXCJcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKG1lc3NhZ2UuaW5jbHVkZXMoXCJidXJuIHJhdGVcIikpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0ZXh0OiBcIlRoZSBjdXJyZW50IG1vbnRobHkgYnVybiByYXRlIGlzIGFwcHJveGltYXRlbHkgJDIuMSBtaWxsaW9uIEFVRCAoVVMkMS42MiBtaWxsaW9uKSwgY2FsY3VsYXRlZCBhcyBhbiBhdmVyYWdlIG9mIHRoZSBsYXN0IHRocmVlIG1vbnRocyBvZiBvcGVyYXRpb25hbCBleHBlbnNlcy5cIlxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAobWVzc2FnZS5pbmNsdWRlcyhcInJ1bndheVwiKSkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRleHQ6IFwiQmFzZWQgb24gdGhlIGN1cnJlbnQgY2FzaCByZXNlcnZlcyBvZiAkMjUuMyBtaWxsaW9uIEFVRCBhbmQgYSBtb250aGx5IGJ1cm4gcmF0ZSBvZiAkMi4xIG1pbGxpb24gQVVELCB0aGUgY29tcGFueSBoYXMgYXBwcm94aW1hdGVseSAxMiBtb250aHMgb2YgcnVud2F5IHJlbWFpbmluZy5cIlxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAobWVzc2FnZS5pbmNsdWRlcyhcIm1hbmFnZW1lbnQgdGVhbVwiKSkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRleHQ6IFwiVGhlIGtleSBtZW1iZXJzIG9mIHRoZSBtYW5hZ2VtZW50IHRlYW0gaW5jbHVkZTpcXG5cXG4tIFNhcmFoIEpvaG5zb24sIENFTyAtIEZvcm1lciBWUCBvZiBQcm9kdWN0IGF0IFNhbGVzZm9yY2Ugd2l0aCAxNSsgeWVhcnMgaW4gU2FhU1xcbi0gTWljaGFlbCBDaGVuLCBDVE8gLSBQcmV2aW91c2x5IGxlZCBlbmdpbmVlcmluZyB0ZWFtcyBhdCBHb29nbGUgYW5kIERyb3Bib3hcXG4tIEVtbWEgUm9kcmlndWV6LCBDRk8gLSAxMiB5ZWFycyBvZiBmaW5hbmNpYWwgbGVhZGVyc2hpcCBpbiB0ZWNoIHN0YXJ0dXBzXFxuLSBEYXZpZCBLaW0sIENPTyAtIEJhY2tncm91bmQgaW4gb3BlcmF0aW9ucyBhdCBBbWF6b24gYW5kIFViZXJcIlxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAobWVzc2FnZS5pbmNsdWRlcyhcInByb2ZpdGFibGVcIikpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0ZXh0OiBcIlRoZSBjb21wYW55IGlzIG5vdCB5ZXQgcHJvZml0YWJsZS4gQWNjb3JkaW5nIHRvIHRoZSBmaW5hbmNpYWwgZGF0YSwgdGhleSBhcmUgY3VycmVudGx5IG9wZXJhdGluZyBhdCBhIGxvc3Mgd2l0aCBhIG5lZ2F0aXZlIHByb2ZpdCBtYXJnaW4gb2YgLTE1JS4gSG93ZXZlciwgdGhleSBwcm9qZWN0IHJlYWNoaW5nIHByb2ZpdGFiaWxpdHkgd2l0aGluIHRoZSBuZXh0IDE4IG1vbnRocyBiYXNlZCBvbiB0aGVpciBjdXJyZW50IGdyb3d0aCB0cmFqZWN0b3J5LlwiXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIERlZmF1bHQgcmVzcG9uc2UgZm9yIG90aGVyIHF1ZXN0aW9uc1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdGV4dDogYFRoaXMgaXMgYSBkZXZlbG9wbWVudCBtb2RlIHJlc3BvbnNlLiBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGNhbGwgdGhlIE9wZW5BSSBBUEkgdG8gYW5hbHl6ZSB5b3VyIGRvY3VtZW50cyAoJHtmaWxlTmFtZXN9KSBhbmQgYW5zd2VyIHlvdXIgcXVlc3Rpb24gYWJvdXQ6IFwiJHttZXNzYWdlfVwiLmBcclxuICAgIH07XHJcbiAgfVxyXG59OyJdLCJuYW1lcyI6WyJPcGVuQUkiLCJwcm9jZXNzRXhjZWxRdWVzdGlvbiIsImdldFN1Z2dlc3RlZFF1ZXN0aW9ucyIsIkZBTExCQUNLX0FQSV9LRVkiLCJjb25zb2xlIiwibG9nIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX09QRU5BSV9BUElfS0VZIiwic3Vic3RyaW5nIiwiYXBpS2V5IiwiaXNQcm9qZWN0S2V5Iiwic3RhcnRzV2l0aCIsInByb2plY3RJZCIsIk5FWFRfUFVCTElDX09QRU5BSV9QUk9KRUNUX0lEIiwic3BsaXQiLCJ1bmRlZmluZWQiLCJvcGVuYWkiLCJkYW5nZXJvdXNseUFsbG93QnJvd3NlciIsImJhc2VVUkwiLCJFWENFTF9LRVlXT1JEUyIsInByZXBhcmVFeGNlbENvbnRleHRGb3JBSSIsImNvbnRlbnQiLCJjaGF0U2VydmljZSIsInNlbmRNZXNzYWdlIiwibWVzc2FnZSIsImZpbGVzIiwiaXNEZXZlbG9wbWVudE1vZGUiLCJlcnJvciIsIkVycm9yIiwibGVuZ3RoIiwid2FybiIsInRleHQiLCJnZXRNb2NrUmVzcG9uc2UiLCJjb250ZXh0TWVzc2FnZSIsIm1hcCIsImYiLCJuYW1lIiwidHlwZSIsImpvaW4iLCJwZGZGaWxlcyIsImZpbHRlciIsImZpbGUiLCJ0b0xvd2VyQ2FzZSIsImVuZHNXaXRoIiwiZXhjZWxGaWxlcyIsImZpbGVDb250ZW50QWRkZWQiLCJwZGZDb250ZW50IiwiY29udGVudExlbmd0aCIsImtleVBocmFzZXMiLCJleHRyYWN0ZWRDb250ZW50IiwiY2h1bmtTaXplIiwiaSIsImNodW5rIiwiTWF0aCIsIm1pbiIsImNvbnRhaW5zS2V5UGhyYXNlIiwic29tZSIsInBocmFzZSIsImluY2x1ZGVzIiwiZW5kU2VjdGlvbiIsIm1heCIsImV4Y2VsQ29udGVudCIsInNoZWV0U2VwYXJhdG9yUGF0dGVybiIsInNoZWV0TWF0Y2hlcyIsIm1hdGNoQWxsIiwiaGlnaFByaW9yaXR5U2hlZXRzIiwic2hlZXROYW1lTWF0Y2giLCJzaGVldE5hbWUiLCJpc0hpZ2hQcmlvcml0eSIsImtleXdvcmQiLCJzaGVldFN0YXJ0IiwiaW5kZXgiLCJuZXh0U2hlZXRNYXRjaCIsInNoZWV0RW5kIiwic2hlZXRDb250ZW50IiwiZnVsbE1lc3NhZ2UiLCJtb2RlbCIsInJlc3BvbnNlIiwiY2hhdCIsImNvbXBsZXRpb25zIiwiY3JlYXRlIiwibWVzc2FnZXMiLCJyb2xlIiwidGVtcGVyYXR1cmUiLCJtYXhfY29tcGxldGlvbl90b2tlbnMiLCJjaG9pY2VzIiwic3VnZ2VzdGVkUXVlc3Rpb25zIiwiYXBpRXJyb3IiLCJzdGF0dXMiLCJpc0V4Y2VsUmVsYXRlZFF1ZXN0aW9uIiwicXVlc3Rpb24iLCJsb3dlclF1ZXN0aW9uIiwiZ2V0U3VnZ2VzdGVkRXhjZWxRdWVzdGlvbnMiLCJsYXRlc3RFeGNlbEZpbGUiLCJjb250ZXh0RGF0YSIsInNoZWV0cyIsImV4Y2VsRGF0YSIsIm1ldGFkYXRhIiwiZmlsZU5hbWVzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/services/chatService.js\n"));

/***/ })

});