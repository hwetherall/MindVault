"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/services/filesService.js":
/*!**************************************!*\
  !*** ./app/services/filesService.js ***!
  \**************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   filesService: () => (/* binding */ filesService)\n/* harmony export */ });\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/supabase */ \"(app-pages-browser)/./app/lib/supabase.js\");\n/**\r\n * Service for handling file operations with Supabase\r\n */ \n/**\r\n * Formats file size in a human-readable format\r\n */ const formatFileSize = (bytes)=>{\n    if (bytes < 1024) return bytes + ' bytes';\n    else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';\n    else return (bytes / 1048576).toFixed(1) + ' MB';\n};\n/**\r\n * Extract text from PDF file\r\n */ const extractTextFromPDF = async (file)=>{\n    try {\n        const arrayBuffer = await file.arrayBuffer();\n        // Here, we'll just read the file as text for simplicity\n        // In a real app, you would use a PDF parsing library like pdf.js\n        const textDecoder = new TextDecoder('utf-8');\n        try {\n            // Get the raw text from the PDF\n            const rawText = textDecoder.decode(arrayBuffer);\n            // Clean the text by removing null bytes and other control characters\n            // This prevents PostgreSQL from rejecting the content\n            const cleanedText = rawText.replace(/\\u0000/g, '') // Remove null bytes\n            .replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g, ''); // Remove other control characters\n            console.log(\"PDF processed, removed \".concat(rawText.length - cleanedText.length, \" invalid characters\"));\n            return cleanedText;\n        } catch (error) {\n            console.error('Error decoding PDF text:', error);\n            return 'Unable to extract text from PDF';\n        }\n    } catch (error) {\n        console.error('Error reading PDF:', error);\n        return '';\n    }\n};\n/**\r\n * Extract data from Excel file\r\n */ const extractTextFromExcel = async (file)=>{\n    try {\n        // In a real app, you would use a library like xlsx or exceljs\n        // For now, we'll just return a placeholder\n        return \"Extracted text from Excel file: \".concat(file.name);\n    } catch (error) {\n        console.error('Error reading Excel file:', error);\n        return '';\n    }\n};\n/**\r\n * Uploads a document to Supabase storage and database\r\n */ const uploadDocument = async (file)=>{\n    try {\n        console.log(\"Processing document: \".concat(file.name, \", type: \").concat(file.type, \", size: \").concat(file.size, \" bytes\"));\n        // Extract text content from PDF\n        let textContent = '';\n        if (file.type === 'application/pdf') {\n            console.log('Processing as PDF...');\n            textContent = await extractTextFromPDF(file);\n            console.log(\"PDF processing complete, extracted \".concat(textContent.length, \" characters\"));\n        } else {\n            console.log(\"Unsupported document type: \".concat(file.type, \", no text extraction performed\"));\n        }\n        // Upload file to Supabase Storage\n        const fileName = \"\".concat(Date.now(), \"-\").concat(file.name);\n        console.log(\"Uploading file to Supabase storage bucket 'documents' with name: \".concat(fileName));\n        const { error: uploadError, data: storageData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.storage.from('documents').upload(fileName, file, {\n            cacheControl: '3600',\n            upsert: false\n        });\n        if (uploadError) {\n            console.error('Storage upload error:', JSON.stringify(uploadError));\n            throw new Error(\"Storage upload error: \".concat(JSON.stringify(uploadError)));\n        }\n        console.log('File successfully uploaded to storage, getting public URL');\n        // Get the public URL\n        const { data: { publicUrl } } = _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.storage.from('documents').getPublicUrl(fileName);\n        console.log(\"Public URL generated: \".concat(publicUrl));\n        // Create database record\n        console.log('Creating database record for the uploaded file');\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('documents').insert([\n            {\n                title: file.name,\n                file_path: fileName,\n                file_type: file.type,\n                file_size: file.size,\n                content: textContent,\n                public_url: publicUrl\n            }\n        ]).select();\n        if (error) {\n            console.error('Database insert error:', JSON.stringify(error));\n            throw new Error(\"Database insert error: \".concat(JSON.stringify(error)));\n        }\n        console.log('Document successfully uploaded and recorded in database');\n        // Return formatted document\n        return {\n            id: data[0].id,\n            name: data[0].title,\n            type: 'document',\n            content: data[0].content,\n            size: formatFileSize(data[0].file_size),\n            uploadDate: new Date(data[0].created_at),\n            url: data[0].public_url\n        };\n    } catch (error) {\n        console.error('Upload document error:', error);\n        throw error;\n    }\n};\n/**\r\n * Uploads a spreadsheet to Supabase storage and database\r\n */ const uploadSpreadsheet = async (file)=>{\n    try {\n        console.log(\"Processing spreadsheet: \".concat(file.name, \", type: \").concat(file.type, \", size: \").concat(file.size, \" bytes\"));\n        // Extract content from Excel\n        let textContent = '';\n        let structuredData = null;\n        if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls') || file.type.includes('excel')) {\n            console.log('Processing as Excel...');\n            textContent = await extractTextFromExcel(file);\n            // In a real app, you would parse the Excel data into structured JSON\n            structuredData = JSON.stringify([\n                [\n                    'Header 1',\n                    'Header 2'\n                ],\n                [\n                    'Data 1',\n                    'Data 2'\n                ]\n            ]);\n            console.log(\"Excel processing complete, extracted \".concat(textContent.length, \" characters\"));\n        } else {\n            console.log(\"Unsupported spreadsheet type: \".concat(file.type, \", no text extraction performed\"));\n        }\n        // Upload file to Supabase Storage\n        const fileName = \"\".concat(Date.now(), \"-\").concat(file.name);\n        console.log(\"Uploading file to Supabase storage bucket 'spreadsheets' with name: \".concat(fileName));\n        const { error: uploadError, data: storageData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.storage.from('spreadsheets').upload(fileName, file, {\n            cacheControl: '3600',\n            upsert: false\n        });\n        if (uploadError) {\n            console.error('Storage upload error:', JSON.stringify(uploadError));\n            throw new Error(\"Storage upload error: \".concat(JSON.stringify(uploadError)));\n        }\n        console.log('File successfully uploaded to storage, getting public URL');\n        // Get the public URL\n        const { data: { publicUrl } } = _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.storage.from('spreadsheets').getPublicUrl(fileName);\n        console.log(\"Public URL generated: \".concat(publicUrl));\n        // Create database record\n        console.log('Creating database record for the uploaded file');\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('documents').insert([\n            {\n                title: file.name,\n                file_path: fileName,\n                file_type: \"spreadsheet/\".concat(file.type),\n                file_size: file.size,\n                content: textContent,\n                structured_data: structuredData,\n                public_url: publicUrl\n            }\n        ]).select();\n        if (error) {\n            console.error('Database insert error:', JSON.stringify(error));\n            throw new Error(\"Database insert error: \".concat(JSON.stringify(error)));\n        }\n        console.log('Spreadsheet successfully uploaded and recorded in database');\n        // Return formatted spreadsheet\n        return {\n            id: data[0].id,\n            name: data[0].title,\n            type: 'spreadsheet',\n            data: JSON.parse(data[0].structured_data || '[[]]'),\n            size: formatFileSize(data[0].file_size),\n            uploadDate: new Date(data[0].created_at),\n            url: data[0].public_url\n        };\n    } catch (error) {\n        console.error('Upload spreadsheet error:', error);\n        throw error;\n    }\n};\n/**\r\n * Retrieves all files from Supabase\r\n */ const getFiles = async ()=>{\n    try {\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('documents').select('*').order('created_at', {\n            ascending: false\n        });\n        if (error) throw error;\n        return data.map((file)=>{\n            if (file.file_type.includes('spreadsheet')) {\n                // Return as Spreadsheet type\n                return {\n                    id: file.id,\n                    name: file.title || file.name,\n                    type: 'spreadsheet',\n                    data: file.structured_data ? JSON.parse(file.structured_data) : [\n                        []\n                    ],\n                    size: formatFileSize(file.file_size || 0),\n                    uploadDate: new Date(file.created_at),\n                    url: file.public_url\n                };\n            } else {\n                // Return as Document type\n                return {\n                    id: file.id,\n                    name: file.title || file.name,\n                    type: 'document',\n                    content: file.content || '',\n                    size: formatFileSize(file.file_size || 0),\n                    uploadDate: new Date(file.created_at),\n                    url: file.public_url\n                };\n            }\n        });\n    } catch (e) {\n        console.warn('Could not fetch files from Supabase:', e);\n        return [];\n    }\n};\n/**\r\n * Deletes a file by ID\r\n */ const deleteFile = async (id)=>{\n    try {\n        // First get the file info to get the storage path\n        const { data: file } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('documents').select('file_path, file_type').eq('id', id).single();\n        if (file) {\n            // Determine the storage bucket based on file type\n            const bucket = file.file_type.includes('spreadsheet') ? 'spreadsheets' : 'documents';\n            // Delete from storage\n            const { error: storageError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.storage.from(bucket).remove([\n                file.file_path\n            ]);\n            if (storageError) {\n                console.error('Storage delete error:', storageError);\n            }\n        }\n        // Delete from database\n        const { error: dbError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('documents').delete().eq('id', id);\n        if (dbError) throw dbError;\n        return true;\n    } catch (error) {\n        console.error('Error deleting file:', error);\n        throw error;\n    }\n};\nconst filesService = {\n    uploadDocument,\n    uploadSpreadsheet,\n    getFiles,\n    deleteFile,\n    extractTextFromPDF,\n    extractTextFromExcel\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zZXJ2aWNlcy9maWxlc1NlcnZpY2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Q0FFQyxHQUMwQztBQUUzQzs7Q0FFQyxHQUNELE1BQU1DLGlCQUFpQixDQUFDQztJQUN0QixJQUFJQSxRQUFRLE1BQU0sT0FBT0EsUUFBUTtTQUM1QixJQUFJQSxRQUFRLFNBQVMsT0FBTyxDQUFDQSxRQUFRLElBQUcsRUFBR0MsT0FBTyxDQUFDLEtBQUs7U0FDeEQsT0FBTyxDQUFDRCxRQUFRLE9BQU0sRUFBR0MsT0FBTyxDQUFDLEtBQUs7QUFDN0M7QUFFQTs7Q0FFQyxHQUNELE1BQU1DLHFCQUFxQixPQUFPQztJQUNoQyxJQUFJO1FBQ0YsTUFBTUMsY0FBYyxNQUFNRCxLQUFLQyxXQUFXO1FBRTFDLHdEQUF3RDtRQUN4RCxpRUFBaUU7UUFDakUsTUFBTUMsY0FBYyxJQUFJQyxZQUFZO1FBQ3BDLElBQUk7WUFDRixnQ0FBZ0M7WUFDaEMsTUFBTUMsVUFBVUYsWUFBWUcsTUFBTSxDQUFDSjtZQUVuQyxxRUFBcUU7WUFDckUsc0RBQXNEO1lBQ3RELE1BQU1LLGNBQWNGLFFBQ2pCRyxPQUFPLENBQUMsV0FBVyxJQUFJLG9CQUFvQjthQUMzQ0EsT0FBTyxDQUFDLHFDQUFxQyxLQUFLLGtDQUFrQztZQUV2RkMsUUFBUUMsR0FBRyxDQUFDLDBCQUE4RCxPQUFwQ0wsUUFBUU0sTUFBTSxHQUFHSixZQUFZSSxNQUFNLEVBQUM7WUFFMUUsT0FBT0o7UUFDVCxFQUFFLE9BQU9LLE9BQU87WUFDZEgsUUFBUUcsS0FBSyxDQUFDLDRCQUE0QkE7WUFDMUMsT0FBTztRQUNUO0lBQ0YsRUFBRSxPQUFPQSxPQUFPO1FBQ2RILFFBQVFHLEtBQUssQ0FBQyxzQkFBc0JBO1FBQ3BDLE9BQU87SUFDVDtBQUNGO0FBRUE7O0NBRUMsR0FDRCxNQUFNQyx1QkFBdUIsT0FBT1o7SUFDbEMsSUFBSTtRQUNGLDhEQUE4RDtRQUM5RCwyQ0FBMkM7UUFDM0MsT0FB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R0FDTk4sRUFBRSxDQUFDLE1BQU1qQjtRQUVaLElBQUlzQixTQUFTLE1BQU1BO1FBRW5CLE9BQU87SUFDVCxFQUFFLE9BQU9yRCxPQUFPO1FBQ2RILFFBQVFHLEtBQUssQ0FBQyx3QkFBd0JBO1FBQ3RDLE1BQU1BO0lBQ1I7QUFDRjtBQUVPLE1BQU11RCxlQUFlO0lBQzFCcEQ7SUFDQWdDO0lBQ0FNO0lBQ0FNO0lBQ0EzRDtJQUNBYTtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcaHdldGhcXE9uZURyaXZlXFxEZXNrdG9wXFxJbm5vdmVyYVxcSGlnZ2luc1xcTWluZFZhdWx0XFxNaW5kVmF1bHQtMVxcbWluZHZhdWx0XFxhcHBcXHNlcnZpY2VzXFxmaWxlc1NlcnZpY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFNlcnZpY2UgZm9yIGhhbmRsaW5nIGZpbGUgb3BlcmF0aW9ucyB3aXRoIFN1cGFiYXNlXHJcbiAqL1xyXG5pbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gJy4uL2xpYi9zdXBhYmFzZSc7XHJcblxyXG4vKipcclxuICogRm9ybWF0cyBmaWxlIHNpemUgaW4gYSBodW1hbi1yZWFkYWJsZSBmb3JtYXRcclxuICovXHJcbmNvbnN0IGZvcm1hdEZpbGVTaXplID0gKGJ5dGVzKSA9PiB7XHJcbiAgaWYgKGJ5dGVzIDwgMTAyNCkgcmV0dXJuIGJ5dGVzICsgJyBieXRlcyc7XHJcbiAgZWxzZSBpZiAoYnl0ZXMgPCAxMDQ4NTc2KSByZXR1cm4gKGJ5dGVzIC8gMTAyNCkudG9GaXhlZCgxKSArICcgS0InO1xyXG4gIGVsc2UgcmV0dXJuIChieXRlcyAvIDEwNDg1NzYpLnRvRml4ZWQoMSkgKyAnIE1CJztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFeHRyYWN0IHRleHQgZnJvbSBQREYgZmlsZVxyXG4gKi9cclxuY29uc3QgZXh0cmFjdFRleHRGcm9tUERGID0gYXN5bmMgKGZpbGUpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBmaWxlLmFycmF5QnVmZmVyKCk7XHJcbiAgICBcclxuICAgIC8vIEhlcmUsIHdlJ2xsIGp1c3QgcmVhZCB0aGUgZmlsZSBhcyB0ZXh0IGZvciBzaW1wbGljaXR5XHJcbiAgICAvLyBJbiBhIHJlYWwgYXBwLCB5b3Ugd291bGQgdXNlIGEgUERGIHBhcnNpbmcgbGlicmFyeSBsaWtlIHBkZi5qc1xyXG4gICAgY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04Jyk7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBHZXQgdGhlIHJhdyB0ZXh0IGZyb20gdGhlIFBERlxyXG4gICAgICBjb25zdCByYXdUZXh0ID0gdGV4dERlY29kZXIuZGVjb2RlKGFycmF5QnVmZmVyKTtcclxuICAgICAgXHJcbiAgICAgIC8vIENsZWFuIHRoZSB0ZXh0IGJ5IHJlbW92aW5nIG51bGwgYnl0ZXMgYW5kIG90aGVyIGNvbnRyb2wgY2hhcmFjdGVyc1xyXG4gICAgICAvLyBUaGlzIHByZXZlbnRzIFBvc3RncmVTUUwgZnJvbSByZWplY3RpbmcgdGhlIGNvbnRlbnRcclxuICAgICAgY29uc3QgY2xlYW5lZFRleHQgPSByYXdUZXh0XHJcbiAgICAgICAgLnJlcGxhY2UoL1xcdTAwMDAvZywgJycpIC8vIFJlbW92ZSBudWxsIGJ5dGVzXHJcbiAgICAgICAgLnJlcGxhY2UoL1tcXHgwMC1cXHgwOFxceDBCXFx4MENcXHgwRS1cXHgxRlxceDdGXS9nLCAnJyk7IC8vIFJlbW92ZSBvdGhlciBjb250cm9sIGNoYXJhY3RlcnNcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKGBQREYgcHJvY2Vzc2VkLCByZW1vdmVkICR7cmF3VGV4dC5sZW5ndGggLSBjbGVhbmVkVGV4dC5sZW5ndGh9IGludmFsaWQgY2hhcmFjdGVyc2ApO1xyXG4gICAgICBcclxuICAgICAgcmV0dXJuIGNsZWFuZWRUZXh0O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVjb2RpbmcgUERGIHRleHQ6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gJ1VuYWJsZSB0byBleHRyYWN0IHRleHQgZnJvbSBQREYnO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWFkaW5nIFBERjonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gJyc7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEV4dHJhY3QgZGF0YSBmcm9tIEV4Y2VsIGZpbGVcclxuICovXHJcbmNvbnN0IGV4dHJhY3RUZXh0RnJvbUV4Y2VsID0gYXN5bmMgKGZpbGUpID0+IHtcclxuICB0cnkge1xyXG4gICAgLy8gSW4gYSByZWFsIGFwcCwgeW91IHdvdWxkIHVzZSBhIGxpYnJhcnkgbGlrZSB4bHN4IG9yIGV4Y2VsanNcclxuICAgIC8vIEZvciBub3csIHdlJ2xsIGp1c3QgcmV0dXJuIGEgcGxhY2Vob2xkZXJcclxuICAgIHJldHVybiBgRXh0cmFjdGVkIHRleHQgZnJvbSBFeGNlbCBmaWxlOiAke2ZpbGUubmFtZX1gO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWFkaW5nIEV4Y2VsIGZpbGU6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBVcGxvYWRzIGEgZG9jdW1lbnQgdG8gU3VwYWJhc2Ugc3RvcmFnZSBhbmQgZGF0YWJhc2VcclxuICovXHJcbmNvbnN0IHVwbG9hZERvY3VtZW50ID0gYXN5bmMgKGZpbGUpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc29sZS5sb2coYFByb2Nlc3NpbmcgZG9jdW1lbnQ6ICR7ZmlsZS5uYW1lfSwgdHlwZTogJHtmaWxlLnR5cGV9LCBzaXplOiAke2ZpbGUuc2l6ZX0gYnl0ZXNgKTtcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCB0ZXh0IGNvbnRlbnQgZnJvbSBQREZcclxuICAgIGxldCB0ZXh0Q29udGVudCA9ICcnO1xyXG4gICAgaWYgKGZpbGUudHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3BkZicpIHtcclxuICAgICAgY29uc29sZS5sb2coJ1Byb2Nlc3NpbmcgYXMgUERGLi4uJyk7XHJcbiAgICAgIHRleHRDb250ZW50ID0gYXdhaXQgZXh0cmFjdFRleHRGcm9tUERGKGZpbGUpO1xyXG4gICAgICBjb25zb2xlLmxvZyhgUERGIHByb2Nlc3NpbmcgY29tcGxldGUsIGV4dHJhY3RlZCAke3RleHRDb250ZW50Lmxlbmd0aH0gY2hhcmFjdGVyc2ApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5sb2coYFVuc3VwcG9ydGVkIGRvY3VtZW50IHR5cGU6ICR7ZmlsZS50eXBlfSwgbm8gdGV4dCBleHRyYWN0aW9uIHBlcmZvcm1lZGApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBVcGxvYWQgZmlsZSB0byBTdXBhYmFzZSBTdG9yYWdlXHJcbiAgICBjb25zdCBmaWxlTmFtZSA9IGAke0RhdGUubm93KCl9LSR7ZmlsZS5uYW1lfWA7XHJcbiAgICBjb25zb2xlLmxvZyhgVXBsb2FkaW5nIGZpbGUgdG8gU3VwYWJhc2Ugc3RvcmFnZSBidWNrZXQgJ2RvY3VtZW50cycgd2l0aCBuYW1lOiAke2ZpbGVOYW1lfWApO1xyXG4gICAgY29uc3QgeyBlcnJvcjogdXBsb2FkRXJyb3IsIGRhdGE6IHN0b3JhZ2VEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZS5zdG9yYWdlXHJcbiAgICAgIC5mcm9tKCdkb2N1bWVudHMnKVxyXG4gICAgICAudXBsb2FkKGZpbGVOYW1lLCBmaWxlLCB7XHJcbiAgICAgICAgY2FjaGVDb250cm9sOiAnMzYwMCcsXHJcbiAgICAgICAgdXBzZXJ0OiBmYWxzZVxyXG4gICAgICB9KTtcclxuXHJcbiAgICBpZiAodXBsb2FkRXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignU3RvcmFnZSB1cGxvYWQgZXJyb3I6JywgSlNPTi5zdHJpbmdpZnkodXBsb2FkRXJyb3IpKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdG9yYWdlIHVwbG9hZCBlcnJvcjogJHtKU09OLnN0cmluZ2lmeSh1cGxvYWRFcnJvcil9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coJ0ZpbGUgc3VjY2Vzc2Z1bGx5IHVwbG9hZGVkIHRvIHN0b3JhZ2UsIGdldHRpbmcgcHVibGljIFVSTCcpO1xyXG4gICAgLy8gR2V0IHRoZSBwdWJsaWMgVVJMXHJcbiAgICBjb25zdCB7IGRhdGE6IHsgcHVibGljVXJsIH0gfSA9IHN1cGFiYXNlLnN0b3JhZ2VcclxuICAgICAgLmZyb20oJ2RvY3VtZW50cycpXHJcbiAgICAgIC5nZXRQdWJsaWNVcmwoZmlsZU5hbWUpO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKGBQdWJsaWMgVVJMIGdlbmVyYXRlZDogJHtwdWJsaWNVcmx9YCk7XHJcbiAgICBcclxuICAgIC8vIENyZWF0ZSBkYXRhYmFzZSByZWNvcmRcclxuICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBkYXRhYmFzZSByZWNvcmQgZm9yIHRoZSB1cGxvYWRlZCBmaWxlJyk7XHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnZG9jdW1lbnRzJylcclxuICAgICAgLmluc2VydChbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgdGl0bGU6IGZpbGUubmFtZSxcclxuICAgICAgICAgIGZpbGVfcGF0aDogZmlsZU5hbWUsXHJcbiAgICAgICAgICBmaWxlX3R5cGU6IGZpbGUudHlwZSxcclxuICAgICAgICAgIGZpbGVfc2l6ZTogZmlsZS5zaXplLFxyXG4gICAgICAgICAgY29udGVudDogdGV4dENvbnRlbnQsXHJcbiAgICAgICAgICBwdWJsaWNfdXJsOiBwdWJsaWNVcmxcclxuICAgICAgICB9XHJcbiAgICAgIF0pXHJcbiAgICAgIC5zZWxlY3QoKTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRGF0YWJhc2UgaW5zZXJ0IGVycm9yOicsIEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YWJhc2UgaW5zZXJ0IGVycm9yOiAke0pTT04uc3RyaW5naWZ5KGVycm9yKX1gKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ0RvY3VtZW50IHN1Y2Nlc3NmdWxseSB1cGxvYWRlZCBhbmQgcmVjb3JkZWQgaW4gZGF0YWJhc2UnKTtcclxuICAgIC8vIFJldHVybiBmb3JtYXR0ZWQgZG9jdW1lbnRcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkOiBkYXRhWzBdLmlkLFxyXG4gICAgICBuYW1lOiBkYXRhWzBdLnRpdGxlLFxyXG4gICAgICB0eXBlOiAnZG9jdW1lbnQnLFxyXG4gICAgICBjb250ZW50OiBkYXRhWzBdLmNvbnRlbnQsXHJcbiAgICAgIHNpemU6IGZvcm1hdEZpbGVTaXplKGRhdGFbMF0uZmlsZV9zaXplKSxcclxuICAgICAgdXBsb2FkRGF0ZTogbmV3IERhdGUoZGF0YVswXS5jcmVhdGVkX2F0KSxcclxuICAgICAgdXJsOiBkYXRhWzBdLnB1YmxpY191cmxcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ1VwbG9hZCBkb2N1bWVudCBlcnJvcjonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogVXBsb2FkcyBhIHNwcmVhZHNoZWV0IHRvIFN1cGFiYXNlIHN0b3JhZ2UgYW5kIGRhdGFiYXNlXHJcbiAqL1xyXG5jb25zdCB1cGxvYWRTcHJlYWRzaGVldCA9IGFzeW5jIChmaWxlKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKGBQcm9jZXNzaW5nIHNwcmVhZHNoZWV0OiAke2ZpbGUubmFtZX0sIHR5cGU6ICR7ZmlsZS50eXBlfSwgc2l6ZTogJHtmaWxlLnNpemV9IGJ5dGVzYCk7XHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3QgY29udGVudCBmcm9tIEV4Y2VsXHJcbiAgICBsZXQgdGV4dENvbnRlbnQgPSAnJztcclxuICAgIGxldCBzdHJ1Y3R1cmVkRGF0YSA9IG51bGw7XHJcbiAgICBcclxuICAgIGlmIChmaWxlLm5hbWUuZW5kc1dpdGgoJy54bHN4JykgfHwgZmlsZS5uYW1lLmVuZHNXaXRoKCcueGxzJykgfHwgZmlsZS50eXBlLmluY2x1ZGVzKCdleGNlbCcpKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdQcm9jZXNzaW5nIGFzIEV4Y2VsLi4uJyk7XHJcbiAgICAgIHRleHRDb250ZW50ID0gYXdhaXQgZXh0cmFjdFRleHRGcm9tRXhjZWwoZmlsZSk7XHJcbiAgICAgIC8vIEluIGEgcmVhbCBhcHAsIHlvdSB3b3VsZCBwYXJzZSB0aGUgRXhjZWwgZGF0YSBpbnRvIHN0cnVjdHVyZWQgSlNPTlxyXG4gICAgICBzdHJ1Y3R1cmVkRGF0YSA9IEpTT04uc3RyaW5naWZ5KFtbJ0hlYWRlciAxJywgJ0hlYWRlciAyJ10sIFsnRGF0YSAxJywgJ0RhdGEgMiddXSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBFeGNlbCBwcm9jZXNzaW5nIGNvbXBsZXRlLCBleHRyYWN0ZWQgJHt0ZXh0Q29udGVudC5sZW5ndGh9IGNoYXJhY3RlcnNgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBVbnN1cHBvcnRlZCBzcHJlYWRzaGVldCB0eXBlOiAke2ZpbGUudHlwZX0sIG5vIHRleHQgZXh0cmFjdGlvbiBwZXJmb3JtZWRgKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gVXBsb2FkIGZpbGUgdG8gU3VwYWJhc2UgU3RvcmFnZVxyXG4gICAgY29uc3QgZmlsZU5hbWUgPSBgJHtEYXRlLm5vdygpfS0ke2ZpbGUubmFtZX1gO1xyXG4gICAgY29uc29sZS5sb2coYFVwbG9hZGluZyBmaWxlIHRvIFN1cGFiYXNlIHN0b3JhZ2UgYnVja2V0ICdzcHJlYWRzaGVldHMnIHdpdGggbmFtZTogJHtmaWxlTmFtZX1gKTtcclxuICAgIGNvbnN0IHsgZXJyb3I6IHVwbG9hZEVycm9yLCBkYXRhOiBzdG9yYWdlRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2Uuc3RvcmFnZVxyXG4gICAgICAuZnJvbSgnc3ByZWFkc2hlZXRzJylcclxuICAgICAgLnVwbG9hZChmaWxlTmFtZSwgZmlsZSwge1xyXG4gICAgICAgIGNhY2hlQ29udHJvbDogJzM2MDAnLFxyXG4gICAgICAgIHVwc2VydDogZmFsc2VcclxuICAgICAgfSk7XHJcblxyXG4gICAgaWYgKHVwbG9hZEVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1N0b3JhZ2UgdXBsb2FkIGVycm9yOicsIEpTT04uc3RyaW5naWZ5KHVwbG9hZEVycm9yKSk7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU3RvcmFnZSB1cGxvYWQgZXJyb3I6ICR7SlNPTi5zdHJpbmdpZnkodXBsb2FkRXJyb3IpfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKCdGaWxlIHN1Y2Nlc3NmdWxseSB1cGxvYWRlZCB0byBzdG9yYWdlLCBnZXR0aW5nIHB1YmxpYyBVUkwnKTtcclxuICAgIC8vIEdldCB0aGUgcHVibGljIFVSTFxyXG4gICAgY29uc3QgeyBkYXRhOiB7IHB1YmxpY1VybCB9IH0gPSBzdXBhYmFzZS5zdG9yYWdlXHJcbiAgICAgIC5mcm9tKCdzcHJlYWRzaGVldHMnKVxyXG4gICAgICAuZ2V0UHVibGljVXJsKGZpbGVOYW1lKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhgUHVibGljIFVSTCBnZW5lcmF0ZWQ6ICR7cHVibGljVXJsfWApO1xyXG4gICAgXHJcbiAgICAvLyBDcmVhdGUgZGF0YWJhc2UgcmVjb3JkXHJcbiAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgZGF0YWJhc2UgcmVjb3JkIGZvciB0aGUgdXBsb2FkZWQgZmlsZScpO1xyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ2RvY3VtZW50cycpXHJcbiAgICAgIC5pbnNlcnQoW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIHRpdGxlOiBmaWxlLm5hbWUsXHJcbiAgICAgICAgICBmaWxlX3BhdGg6IGZpbGVOYW1lLFxyXG4gICAgICAgICAgZmlsZV90eXBlOiBgc3ByZWFkc2hlZXQvJHtmaWxlLnR5cGV9YCxcclxuICAgICAgICAgIGZpbGVfc2l6ZTogZmlsZS5zaXplLFxyXG4gICAgICAgICAgY29udGVudDogdGV4dENvbnRlbnQsXHJcbiAgICAgICAgICBzdHJ1Y3R1cmVkX2RhdGE6IHN0cnVjdHVyZWREYXRhLFxyXG4gICAgICAgICAgcHVibGljX3VybDogcHVibGljVXJsXHJcbiAgICAgICAgfVxyXG4gICAgICBdKVxyXG4gICAgICAuc2VsZWN0KCk7XHJcblxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0RhdGFiYXNlIGluc2VydCBlcnJvcjonLCBKU09OLnN0cmluZ2lmeShlcnJvcikpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFiYXNlIGluc2VydCBlcnJvcjogJHtKU09OLnN0cmluZ2lmeShlcnJvcil9YCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdTcHJlYWRzaGVldCBzdWNjZXNzZnVsbHkgdXBsb2FkZWQgYW5kIHJlY29yZGVkIGluIGRhdGFiYXNlJyk7XHJcbiAgICAvLyBSZXR1cm4gZm9ybWF0dGVkIHNwcmVhZHNoZWV0XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpZDogZGF0YVswXS5pZCxcclxuICAgICAgbmFtZTogZGF0YVswXS50aXRsZSxcclxuICAgICAgdHlwZTogJ3NwcmVhZHNoZWV0JyxcclxuICAgICAgZGF0YTogSlNPTi5wYXJzZShkYXRhWzBdLnN0cnVjdHVyZWRfZGF0YSB8fCAnW1tdXScpLFxyXG4gICAgICBzaXplOiBmb3JtYXRGaWxlU2l6ZShkYXRhWzBdLmZpbGVfc2l6ZSksXHJcbiAgICAgIHVwbG9hZERhdGU6IG5ldyBEYXRlKGRhdGFbMF0uY3JlYXRlZF9hdCksXHJcbiAgICAgIHVybDogZGF0YVswXS5wdWJsaWNfdXJsXHJcbiAgICB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdVcGxvYWQgc3ByZWFkc2hlZXQgZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHJpZXZlcyBhbGwgZmlsZXMgZnJvbSBTdXBhYmFzZVxyXG4gKi9cclxuY29uc3QgZ2V0RmlsZXMgPSBhc3luYyAoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdkb2N1bWVudHMnKVxyXG4gICAgICAuc2VsZWN0KCcqJylcclxuICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xyXG5cclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcblxyXG4gICAgcmV0dXJuIGRhdGEubWFwKGZpbGUgPT4ge1xyXG4gICAgICBpZiAoZmlsZS5maWxlX3R5cGUuaW5jbHVkZXMoJ3NwcmVhZHNoZWV0JykpIHtcclxuICAgICAgICAvLyBSZXR1cm4gYXMgU3ByZWFkc2hlZXQgdHlwZVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBpZDogZmlsZS5pZCxcclxuICAgICAgICAgIG5hbWU6IGZpbGUudGl0bGUgfHwgZmlsZS5uYW1lLFxyXG4gICAgICAgICAgdHlwZTogJ3NwcmVhZHNoZWV0JyxcclxuICAgICAgICAgIGRhdGE6IGZpbGUuc3RydWN0dXJlZF9kYXRhID8gSlNPTi5wYXJzZShmaWxlLnN0cnVjdHVyZWRfZGF0YSkgOiBbW11dLFxyXG4gICAgICAgICAgc2l6ZTogZm9ybWF0RmlsZVNpemUoZmlsZS5maWxlX3NpemUgfHwgMCksXHJcbiAgICAgICAgICB1cGxvYWREYXRlOiBuZXcgRGF0ZShmaWxlLmNyZWF0ZWRfYXQpLFxyXG4gICAgICAgICAgdXJsOiBmaWxlLnB1YmxpY191cmxcclxuICAgICAgICB9O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFJldHVybiBhcyBEb2N1bWVudCB0eXBlXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGlkOiBmaWxlLmlkLFxyXG4gICAgICAgICAgbmFtZTogZmlsZS50aXRsZSB8fCBmaWxlLm5hbWUsXHJcbiAgICAgICAgICB0eXBlOiAnZG9jdW1lbnQnLFxyXG4gICAgICAgICAgY29udGVudDogZmlsZS5jb250ZW50IHx8ICcnLFxyXG4gICAgICAgICAgc2l6ZTogZm9ybWF0RmlsZVNpemUoZmlsZS5maWxlX3NpemUgfHwgMCksXHJcbiAgICAgICAgICB1cGxvYWREYXRlOiBuZXcgRGF0ZShmaWxlLmNyZWF0ZWRfYXQpLFxyXG4gICAgICAgICAgdXJsOiBmaWxlLnB1YmxpY191cmxcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBmZXRjaCBmaWxlcyBmcm9tIFN1cGFiYXNlOicsIGUpO1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZWxldGVzIGEgZmlsZSBieSBJRFxyXG4gKi9cclxuY29uc3QgZGVsZXRlRmlsZSA9IGFzeW5jIChpZCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBGaXJzdCBnZXQgdGhlIGZpbGUgaW5mbyB0byBnZXQgdGhlIHN0b3JhZ2UgcGF0aFxyXG4gICAgY29uc3QgeyBkYXRhOiBmaWxlIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnZG9jdW1lbnRzJylcclxuICAgICAgLnNlbGVjdCgnZmlsZV9wYXRoLCBmaWxlX3R5cGUnKVxyXG4gICAgICAuZXEoJ2lkJywgaWQpXHJcbiAgICAgIC5zaW5nbGUoKTtcclxuXHJcbiAgICBpZiAoZmlsZSkge1xyXG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIHN0b3JhZ2UgYnVja2V0IGJhc2VkIG9uIGZpbGUgdHlwZVxyXG4gICAgICBjb25zdCBidWNrZXQgPSBmaWxlLmZpbGVfdHlwZS5pbmNsdWRlcygnc3ByZWFkc2hlZXQnKSA/ICdzcHJlYWRzaGVldHMnIDogJ2RvY3VtZW50cyc7XHJcbiAgICAgIFxyXG4gICAgICAvLyBEZWxldGUgZnJvbSBzdG9yYWdlXHJcbiAgICAgIGNvbnN0IHsgZXJyb3I6IHN0b3JhZ2VFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Uuc3RvcmFnZVxyXG4gICAgICAgIC5mcm9tKGJ1Y2tldClcclxuICAgICAgICAucmVtb3ZlKFtmaWxlLmZpbGVfcGF0aF0pO1xyXG5cclxuICAgICAgaWYgKHN0b3JhZ2VFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N0b3JhZ2UgZGVsZXRlIGVycm9yOicsIHN0b3JhZ2VFcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBEZWxldGUgZnJvbSBkYXRhYmFzZVxyXG4gICAgY29uc3QgeyBlcnJvcjogZGJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ2RvY3VtZW50cycpXHJcbiAgICAgIC5kZWxldGUoKVxyXG4gICAgICAuZXEoJ2lkJywgaWQpO1xyXG5cclxuICAgIGlmIChkYkVycm9yKSB0aHJvdyBkYkVycm9yO1xyXG4gICAgXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgZmlsZTonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZmlsZXNTZXJ2aWNlID0ge1xyXG4gIHVwbG9hZERvY3VtZW50LFxyXG4gIHVwbG9hZFNwcmVhZHNoZWV0LFxyXG4gIGdldEZpbGVzLFxyXG4gIGRlbGV0ZUZpbGUsXHJcbiAgZXh0cmFjdFRleHRGcm9tUERGLFxyXG4gIGV4dHJhY3RUZXh0RnJvbUV4Y2VsXHJcbn07ICJdLCJuYW1lcyI6WyJzdXBhYmFzZSIsImZvcm1hdEZpbGVTaXplIiwiYnl0ZXMiLCJ0b0ZpeGVkIiwiZXh0cmFjdFRleHRGcm9tUERGIiwiZmlsZSIsImFycmF5QnVmZmVyIiwidGV4dERlY29kZXIiLCJUZXh0RGVjb2RlciIsInJhd1RleHQiLCJkZWNvZGUiLCJjbGVhbmVkVGV4dCIsInJlcGxhY2UiLCJjb25zb2xlIiwibG9nIiwibGVuZ3RoIiwiZXJyb3IiLCJleHRyYWN0VGV4dEZyb21FeGNlbCIsIm5hbWUiLCJ1cGxvYWREb2N1bWVudCIsInR5cGUiLCJzaXplIiwidGV4dENvbnRlbnQiLCJmaWxlTmFtZSIsIkRhdGUiLCJub3ciLCJ1cGxvYWRFcnJvciIsImRhdGEiLCJzdG9yYWdlRGF0YSIsInN0b3JhZ2UiLCJmcm9tIiwidXBsb2FkIiwiY2FjaGVDb250cm9sIiwidXBzZXJ0IiwiSlNPTiIsInN0cmluZ2lmeSIsIkVycm9yIiwicHVibGljVXJsIiwiZ2V0UHVibGljVXJsIiwiaW5zZXJ0IiwidGl0bGUiLCJmaWxlX3BhdGgiLCJmaWxlX3R5cGUiLCJmaWxlX3NpemUiLCJjb250ZW50IiwicHVibGljX3VybCIsInNlbGVjdCIsImlkIiwidXBsb2FkRGF0ZSIsImNyZWF0ZWRfYXQiLCJ1cmwiLCJ1cGxvYWRTcHJlYWRzaGVldCIsInN0cnVjdHVyZWREYXRhIiwiZW5kc1dpdGgiLCJpbmNsdWRlcyIsInN0cnVjdHVyZWRfZGF0YSIsInBhcnNlIiwiZ2V0RmlsZXMiLCJvcmRlciIsImFzY2VuZGluZyIsIm1hcCIsImUiLCJ3YXJuIiwiZGVsZXRlRmlsZSIsImVxIiwic2luZ2xlIiwiYnVja2V0Iiwic3RvcmFnZUVycm9yIiwicmVtb3ZlIiwiZGJFcnJvciIsImRlbGV0ZSIsImZpbGVzU2VydmljZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/services/filesService.js\n"));

/***/ })

});