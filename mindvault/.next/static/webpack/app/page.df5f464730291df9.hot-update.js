"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/services/filesService.js":
/*!**************************************!*\
  !*** ./app/services/filesService.js ***!
  \**************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   filesService: () => (/* binding */ filesService)\n/* harmony export */ });\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/supabase */ \"(app-pages-browser)/./app/lib/supabase.js\");\n/**\r\n * Service for handling file operations with Supabase\r\n */ \n/**\r\n * Formats file size in a human-readable format\r\n */ const formatFileSize = (bytes)=>{\n    if (bytes < 1024) return bytes + ' bytes';\n    else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';\n    else return (bytes / 1048576).toFixed(1) + ' MB';\n};\n/**\r\n * Extract text from PDF file\r\n */ const extractTextFromPDF = async (file)=>{\n    try {\n        const arrayBuffer = await file.arrayBuffer();\n        // Here, we'll just read the file as text for simplicity\n        // In a real app, you would use a PDF parsing library like pdf.js\n        const textDecoder = new TextDecoder('utf-8');\n        try {\n            // Get the raw text from the PDF\n            const rawText = textDecoder.decode(arrayBuffer);\n            // Clean the text by removing null bytes and other control characters\n            // This prevents PostgreSQL from rejecting the content\n            const cleanedText = rawText.replace(/\\u0000/g, '') // Remove null bytes\n            .replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g, ''); // Remove other control characters\n            console.log(\"PDF processed, removed \".concat(rawText.length - cleanedText.length, \" invalid characters\"));\n            return cleanedText;\n        } catch (error) {\n            console.error('Error decoding PDF text:', error);\n            return 'Unable to extract text from PDF';\n        }\n    } catch (error) {\n        console.error('Error reading PDF:', error);\n        return '';\n    }\n};\n/**\r\n * Extract data from Excel file\r\n */ const extractTextFromExcel = async (file)=>{\n    try {\n        // In a real app, you would use a library like xlsx or exceljs\n        // For now, we'll just return a placeholder\n        return \"Extracted text from Excel file: \".concat(file.name);\n    } catch (error) {\n        console.error('Error reading Excel file:', error);\n        return '';\n    }\n};\n/**\r\n * Uploads a document to Supabase storage and database\r\n */ const uploadDocument = async (file)=>{\n    try {\n        console.log(\"Processing document: \".concat(file.name, \", type: \").concat(file.type, \", size: \").concat(file.size, \" bytes\"));\n        // Extract text content from PDF\n        let textContent = '';\n        if (file.type === 'application/pdf') {\n            console.log('Processing as PDF...');\n            try {\n                textContent = await extractTextFromPDF(file);\n                console.log(\"PDF processing complete, extracted \".concat(textContent.length, \" characters\"));\n                // Limit the text content size to prevent database issues\n                // PostgreSQL has a limit on text column size\n                if (textContent.length > 1000000) {\n                    console.log(\"Text content too large (\".concat(textContent.length, \" chars), truncating...\"));\n                    textContent = textContent.substring(0, 1000000) + '... [content truncated]';\n                }\n            } catch (pdfError) {\n                console.error('PDF extraction error:', pdfError);\n                textContent = 'Error extracting PDF content';\n            }\n        } else {\n            console.log(\"Unsupported document type: \".concat(file.type, \", no text extraction performed\"));\n        }\n        // Upload file to Supabase Storage\n        const fileName = \"\".concat(Date.now(), \"-\").concat(file.name);\n        console.log(\"Uploading file to Supabase storage bucket 'documents' with name: \".concat(fileName));\n        const { error: uploadError, data: storageData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.storage.from('documents').upload(fileName, file, {\n            cacheControl: '3600',\n            upsert: false\n        });\n        if (uploadError) {\n            console.error('Storage upload error:', JSON.stringify(uploadError));\n            throw new Error(\"Storage upload error: \".concat(JSON.stringify(uploadError)));\n        }\n        console.log('File successfully uploaded to storage, getting public URL');\n        // Get the public URL\n        const { data: { publicUrl } } = _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.storage.from('documents').getPublicUrl(fileName);\n        console.log(\"Public URL generated: \".concat(publicUrl));\n        // Create database record\n        console.log('Creating database record for the uploaded file');\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('documents').insert([\n            {\n                title: file.name,\n                file_path: fileName,\n                file_type: file.type,\n                file_size: file.size,\n                content: textContent,\n                public_url: publicUrl\n            }\n        ]).select();\n        if (error) {\n            console.error('Database insert error:', JSON.stringify(error));\n            throw new Error(\"Database insert error: \".concat(JSON.stringify(error)));\n        }\n        console.log('Document successfully uploaded and recorded in database');\n        // Return formatted document\n        return {\n            id: data[0].id,\n            name: data[0].title,\n            type: 'document',\n            content: data[0].content,\n            size: formatFileSize(data[0].file_size),\n            uploadDate: new Date(data[0].created_at),\n            url: data[0].public_url\n        };\n    } catch (error) {\n        console.error('Upload document error:', error);\n        throw error;\n    }\n};\n/**\r\n * Uploads a spreadsheet to Supabase storage and database\r\n */ const uploadSpreadsheet = async (file)=>{\n    try {\n        console.log(\"Processing spreadsheet: \".concat(file.name, \", type: \").concat(file.type, \", size: \").concat(file.size, \" bytes\"));\n        // Extract content from Excel\n        let textContent = '';\n        let structuredData = null;\n        if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls') || file.type.includes('excel')) {\n            console.log('Processing as Excel...');\n            try {\n                textContent = await extractTextFromExcel(file);\n                // In a real app, you would parse the Excel data into structured JSON\n                structuredData = JSON.stringify([\n                    [\n                        'Header 1',\n                        'Header 2'\n                    ],\n                    [\n                        'Data 1',\n                        'Data 2'\n                    ]\n                ]);\n                console.log(\"Excel processing complete, extracted \".concat(textContent.length, \" characters\"));\n                // Limit the text content size\n                if (textContent.length > 1000000) {\n                    console.log(\"Text content too large (\".concat(textContent.length, \" chars), truncating...\"));\n                    textContent = textContent.substring(0, 1000000) + '... [content truncated]';\n                }\n            } catch (excelError) {\n                console.error('Excel extraction error:', excelError);\n                textContent = 'Error extracting Excel content';\n                structuredData = JSON.stringify([\n                    [\n                        'Error'\n                    ],\n                    [\n                        'Failed to extract data'\n                    ]\n                ]);\n            }\n        } else {\n            console.log(\"Unsupported spreadsheet type: \".concat(file.type, \", no text extraction performed\"));\n            structuredData = JSON.stringify([\n                [\n                    'No Data'\n                ],\n                [\n                    'Unsupported file format'\n                ]\n            ]);\n        }\n        // Upload file to Supabase Storage\n        const fileName = \"\".concat(Date.now(), \"-\").concat(file.name);\n        console.log(\"Uploading file to Supabase storage bucket 'spreadsheets' with name: \".concat(fileName));\n        const { error: uploadError, data: storageData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.storage.from('spreadsheets').upload(fileName, file, {\n            cacheControl: '3600',\n            upsert: false\n        });\n        if (uploadError) {\n            console.error('Storage upload error:', JSON.stringify(uploadError));\n            throw new Error(\"Storage upload error: \".concat(JSON.stringify(uploadError)));\n        }\n        console.log('File successfully uploaded to storage, getting public URL');\n        // Get the public URL\n        const { data: { publicUrl } } = _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.storage.from('spreadsheets').getPublicUrl(fileName);\n        console.log(\"Public URL generated: \".concat(publicUrl));\n        // Create database record\n        console.log('Creating database record for the uploaded file');\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('documents').insert([\n            {\n                title: file.name,\n                file_path: fileName,\n                file_type: \"spreadsheet/\".concat(file.type),\n                file_size: file.size,\n                content: textContent,\n                structured_data: structuredData,\n                public_url: publicUrl\n            }\n        ]).select();\n        if (error) {\n            console.error('Database insert error:', JSON.stringify(error));\n            throw new Error(\"Database insert error: \".concat(JSON.stringify(error)));\n        }\n        console.log('Spreadsheet successfully uploaded and recorded in database');\n        // Return formatted spreadsheet\n        return {\n            id: data[0].id,\n            name: data[0].title,\n            type: 'spreadsheet',\n            data: JSON.parse(data[0].structured_data || '[[]]'),\n            size: formatFileSize(data[0].file_size),\n            uploadDate: new Date(data[0].created_at),\n            url: data[0].public_url\n        };\n    } catch (error) {\n        console.error('Upload spreadsheet error:', error);\n        throw error;\n    }\n};\n/**\r\n * Retrieves all files from Supabase\r\n */ const getFiles = async ()=>{\n    try {\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('documents').select('*').order('created_at', {\n            ascending: false\n        });\n        if (error) throw error;\n        return data.map((file)=>{\n            if (file.file_type.includes('spreadsheet')) {\n                // Return as Spreadsheet type\n                return {\n                    id: file.id,\n                    name: file.title || file.name,\n                    type: 'spreadsheet',\n                    data: file.structured_data ? JSON.parse(file.structured_data) : [\n                        []\n                    ],\n                    size: formatFileSize(file.file_size || 0),\n                    uploadDate: new Date(file.created_at),\n                    url: file.public_url\n                };\n            } else {\n                // Return as Document type\n                return {\n                    id: file.id,\n                    name: file.title || file.name,\n                    type: 'document',\n                    content: file.content || '',\n                    size: formatFileSize(file.file_size || 0),\n                    uploadDate: new Date(file.created_at),\n                    url: file.public_url\n                };\n            }\n        });\n    } catch (e) {\n        console.warn('Could not fetch files from Supabase:', e);\n        return [];\n    }\n};\n/**\r\n * Deletes a file by ID\r\n */ const deleteFile = async (id)=>{\n    try {\n        // First get the file info to get the storage path\n        const { data: file } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('documents').select('file_path, file_type').eq('id', id).single();\n        if (file) {\n            // Determine the storage bucket based on file type\n            const bucket = file.file_type.includes('spreadsheet') ? 'spreadsheets' : 'documents';\n            // Delete from storage\n            const { error: storageError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.storage.from(bucket).remove([\n                file.file_path\n            ]);\n            if (storageError) {\n                console.error('Storage delete error:', storageError);\n            }\n        }\n        // Delete from database\n        const { error: dbError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('documents').delete().eq('id', id);\n        if (dbError) throw dbError;\n        return true;\n    } catch (error) {\n        console.error('Error deleting file:', error);\n        throw error;\n    }\n};\nconst filesService = {\n    uploadDocument,\n    uploadSpreadsheet,\n    getFiles,\n    deleteFile,\n    extractTextFromPDF,\n    extractTextFromExcel\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zZXJ2aWNlcy9maWxlc1NlcnZpY2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Q0FFQyxHQUMwQztBQUUzQzs7Q0FFQyxHQUNELE1BQU1DLGlCQUFpQixDQUFDQztJQUN0QixJQUFJQSxRQUFRLE1BQU0sT0FBT0EsUUFBUTtTQUM1QixJQUFJQSxRQUFRLFNBQVMsT0FBTyxDQUFDQSxRQUFRLElBQUcsRUFBR0MsT0FBTyxDQUFDLEtBQUs7U0FDeEQsT0FBTyxDQUFDRCxRQUFRLE9BQU0sRUFBR0MsT0FBTyxDQUFDLEtBQUs7QUFDN0M7QUFFQTs7Q0FFQyxHQUNELE1BQU1DLHFCQUFxQixPQUFPQztJQUNoQyxJQUFJO1FBQ0YsTUFBTUMsY0FBYyxNQUFNRCxLQUFLQyxXQUFXO1FBRTFDLHdEQUF3RDtRQUN4RCxpRUFBaUU7UUFDakUsTUFBTUMsY0FBYyxJQUFJQyxZQUFZO1FBQ3BDLElBQUk7WUFDRixnQ0FBZ0M7WUFDaEMsTUFBTUMsVUFBVUYsWUFBWUcsTUFBTSxDQUFDSjtZQUVuQyxxRUFBcUU7WUFDckUsc0RBQXNEO1lBQ3RELE1BQU1LLGNBQWNGLFFBQ2pCRyxPQUFPLENBQUMsV0FBVyxJQUFJLG9CQUFvQjthQUMzQ0EsT0FBTyxDQUFDLHFDQUFxQyxLQUFLLGtDQUFrQztZQUV2RkMsUUFBUUMsR0FBRyxDQUFDLDBCQUE4RCxPQUFwQ0wsUUFBUU0sTUFBTSxHQUFHSixZQUFZSSxNQUFNLEVBQUM7WUFFMUUsT0FBT0o7UUFDVCxFQUFFLE9BQU9LLE9BQU87WUFDZEgsUUFBUUcsS0FBSyxDQUFDLDRCQUE0QkE7WUFDMUMsT0FBTztRQUNUO0lBQ0YsRUFBRSxPQUFPQSxPQUFPO1FBQ2RILFFBQVFHLEtBQUssQ0FBQyxzQkFBc0JBO1FBQ3BDLE9BQU87SUFDVDtBQUNGO0FBRUE7O0NBRUMsR0FDRCxNQUFNQyx1QkFBdUIsT0FBT1o7SUFDbEMsSUFBSTtRQUNGLDhEQUE4RDtRQUM5RCwyQ0FBMkM7UUFDM0MsT0FBTyxtQ0FBNkMsT0FBVkEsS0FBS2EsSUFBSTtJQUNyRCxFQUFFLE9BQU9GLE9BQU87UUFDZEgsUUFBUUcsS0FBSyxDQUFDLDZCQUE2QkE7UUFDM0MsT0FBTztJQUNUO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNELE1BQU1HLGlCQUFpQixPQUFPZDtJQUM1QixJQUFJO1FBQ0ZRLFFBQVFDLEdBQUcsQ0FBQyx3QkFBNENULE9BQXBCQSxLQUFLYSxJQUFJLEVBQUMsWUFBOEJiLE9BQXBCQSxLQUFLZSxJQUFJLEVBQUMsWUFBb0IsT0FBVmYsS0FBS2dCLElBQUksRUFBQztRQUV0RixnQ0FBZ0M7UUFDaEMsSUFBSUMsY0FBYztRQUNsQixJQUFJakIsS0FBS2UsSUFBSSxLQUFLLG1CQUFtQjtZQUNuQ1AsUUFBUUMsR0FBRyxDQUFDO1lBQ1osSUFBSTtnQkFDRlEsY0FBYyxNQUFNbEIsbUJBQW1CQztnQkFDdkNRLFFBQVFDLEdBQUcsQ0FBQyxzQ0FBeUQsT0FBbkJRLFlBQVlQLE1BQU0sRUFBQztnQkFFckUseURBQXlEO2dCQUN6RCw2Q0FBNkM7Z0JBQzdDLElBQUlPLFlBQVlQLE1BQU0sR0FBRyxTQUFTO29CQUNoQ0YsUUFBUUMsR0FBRyxDQUFDLDJCQUE4QyxPQUFuQlEsWUFBWVAsTUFBTSxFQUFDO29CQUMxRE8sY0FBY0EsWUFBWUMsU0FBUyxDQUFDLEdBQUcsV0FBVztnQkFDcEQ7WUFDRixFQUFFLE9BQU9DLFVBQVU7Z0JBQ2pCWCxRQUFRRyxLQUFLLENBQUMseUJBQXlCUTtnQkFDdkNGLGNBQWM7WUFDaEI7UUFDRixPQUFPO1lBQ0xULFFBQVFDLEdBQUcsQ0FBQyw4QkFBd0MsT0FBVlQsS0FBS2UsSUFBSSxFQUFDO1FBQ3REO1FBRUEsa0NBQWtDO1FBQ2xDLE1BQU1LLFdBQVcsR0FBaUJwQixPQUFkcUIsS0FBS0MsR0FBRyxJQUFHLEtBQWEsT0FBVnRCLEtBQUthLElBQUk7UUFDM0NMLFFBQVFDLEdBQUcsQ0FBQyxvRUFBNkUsT0FBVFc7UUFDaEYsTUFBTSxFQUFFVCxPQUFPWSxXQUFXLEVBQUVDLE1BQU1DLFdBQVcsRUFBRSxHQUFHLE1BQU05QixtREFBUUEsQ0FBQytCLE9BQU8sQ0FDckVDLElBQUksQ0FBQyxhQUNMQyxNQUFNLENBQUNSLFVBQVVwQixNQUFNO1lBQ3RCNkIsY0FBYztZQUNkQyxRQUFRO1FBQ1Y7UUFFRixJQUFJUCxhQUFhO1lBQ2ZmLFFBQVFHLEtBQUssQ0FBQyx5QkFBeUJvQixLQUFLQyxTQUFTLENBQUNUO1lBQ3RELE1BQU0sSUFBSVUsTUFBTSx5QkFBcUQsT0FBNUJGLEtBQUtDLFNBQVMsQ0FBQ1Q7UUFDMUQ7UUFFQWYsUUFBUUMsR0FBRyxDQUFDO1FBQ1oscUJBQXFCO1FBQ3JCLE1BQU0sRUFBRWUsTUFBTSxFQUFFVSxTQUFTLEVBQUUsRUFBRSxHQUFHdkMsbURBQVFBLENBQUMrQixPQUFPLENBQzdDQyxJQUFJLENBQUMsYUFDTFEsWUFBWSxDQUFDZjtRQUVoQlosUUFBUUMsR0FBRyxDQUFDLHlCQUFtQyxPQUFWeUI7UUFFckMseUJBQXlCO1FBQ3pCMUIsUUFBUUMsR0FBRyxDQUFDO1FBQ1osTUFBTSxFQUFFZSxJQUFJLEVBQUViLEtBQUssRUFBRSxHQUFHLE1BQU1oQixtREFBUUEsQ0FDbkNnQyxJQUFJLENBQUMsYUFDTFMsTUFBTSxDQUFDO1lBQ047Z0JBQ0VDLE9BQU9yQyxLQUFLYSxJQUFJO2dCQUNoQnlCLFdBQVdsQjtnQkFDWG1CLFdBQVd2QyxLQUFLZSxJQUFJO2dCQUNwQnlCLFdBQVd4QyxLQUFLZ0IsSUFBSTtnQkFDcEJ5QixTQUFTeEI7Z0JBQ1R5QixZQUFZUjtZQUNkO1NBQ0QsRUFDQVMsTUFBTTtRQUVULElBQUloQyxPQUFPO1lBQ1RILFFBQVFHLEtBQUssQ0FBQywwQkFBMEJvQixLQUFLQyxTQUFTLENBQUNyQjtZQUN2RCxNQUFNLElBQUlzQixNQUFNLDBCQUFnRCxPQUF0QkYsS0FBS0MsU0FBUyxDQUFDckI7UUFDM0Q7UUFFQUgsUUFBUUMsR0FBRyxDQUFDO1FBQ1osNEJBQTRCO1FBQzVCLE9BQU87WUFDTG1DLElBQUlwQixJQUFJLENBQUMsRUFBRSxDQUFDb0IsRUFBRTtZQUNkL0IsTUFBTVcsSUFBSSxDQUFDLEVBQUUsQ0FBQ2EsS0FBSztZQUNuQnRCLE1BQU07WUFDTjBCLFNBQVNqQixJQUFJLENBQUMsRUFBRSxDQUFDaUIsT0FBTztZQUN4QnpCLE1BQU1wQixlQUFlNEIsSUFBSSxDQUFDLEVBQUUsQ0FBQ2dCLFNBQVM7WUFDdENLLFlBQVksSUFBSXhCLEtBQUtHLElBQUksQ0FBQyxFQUFFLENBQUNzQixVQUFVO1lBQ3ZDQyxLQUFLdkIsSUFBSSxDQUFDLEVBQUUsQ0FBQ2tCLFVBQVU7UUFDekI7SUFDRixFQUFFLE9BQU8vQixPQUFPO1FBQ2RILFFBQVFHLEtBQUssQ0FBQywwQkFBMEJBO1FBQ3hDLE1BQU1BO0lBQ1I7QUFDRjtBQUVBOztDQUVDLEdBQ0QsTUFBTXFDLG9CQUFvQixPQUFPaEQ7SUFDL0IsSUFBSTtRQUNGUSxRQUFRQyxHQUFHLENBQUMsMkJBQStDVCxPQUFwQkEsS0FBS2EsSUFBSSxFQUFDLFlBQThCYixPQUFwQkEsS0FBS2UsSUFBSSxFQUFDLFlBQW9CLE9BQVZmLEtBQUtnQixJQUFJLEVBQUM7UUFFekYsNkJBQTZCO1FBQzdCLElBQUlDLGNBQWM7UUFDbEIsSUFBSWdDLGlCQUFpQjtRQUVyQixJQUFJakQsS0FBS2EsSUFBSSxDQUFDcUMsUUFBUSxDQUFDLFlBQVlsRCxLQUFLYSxJQUFJLENBQUNxQyxRQUFRLENBQUMsV0FBV2xELEtBQUtlLElBQUksQ0FBQ29DLFFBQVEsQ0FBQyxVQUFVO1lBQzVGM0MsUUFBUUMsR0FBRyxDQUFDO1lBQ1osSUFBSTtnQkFDRlEsY0FBYyxNQUFNTCxxQkFBcUJaO2dCQUN6QyxxRUFBcUU7Z0JBQ3JFaUQsaUJBQWlCbEIsS0FBS0MsU0FBUyxDQUFDO29CQUFDO3dCQUFDO3dCQUFZO3FCQUFXO29CQUFFO3dCQUFDO3dCQUFVO3FCQUFTO2lCQUFDO2dCQUNoRnhCLFFBQVFDLEdBQUcsQ0FBQyx3Q0FBMkQsT0FBbkJRLFlBQVlQLE1BQU0sRUFBQztnQkFFdkUsOEJBQThCO2dCQUM5QixJQUFJTyxZQUFZUCxNQUFNLEdBQUcsU0FBUztvQkFDaENGLFFBQVFDLEdBQUcsQ0FBQywyQkFBOEMsT0FBbkJRLFlBQVlQLE1BQU0sRUFBQztvQkFDMURPLGNBQWNBLFlBQVlDLFNBQVMsQ0FBQyxHQUFHLFdBQVc7Z0JBQ3BEO1lBQ0YsRUFBRSxPQUFPa0MsWUFBWTtnQkFDbkI1QyxRQUFRRyxLQUFLLENBQUMsMkJBQTJCeUM7Z0JBQ3pDbkMsY0FBYztnQkFDZGdDLGlCQUFpQmxCLEtBQUtDLFNBQVMsQ0FBQztvQkFBQzt3QkFBQztxQkFBUTtvQkFBRTt3QkFBQztxQkFBeUI7aUJBQUM7WUFDekU7UUFDRixPQUFPO1lBQ0x4QixRQUFRQyxHQUFHLENBQUMsaUNBQTJDLE9BQVZULEtBQUtlLElBQUksRUFBQztZQUN2RGtDLGlCQUFpQmxCLEtBQUtDLFNBQVMsQ0FBQztnQkFBQztvQkFBQztpQkFBVTtnQkFBRTtvQkFBQztpQkFBMEI7YUFBQztRQUM1RTtRQUVBLGtDQUFrQztRQUNsQyxNQUFNWixXQUFXLEdBQWlCcEIsT0FBZHFCLEtBQUtDLEdBQUcsSUFBRyxLQUFhLE9BQVZ0QixLQUFLYSxJQUFJO1FBQzNDTCxRQUFRQyxHQUFHLENBQUMsdUVBQWdGLE9BQVRXO1FBQ25GLE1BQU0sRUFBRVQsT0FBT1ksV0FBVyxFQUFFQyxNQUFNQyxXQUFXLEVBQUUsR0FBRyxNQUFNOUIsbURBQVFBLENBQUMrQixPQUFPLENBQ3JFQyxJQUFJLENBQUMsZ0JBQ0xDLE1BQU0sQ0FBQ1IsVUFBVXBCLE1BQU07WUFDdEI2QixjQUFjO1lBQ2RDLFFBQVE7UUFDVjtRQUVGLElBQUlQLGFBQWE7WUFDZmYsUUFBUUcsS0FBSyxDQUFDLHlCQUF5Qm9CLEtBQUtDLFNBQVMsQ0FBQ1Q7WUFDdEQsTUFBTSxJQUFJVSxNQUFNLHlCQUFxRCxPQUE1QkYsS0FBS0MsU0FBUyxDQUFDVDtRQUMxRDtRQUVBZixRQUFRQyxHQUFHLENBQUM7UUFDWixxQkFBcUI7UUFDckIsTUFBTSxFQUFFZSxNQUFNLEVBQUVVLFNBQVMsRUFBRSxFQUFFLEdBQUd2QyxtREFBUUEsQ0FBQytCLE9BQU8sQ0FDN0NDLElBQUksQ0FBQyxnQkFDTFEsWUFBWSxDQUFDZjtRQUVoQlosUUFBUUMsR0FBRyxDQUFDLHlCQUFtQyxPQUFWeUI7UUFFckMseUJBQXlCO1FBQ3pCMUIsUUFBUUMsR0FBRyxDQUFDO1FBQ1osTUFBTSxFQUFFZSxJQUFJLEVBQUViLEtBQUssRUFBRSxHQUFHLE1BQU1oQixtREFBUUEsQ0FDbkNnQyxJQUFJLENBQUMsYUFDTFMsTUFBTSxDQUFDO1lBQ047Z0JBQ0VDLE9BQU9yQyxLQUFLYSxJQUFJO2dCQUNoQnlCLFdBQVdsQjtnQkFDWG1CLFdBQVcsZUFBeUIsT0FBVnZDLEtBQUtlLElBQUk7Z0JBQ25DeUIsV0FBV3hDLEtBQUtnQixJQUFJO2dCQUNwQnlCLFNBQVN4QjtnQkFDVG9DLGlCQUFpQko7Z0JBQ2pCUCxZQUFZUjtZQUNkO1NBQ0QsRUFDQVMsTUFBTTtRQUVULElBQUloQyxPQUFPO1lBQ1RILFFBQVFHLEtBQUssQ0FBQywwQkFBMEJvQixLQUFLQyxTQUFTLENBQUNyQjtZQUN2RCxNQUFNLElBQUlzQixNQUFNLDBCQUFnRCxPQUF0QkYsS0FBS0MsU0FBUyxDQUFDckI7UUFDM0Q7UUFFQUgsUUFBUUMsR0FBRyxDQUFDO1FBQ1osK0JBQStCO1FBQy9CLE9BQU87WUFDTG1DLElBQUlwQixJQUFJLENBQUMsRUFBRSxDQUFDb0IsRUFBRTtZQUNkL0IsTUFBTVcsSUFBSSxDQUFDLEVBQUUsQ0FBQ2EsS0FBSztZQUNuQnRCLE1BQU07WUFDTlMsTUFBTU8sS0FBS3VCLEtBQUssQ0FBQzlCLElBQUksQ0FBQyxFQUFFLENBQUM2QixlQUFlLElBQUk7WUFDNUNyQyxNQUFNcEIsZUFBZTRCLElBQUksQ0FBQyxFQUFFLENBQUNnQixTQUFTO1lBQ3RDSyxZQUFZLElBQUl4QixLQUFLRyxJQUFJLENBQUMsRUFBRSxDQUFDc0IsVUFBVTtZQUN2Q0MsS0FBS3ZCLElBQUksQ0FBQyxFQUFFLENBQUNrQixVQUFVO1FBQ3pCO0lBQ0YsRUFBRSxPQUFPL0IsT0FBTztRQUNkSCxRQUFRRyxLQUFLLENBQUMsNkJBQTZCQTtRQUMzQyxNQUFNQTtJQUNSO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNELE1BQU00QyxXQUFXO0lBQ2YsSUFBSTtRQUNGLE1BQU0sRUFBRS9CLElBQUksRUFBRWIsS0FBSyxFQUFFLEdBQUcsTUFBTWhCLG1EQUFRQSxDQUNuQ2dDLElBQUksQ0FBQyxhQUNMZ0IsTUFBTSxDQUFDLEtBQ1BhLEtBQUssQ0FBQyxjQUFjO1lBQUVDLFdBQVc7UUFBTTtRQUUxQyxJQUFJOUMsT0FBTyxNQUFNQTtRQUVqQixPQUFPYSxLQUFLa0MsR0FBRyxDQUFDMUQsQ0FBQUE7WUFDZCxJQUFJQSxLQUFLdUMsU0FBUyxDQUFDWSxRQUFRLENBQUMsZ0JBQWdCO2dCQUMxQyw2QkFBNkI7Z0JBQzdCLE9BQU87b0JBQ0xQLElBQUk1QyxLQUFLNEMsRUFBRTtvQkFDWC9CLE1BQU1iLEtBQUtxQyxLQUFLLElBQUlyQyxLQUFLYSxJQUFJO29CQUM3QkUsTUFBTTtvQkFDTlMsTUFBTXhCLEtBQUtxRCxlQUFlLEdBQUd0QixLQUFLdUIsS0FBSyxDQUFDdEQsS0FBS3FELGVBQWUsSUFBSTt3QkFBQyxFQUFFO3FCQUFDO29CQUNwRXJDLE1BQU1wQixlQUFlSSxLQUFLd0MsU0FBUyxJQUFJO29CQUN2Q0ssWUFBWSxJQUFJeEIsS0FBS3JCLEtBQUs4QyxVQUFVO29CQUNwQ0MsS0FBSy9DLEtBQUswQyxVQUFVO2dCQUN0QjtZQUNGLE9BQU87Z0JBQ0wsMEJBQTBCO2dCQUMxQixPQUFPO29CQUNMRSxJQUFJNUMsS0FBSzRDLEVBQUU7b0JBQ1gvQixNQUFNYixLQUFLcUMsS0FBSyxJQUFJckMsS0FBS2EsSUFBSTtvQkFDN0JFLE1BQU07b0JBQ04wQixTQUFTekMsS0FBS3lDLE9BQU8sSUFBSTtvQkFDekJ6QixNQUFNcEIsZUFBZUksS0FBS3dDLFNBQVMsSUFBSTtvQkFDdkNLLFlBQVksSUFBSXhCLEtBQUtyQixLQUFLOEMsVUFBVTtvQkFDcENDLEtBQUsvQyxLQUFLMEMsVUFBVTtnQkFDdEI7WUFDRjtRQUNGO0lBQ0YsRUFBRSxPQUFPaUIsR0FBRztRQUNWbkQsUUFBUW9ELElBQUksQ0FBQyx3Q0FBd0NEO1FBQ3JELE9BQU8sRUFBRTtJQUNYO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNELE1BQU1FLGFBQWEsT0FBT2pCO0lBQ3hCLElBQUk7UUFDRixrREFBa0Q7UUFDbEQsTUFBTSxFQUFFcEIsTUFBTXhCLElBQUksRUFBRSxHQUFHLE1BQU1MLG1EQUFRQSxDQUNsQ2dDLElBQUksQ0FBQyxhQUNMZ0IsTUFBTSxDQUFDLHdCQUNQbUIsRUFBRSxDQUFDLE1BQU1sQixJQUNUbUIsTUFBTTtRQUVULElBQUkvRCxNQUFNO1lBQ1Isa0RBQWtEO1lBQ2xELE1BQU1nRSxTQUFTaEUsS0FBS3VDLFNBQVMsQ0FBQ1ksUUFBUSxDQUFDLGlCQUFpQixpQkFBaUI7WUFFekUsc0JBQXNCO1lBQ3RCLE1BQU0sRUFBRXhDLE9BQU9zRCxZQUFZLEVBQUUsR0FBRyxNQUFNdEUsbURBQVFBLENBQUMrQixPQUFPLENBQ25EQyxJQUFJLENBQUNxQyxRQUNMRSxNQUFNLENBQUM7Z0JBQUNsRSxLQUFLc0MsU0FBUzthQUFDO1lBRTFCLElBQUkyQixjQUFjO2dCQUNoQnpELFFBQVFHLEtBQUssQ0FBQyx5QkFBeUJzRDtZQUN6QztRQUNGO1FBRUEsdUJBQXVCO1FBQ3ZCLE1BQU0sRUFBRXRELE9BQU93RCxPQUFPLEVBQUUsR0FBRyxNQUFNeEUsbURBQVFBLENBQ3RDZ0MsSUFBSSxDQUFDLGFBQ0x5QyxNQUFNLEdBQ05OLEVBQUUsQ0FBQyxNQUFNbEI7UUFFWixJQUFJdUIsU0FBUyxNQUFNQTtRQUVuQixPQUFPO0lBQ1QsRUFBRSxPQUFPeEQsT0FBTztRQUNkSCxRQUFRRyxLQUFLLENBQUMsd0JBQXdCQTtRQUN0QyxNQUFNQTtJQUNSO0FBQ0Y7QUFFTyxNQUFNMEQsZUFBZTtJQUMxQnZEO0lBQ0FrQztJQUNBTztJQUNBTTtJQUNBOUQ7SUFDQWE7QUFDRixFQUFFIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGh3ZXRoXFxPbmVEcml2ZVxcRGVza3RvcFxcSW5ub3ZlcmFcXEhpZ2dpbnNcXE1pbmRWYXVsdFxcTWluZFZhdWx0LTFcXG1pbmR2YXVsdFxcYXBwXFxzZXJ2aWNlc1xcZmlsZXNTZXJ2aWNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBTZXJ2aWNlIGZvciBoYW5kbGluZyBmaWxlIG9wZXJhdGlvbnMgd2l0aCBTdXBhYmFzZVxyXG4gKi9cclxuaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tICcuLi9saWIvc3VwYWJhc2UnO1xyXG5cclxuLyoqXHJcbiAqIEZvcm1hdHMgZmlsZSBzaXplIGluIGEgaHVtYW4tcmVhZGFibGUgZm9ybWF0XHJcbiAqL1xyXG5jb25zdCBmb3JtYXRGaWxlU2l6ZSA9IChieXRlcykgPT4ge1xyXG4gIGlmIChieXRlcyA8IDEwMjQpIHJldHVybiBieXRlcyArICcgYnl0ZXMnO1xyXG4gIGVsc2UgaWYgKGJ5dGVzIDwgMTA0ODU3NikgcmV0dXJuIChieXRlcyAvIDEwMjQpLnRvRml4ZWQoMSkgKyAnIEtCJztcclxuICBlbHNlIHJldHVybiAoYnl0ZXMgLyAxMDQ4NTc2KS50b0ZpeGVkKDEpICsgJyBNQic7XHJcbn07XHJcblxyXG4vKipcclxuICogRXh0cmFjdCB0ZXh0IGZyb20gUERGIGZpbGVcclxuICovXHJcbmNvbnN0IGV4dHJhY3RUZXh0RnJvbVBERiA9IGFzeW5jIChmaWxlKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpO1xyXG4gICAgXHJcbiAgICAvLyBIZXJlLCB3ZSdsbCBqdXN0IHJlYWQgdGhlIGZpbGUgYXMgdGV4dCBmb3Igc2ltcGxpY2l0eVxyXG4gICAgLy8gSW4gYSByZWFsIGFwcCwgeW91IHdvdWxkIHVzZSBhIFBERiBwYXJzaW5nIGxpYnJhcnkgbGlrZSBwZGYuanNcclxuICAgIGNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gR2V0IHRoZSByYXcgdGV4dCBmcm9tIHRoZSBQREZcclxuICAgICAgY29uc3QgcmF3VGV4dCA9IHRleHREZWNvZGVyLmRlY29kZShhcnJheUJ1ZmZlcik7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDbGVhbiB0aGUgdGV4dCBieSByZW1vdmluZyBudWxsIGJ5dGVzIGFuZCBvdGhlciBjb250cm9sIGNoYXJhY3RlcnNcclxuICAgICAgLy8gVGhpcyBwcmV2ZW50cyBQb3N0Z3JlU1FMIGZyb20gcmVqZWN0aW5nIHRoZSBjb250ZW50XHJcbiAgICAgIGNvbnN0IGNsZWFuZWRUZXh0ID0gcmF3VGV4dFxyXG4gICAgICAgIC5yZXBsYWNlKC9cXHUwMDAwL2csICcnKSAvLyBSZW1vdmUgbnVsbCBieXRlc1xyXG4gICAgICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MDhcXHgwQlxceDBDXFx4MEUtXFx4MUZcXHg3Rl0vZywgJycpOyAvLyBSZW1vdmUgb3RoZXIgY29udHJvbCBjaGFyYWN0ZXJzXHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhgUERGIHByb2Nlc3NlZCwgcmVtb3ZlZCAke3Jhd1RleHQubGVuZ3RoIC0gY2xlYW5lZFRleHQubGVuZ3RofSBpbnZhbGlkIGNoYXJhY3RlcnNgKTtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiBjbGVhbmVkVGV4dDtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlY29kaW5nIFBERiB0ZXh0OicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuICdVbmFibGUgdG8gZXh0cmFjdCB0ZXh0IGZyb20gUERGJztcclxuICAgIH1cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVhZGluZyBQREY6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBFeHRyYWN0IGRhdGEgZnJvbSBFeGNlbCBmaWxlXHJcbiAqL1xyXG5jb25zdCBleHRyYWN0VGV4dEZyb21FeGNlbCA9IGFzeW5jIChmaWxlKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIEluIGEgcmVhbCBhcHAsIHlvdSB3b3VsZCB1c2UgYSBsaWJyYXJ5IGxpa2UgeGxzeCBvciBleGNlbGpzXHJcbiAgICAvLyBGb3Igbm93LCB3ZSdsbCBqdXN0IHJldHVybiBhIHBsYWNlaG9sZGVyXHJcbiAgICByZXR1cm4gYEV4dHJhY3RlZCB0ZXh0IGZyb20gRXhjZWwgZmlsZTogJHtmaWxlLm5hbWV9YDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVhZGluZyBFeGNlbCBmaWxlOicsIGVycm9yKTtcclxuICAgIHJldHVybiAnJztcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogVXBsb2FkcyBhIGRvY3VtZW50IHRvIFN1cGFiYXNlIHN0b3JhZ2UgYW5kIGRhdGFiYXNlXHJcbiAqL1xyXG5jb25zdCB1cGxvYWREb2N1bWVudCA9IGFzeW5jIChmaWxlKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKGBQcm9jZXNzaW5nIGRvY3VtZW50OiAke2ZpbGUubmFtZX0sIHR5cGU6ICR7ZmlsZS50eXBlfSwgc2l6ZTogJHtmaWxlLnNpemV9IGJ5dGVzYCk7XHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3QgdGV4dCBjb250ZW50IGZyb20gUERGXHJcbiAgICBsZXQgdGV4dENvbnRlbnQgPSAnJztcclxuICAgIGlmIChmaWxlLnR5cGUgPT09ICdhcHBsaWNhdGlvbi9wZGYnKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdQcm9jZXNzaW5nIGFzIFBERi4uLicpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRleHRDb250ZW50ID0gYXdhaXQgZXh0cmFjdFRleHRGcm9tUERGKGZpbGUpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBQREYgcHJvY2Vzc2luZyBjb21wbGV0ZSwgZXh0cmFjdGVkICR7dGV4dENvbnRlbnQubGVuZ3RofSBjaGFyYWN0ZXJzYCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gTGltaXQgdGhlIHRleHQgY29udGVudCBzaXplIHRvIHByZXZlbnQgZGF0YWJhc2UgaXNzdWVzXHJcbiAgICAgICAgLy8gUG9zdGdyZVNRTCBoYXMgYSBsaW1pdCBvbiB0ZXh0IGNvbHVtbiBzaXplXHJcbiAgICAgICAgaWYgKHRleHRDb250ZW50Lmxlbmd0aCA+IDEwMDAwMDApIHsgIC8vIDFNQiBsaW1pdFxyXG4gICAgICAgICAgY29uc29sZS5sb2coYFRleHQgY29udGVudCB0b28gbGFyZ2UgKCR7dGV4dENvbnRlbnQubGVuZ3RofSBjaGFycyksIHRydW5jYXRpbmcuLi5gKTtcclxuICAgICAgICAgIHRleHRDb250ZW50ID0gdGV4dENvbnRlbnQuc3Vic3RyaW5nKDAsIDEwMDAwMDApICsgJy4uLiBbY29udGVudCB0cnVuY2F0ZWRdJztcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKHBkZkVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignUERGIGV4dHJhY3Rpb24gZXJyb3I6JywgcGRmRXJyb3IpO1xyXG4gICAgICAgIHRleHRDb250ZW50ID0gJ0Vycm9yIGV4dHJhY3RpbmcgUERGIGNvbnRlbnQnO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmxvZyhgVW5zdXBwb3J0ZWQgZG9jdW1lbnQgdHlwZTogJHtmaWxlLnR5cGV9LCBubyB0ZXh0IGV4dHJhY3Rpb24gcGVyZm9ybWVkYCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFVwbG9hZCBmaWxlIHRvIFN1cGFiYXNlIFN0b3JhZ2VcclxuICAgIGNvbnN0IGZpbGVOYW1lID0gYCR7RGF0ZS5ub3coKX0tJHtmaWxlLm5hbWV9YDtcclxuICAgIGNvbnNvbGUubG9nKGBVcGxvYWRpbmcgZmlsZSB0byBTdXBhYmFzZSBzdG9yYWdlIGJ1Y2tldCAnZG9jdW1lbnRzJyB3aXRoIG5hbWU6ICR7ZmlsZU5hbWV9YCk7XHJcbiAgICBjb25zdCB7IGVycm9yOiB1cGxvYWRFcnJvciwgZGF0YTogc3RvcmFnZURhdGEgfSA9IGF3YWl0IHN1cGFiYXNlLnN0b3JhZ2VcclxuICAgICAgLmZyb20oJ2RvY3VtZW50cycpXHJcbiAgICAgIC51cGxvYWQoZmlsZU5hbWUsIGZpbGUsIHtcclxuICAgICAgICBjYWNoZUNvbnRyb2w6ICczNjAwJyxcclxuICAgICAgICB1cHNlcnQ6IGZhbHNlXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGlmICh1cGxvYWRFcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdTdG9yYWdlIHVwbG9hZCBlcnJvcjonLCBKU09OLnN0cmluZ2lmeSh1cGxvYWRFcnJvcikpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0b3JhZ2UgdXBsb2FkIGVycm9yOiAke0pTT04uc3RyaW5naWZ5KHVwbG9hZEVycm9yKX1gKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZygnRmlsZSBzdWNjZXNzZnVsbHkgdXBsb2FkZWQgdG8gc3RvcmFnZSwgZ2V0dGluZyBwdWJsaWMgVVJMJyk7XHJcbiAgICAvLyBHZXQgdGhlIHB1YmxpYyBVUkxcclxuICAgIGNvbnN0IHsgZGF0YTogeyBwdWJsaWNVcmwgfSB9ID0gc3VwYWJhc2Uuc3RvcmFnZVxyXG4gICAgICAuZnJvbSgnZG9jdW1lbnRzJylcclxuICAgICAgLmdldFB1YmxpY1VybChmaWxlTmFtZSk7XHJcblxyXG4gICAgY29uc29sZS5sb2coYFB1YmxpYyBVUkwgZ2VuZXJhdGVkOiAke3B1YmxpY1VybH1gKTtcclxuICAgIFxyXG4gICAgLy8gQ3JlYXRlIGRhdGFiYXNlIHJlY29yZFxyXG4gICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIGRhdGFiYXNlIHJlY29yZCBmb3IgdGhlIHVwbG9hZGVkIGZpbGUnKTtcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdkb2N1bWVudHMnKVxyXG4gICAgICAuaW5zZXJ0KFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICB0aXRsZTogZmlsZS5uYW1lLFxyXG4gICAgICAgICAgZmlsZV9wYXRoOiBmaWxlTmFtZSxcclxuICAgICAgICAgIGZpbGVfdHlwZTogZmlsZS50eXBlLFxyXG4gICAgICAgICAgZmlsZV9zaXplOiBmaWxlLnNpemUsXHJcbiAgICAgICAgICBjb250ZW50OiB0ZXh0Q29udGVudCxcclxuICAgICAgICAgIHB1YmxpY191cmw6IHB1YmxpY1VybFxyXG4gICAgICAgIH1cclxuICAgICAgXSlcclxuICAgICAgLnNlbGVjdCgpO1xyXG5cclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdEYXRhYmFzZSBpbnNlcnQgZXJyb3I6JywgSlNPTi5zdHJpbmdpZnkoZXJyb3IpKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhYmFzZSBpbnNlcnQgZXJyb3I6ICR7SlNPTi5zdHJpbmdpZnkoZXJyb3IpfWApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnRG9jdW1lbnQgc3VjY2Vzc2Z1bGx5IHVwbG9hZGVkIGFuZCByZWNvcmRlZCBpbiBkYXRhYmFzZScpO1xyXG4gICAgLy8gUmV0dXJuIGZvcm1hdHRlZCBkb2N1bWVudFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaWQ6IGRhdGFbMF0uaWQsXHJcbiAgICAgIG5hbWU6IGRhdGFbMF0udGl0bGUsXHJcbiAgICAgIHR5cGU6ICdkb2N1bWVudCcsXHJcbiAgICAgIGNvbnRlbnQ6IGRhdGFbMF0uY29udGVudCxcclxuICAgICAgc2l6ZTogZm9ybWF0RmlsZVNpemUoZGF0YVswXS5maWxlX3NpemUpLFxyXG4gICAgICB1cGxvYWREYXRlOiBuZXcgRGF0ZShkYXRhWzBdLmNyZWF0ZWRfYXQpLFxyXG4gICAgICB1cmw6IGRhdGFbMF0ucHVibGljX3VybFxyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignVXBsb2FkIGRvY3VtZW50IGVycm9yOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBVcGxvYWRzIGEgc3ByZWFkc2hlZXQgdG8gU3VwYWJhc2Ugc3RvcmFnZSBhbmQgZGF0YWJhc2VcclxuICovXHJcbmNvbnN0IHVwbG9hZFNwcmVhZHNoZWV0ID0gYXN5bmMgKGZpbGUpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc29sZS5sb2coYFByb2Nlc3Npbmcgc3ByZWFkc2hlZXQ6ICR7ZmlsZS5uYW1lfSwgdHlwZTogJHtmaWxlLnR5cGV9LCBzaXplOiAke2ZpbGUuc2l6ZX0gYnl0ZXNgKTtcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBjb250ZW50IGZyb20gRXhjZWxcclxuICAgIGxldCB0ZXh0Q29udGVudCA9ICcnO1xyXG4gICAgbGV0IHN0cnVjdHVyZWREYXRhID0gbnVsbDtcclxuICAgIFxyXG4gICAgaWYgKGZpbGUubmFtZS5lbmRzV2l0aCgnLnhsc3gnKSB8fCBmaWxlLm5hbWUuZW5kc1dpdGgoJy54bHMnKSB8fCBmaWxlLnR5cGUuaW5jbHVkZXMoJ2V4Y2VsJykpIHtcclxuICAgICAgY29uc29sZS5sb2coJ1Byb2Nlc3NpbmcgYXMgRXhjZWwuLi4nKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB0ZXh0Q29udGVudCA9IGF3YWl0IGV4dHJhY3RUZXh0RnJvbUV4Y2VsKGZpbGUpO1xyXG4gICAgICAgIC8vIEluIGEgcmVhbCBhcHAsIHlvdSB3b3VsZCBwYXJzZSB0aGUgRXhjZWwgZGF0YSBpbnRvIHN0cnVjdHVyZWQgSlNPTlxyXG4gICAgICAgIHN0cnVjdHVyZWREYXRhID0gSlNPTi5zdHJpbmdpZnkoW1snSGVhZGVyIDEnLCAnSGVhZGVyIDInXSwgWydEYXRhIDEnLCAnRGF0YSAyJ11dKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgRXhjZWwgcHJvY2Vzc2luZyBjb21wbGV0ZSwgZXh0cmFjdGVkICR7dGV4dENvbnRlbnQubGVuZ3RofSBjaGFyYWN0ZXJzYCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gTGltaXQgdGhlIHRleHQgY29udGVudCBzaXplXHJcbiAgICAgICAgaWYgKHRleHRDb250ZW50Lmxlbmd0aCA+IDEwMDAwMDApIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBUZXh0IGNvbnRlbnQgdG9vIGxhcmdlICgke3RleHRDb250ZW50Lmxlbmd0aH0gY2hhcnMpLCB0cnVuY2F0aW5nLi4uYCk7XHJcbiAgICAgICAgICB0ZXh0Q29udGVudCA9IHRleHRDb250ZW50LnN1YnN0cmluZygwLCAxMDAwMDAwKSArICcuLi4gW2NvbnRlbnQgdHJ1bmNhdGVkXSc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChleGNlbEVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXhjZWwgZXh0cmFjdGlvbiBlcnJvcjonLCBleGNlbEVycm9yKTtcclxuICAgICAgICB0ZXh0Q29udGVudCA9ICdFcnJvciBleHRyYWN0aW5nIEV4Y2VsIGNvbnRlbnQnO1xyXG4gICAgICAgIHN0cnVjdHVyZWREYXRhID0gSlNPTi5zdHJpbmdpZnkoW1snRXJyb3InXSwgWydGYWlsZWQgdG8gZXh0cmFjdCBkYXRhJ11dKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5sb2coYFVuc3VwcG9ydGVkIHNwcmVhZHNoZWV0IHR5cGU6ICR7ZmlsZS50eXBlfSwgbm8gdGV4dCBleHRyYWN0aW9uIHBlcmZvcm1lZGApO1xyXG4gICAgICBzdHJ1Y3R1cmVkRGF0YSA9IEpTT04uc3RyaW5naWZ5KFtbJ05vIERhdGEnXSwgWydVbnN1cHBvcnRlZCBmaWxlIGZvcm1hdCddXSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFVwbG9hZCBmaWxlIHRvIFN1cGFiYXNlIFN0b3JhZ2VcclxuICAgIGNvbnN0IGZpbGVOYW1lID0gYCR7RGF0ZS5ub3coKX0tJHtmaWxlLm5hbWV9YDtcclxuICAgIGNvbnNvbGUubG9nKGBVcGxvYWRpbmcgZmlsZSB0byBTdXBhYmFzZSBzdG9yYWdlIGJ1Y2tldCAnc3ByZWFkc2hlZXRzJyB3aXRoIG5hbWU6ICR7ZmlsZU5hbWV9YCk7XHJcbiAgICBjb25zdCB7IGVycm9yOiB1cGxvYWRFcnJvciwgZGF0YTogc3RvcmFnZURhdGEgfSA9IGF3YWl0IHN1cGFiYXNlLnN0b3JhZ2VcclxuICAgICAgLmZyb20oJ3NwcmVhZHNoZWV0cycpXHJcbiAgICAgIC51cGxvYWQoZmlsZU5hbWUsIGZpbGUsIHtcclxuICAgICAgICBjYWNoZUNvbnRyb2w6ICczNjAwJyxcclxuICAgICAgICB1cHNlcnQ6IGZhbHNlXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGlmICh1cGxvYWRFcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdTdG9yYWdlIHVwbG9hZCBlcnJvcjonLCBKU09OLnN0cmluZ2lmeSh1cGxvYWRFcnJvcikpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0b3JhZ2UgdXBsb2FkIGVycm9yOiAke0pTT04uc3RyaW5naWZ5KHVwbG9hZEVycm9yKX1gKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZygnRmlsZSBzdWNjZXNzZnVsbHkgdXBsb2FkZWQgdG8gc3RvcmFnZSwgZ2V0dGluZyBwdWJsaWMgVVJMJyk7XHJcbiAgICAvLyBHZXQgdGhlIHB1YmxpYyBVUkxcclxuICAgIGNvbnN0IHsgZGF0YTogeyBwdWJsaWNVcmwgfSB9ID0gc3VwYWJhc2Uuc3RvcmFnZVxyXG4gICAgICAuZnJvbSgnc3ByZWFkc2hlZXRzJylcclxuICAgICAgLmdldFB1YmxpY1VybChmaWxlTmFtZSk7XHJcblxyXG4gICAgY29uc29sZS5sb2coYFB1YmxpYyBVUkwgZ2VuZXJhdGVkOiAke3B1YmxpY1VybH1gKTtcclxuICAgIFxyXG4gICAgLy8gQ3JlYXRlIGRhdGFiYXNlIHJlY29yZFxyXG4gICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIGRhdGFiYXNlIHJlY29yZCBmb3IgdGhlIHVwbG9hZGVkIGZpbGUnKTtcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdkb2N1bWVudHMnKVxyXG4gICAgICAuaW5zZXJ0KFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICB0aXRsZTogZmlsZS5uYW1lLFxyXG4gICAgICAgICAgZmlsZV9wYXRoOiBmaWxlTmFtZSxcclxuICAgICAgICAgIGZpbGVfdHlwZTogYHNwcmVhZHNoZWV0LyR7ZmlsZS50eXBlfWAsXHJcbiAgICAgICAgICBmaWxlX3NpemU6IGZpbGUuc2l6ZSxcclxuICAgICAgICAgIGNvbnRlbnQ6IHRleHRDb250ZW50LFxyXG4gICAgICAgICAgc3RydWN0dXJlZF9kYXRhOiBzdHJ1Y3R1cmVkRGF0YSxcclxuICAgICAgICAgIHB1YmxpY191cmw6IHB1YmxpY1VybFxyXG4gICAgICAgIH1cclxuICAgICAgXSlcclxuICAgICAgLnNlbGVjdCgpO1xyXG5cclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdEYXRhYmFzZSBpbnNlcnQgZXJyb3I6JywgSlNPTi5zdHJpbmdpZnkoZXJyb3IpKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhYmFzZSBpbnNlcnQgZXJyb3I6ICR7SlNPTi5zdHJpbmdpZnkoZXJyb3IpfWApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnU3ByZWFkc2hlZXQgc3VjY2Vzc2Z1bGx5IHVwbG9hZGVkIGFuZCByZWNvcmRlZCBpbiBkYXRhYmFzZScpO1xyXG4gICAgLy8gUmV0dXJuIGZvcm1hdHRlZCBzcHJlYWRzaGVldFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaWQ6IGRhdGFbMF0uaWQsXHJcbiAgICAgIG5hbWU6IGRhdGFbMF0udGl0bGUsXHJcbiAgICAgIHR5cGU6ICdzcHJlYWRzaGVldCcsXHJcbiAgICAgIGRhdGE6IEpTT04ucGFyc2UoZGF0YVswXS5zdHJ1Y3R1cmVkX2RhdGEgfHwgJ1tbXV0nKSxcclxuICAgICAgc2l6ZTogZm9ybWF0RmlsZVNpemUoZGF0YVswXS5maWxlX3NpemUpLFxyXG4gICAgICB1cGxvYWREYXRlOiBuZXcgRGF0ZShkYXRhWzBdLmNyZWF0ZWRfYXQpLFxyXG4gICAgICB1cmw6IGRhdGFbMF0ucHVibGljX3VybFxyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignVXBsb2FkIHNwcmVhZHNoZWV0IGVycm9yOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXRyaWV2ZXMgYWxsIGZpbGVzIGZyb20gU3VwYWJhc2VcclxuICovXHJcbmNvbnN0IGdldEZpbGVzID0gYXN5bmMgKCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnZG9jdW1lbnRzJylcclxuICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG5cclxuICAgIHJldHVybiBkYXRhLm1hcChmaWxlID0+IHtcclxuICAgICAgaWYgKGZpbGUuZmlsZV90eXBlLmluY2x1ZGVzKCdzcHJlYWRzaGVldCcpKSB7XHJcbiAgICAgICAgLy8gUmV0dXJuIGFzIFNwcmVhZHNoZWV0IHR5cGVcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgaWQ6IGZpbGUuaWQsXHJcbiAgICAgICAgICBuYW1lOiBmaWxlLnRpdGxlIHx8IGZpbGUubmFtZSxcclxuICAgICAgICAgIHR5cGU6ICdzcHJlYWRzaGVldCcsXHJcbiAgICAgICAgICBkYXRhOiBmaWxlLnN0cnVjdHVyZWRfZGF0YSA/IEpTT04ucGFyc2UoZmlsZS5zdHJ1Y3R1cmVkX2RhdGEpIDogW1tdXSxcclxuICAgICAgICAgIHNpemU6IGZvcm1hdEZpbGVTaXplKGZpbGUuZmlsZV9zaXplIHx8IDApLFxyXG4gICAgICAgICAgdXBsb2FkRGF0ZTogbmV3IERhdGUoZmlsZS5jcmVhdGVkX2F0KSxcclxuICAgICAgICAgIHVybDogZmlsZS5wdWJsaWNfdXJsXHJcbiAgICAgICAgfTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBSZXR1cm4gYXMgRG9jdW1lbnQgdHlwZVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBpZDogZmlsZS5pZCxcclxuICAgICAgICAgIG5hbWU6IGZpbGUudGl0bGUgfHwgZmlsZS5uYW1lLFxyXG4gICAgICAgICAgdHlwZTogJ2RvY3VtZW50JyxcclxuICAgICAgICAgIGNvbnRlbnQ6IGZpbGUuY29udGVudCB8fCAnJyxcclxuICAgICAgICAgIHNpemU6IGZvcm1hdEZpbGVTaXplKGZpbGUuZmlsZV9zaXplIHx8IDApLFxyXG4gICAgICAgICAgdXBsb2FkRGF0ZTogbmV3IERhdGUoZmlsZS5jcmVhdGVkX2F0KSxcclxuICAgICAgICAgIHVybDogZmlsZS5wdWJsaWNfdXJsXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZmV0Y2ggZmlsZXMgZnJvbSBTdXBhYmFzZTonLCBlKTtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRGVsZXRlcyBhIGZpbGUgYnkgSURcclxuICovXHJcbmNvbnN0IGRlbGV0ZUZpbGUgPSBhc3luYyAoaWQpID0+IHtcclxuICB0cnkge1xyXG4gICAgLy8gRmlyc3QgZ2V0IHRoZSBmaWxlIGluZm8gdG8gZ2V0IHRoZSBzdG9yYWdlIHBhdGhcclxuICAgIGNvbnN0IHsgZGF0YTogZmlsZSB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ2RvY3VtZW50cycpXHJcbiAgICAgIC5zZWxlY3QoJ2ZpbGVfcGF0aCwgZmlsZV90eXBlJylcclxuICAgICAgLmVxKCdpZCcsIGlkKVxyXG4gICAgICAuc2luZ2xlKCk7XHJcblxyXG4gICAgaWYgKGZpbGUpIHtcclxuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBzdG9yYWdlIGJ1Y2tldCBiYXNlZCBvbiBmaWxlIHR5cGVcclxuICAgICAgY29uc3QgYnVja2V0ID0gZmlsZS5maWxlX3R5cGUuaW5jbHVkZXMoJ3NwcmVhZHNoZWV0JykgPyAnc3ByZWFkc2hlZXRzJyA6ICdkb2N1bWVudHMnO1xyXG4gICAgICBcclxuICAgICAgLy8gRGVsZXRlIGZyb20gc3RvcmFnZVxyXG4gICAgICBjb25zdCB7IGVycm9yOiBzdG9yYWdlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLnN0b3JhZ2VcclxuICAgICAgICAuZnJvbShidWNrZXQpXHJcbiAgICAgICAgLnJlbW92ZShbZmlsZS5maWxlX3BhdGhdKTtcclxuXHJcbiAgICAgIGlmIChzdG9yYWdlRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdTdG9yYWdlIGRlbGV0ZSBlcnJvcjonLCBzdG9yYWdlRXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGVsZXRlIGZyb20gZGF0YWJhc2VcclxuICAgIGNvbnN0IHsgZXJyb3I6IGRiRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdkb2N1bWVudHMnKVxyXG4gICAgICAuZGVsZXRlKClcclxuICAgICAgLmVxKCdpZCcsIGlkKTtcclxuXHJcbiAgICBpZiAoZGJFcnJvcikgdGhyb3cgZGJFcnJvcjtcclxuICAgIFxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIGZpbGU6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGZpbGVzU2VydmljZSA9IHtcclxuICB1cGxvYWREb2N1bWVudCxcclxuICB1cGxvYWRTcHJlYWRzaGVldCxcclxuICBnZXRGaWxlcyxcclxuICBkZWxldGVGaWxlLFxyXG4gIGV4dHJhY3RUZXh0RnJvbVBERixcclxuICBleHRyYWN0VGV4dEZyb21FeGNlbFxyXG59OyAiXSwibmFtZXMiOlsic3VwYWJhc2UiLCJmb3JtYXRGaWxlU2l6ZSIsImJ5dGVzIiwidG9GaXhlZCIsImV4dHJhY3RUZXh0RnJvbVBERiIsImZpbGUiLCJhcnJheUJ1ZmZlciIsInRleHREZWNvZGVyIiwiVGV4dERlY29kZXIiLCJyYXdUZXh0IiwiZGVjb2RlIiwiY2xlYW5lZFRleHQiLCJyZXBsYWNlIiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsImVycm9yIiwiZXh0cmFjdFRleHRGcm9tRXhjZWwiLCJuYW1lIiwidXBsb2FkRG9jdW1lbnQiLCJ0eXBlIiwic2l6ZSIsInRleHRDb250ZW50Iiwic3Vic3RyaW5nIiwicGRmRXJyb3IiLCJmaWxlTmFtZSIsIkRhdGUiLCJub3ciLCJ1cGxvYWRFcnJvciIsImRhdGEiLCJzdG9yYWdlRGF0YSIsInN0b3JhZ2UiLCJmcm9tIiwidXBsb2FkIiwiY2FjaGVDb250cm9sIiwidXBzZXJ0IiwiSlNPTiIsInN0cmluZ2lmeSIsIkVycm9yIiwicHVibGljVXJsIiwiZ2V0UHVibGljVXJsIiwiaW5zZXJ0IiwidGl0bGUiLCJmaWxlX3BhdGgiLCJmaWxlX3R5cGUiLCJmaWxlX3NpemUiLCJjb250ZW50IiwicHVibGljX3VybCIsInNlbGVjdCIsImlkIiwidXBsb2FkRGF0ZSIsImNyZWF0ZWRfYXQiLCJ1cmwiLCJ1cGxvYWRTcHJlYWRzaGVldCIsInN0cnVjdHVyZWREYXRhIiwiZW5kc1dpdGgiLCJpbmNsdWRlcyIsImV4Y2VsRXJyb3IiLCJzdHJ1Y3R1cmVkX2RhdGEiLCJwYXJzZSIsImdldEZpbGVzIiwib3JkZXIiLCJhc2NlbmRpbmciLCJtYXAiLCJlIiwid2FybiIsImRlbGV0ZUZpbGUiLCJlcSIsInNpbmdsZSIsImJ1Y2tldCIsInN0b3JhZ2VFcnJvciIsInJlbW92ZSIsImRiRXJyb3IiLCJkZWxldGUiLCJmaWxlc1NlcnZpY2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/services/filesService.js\n"));

/***/ })

});