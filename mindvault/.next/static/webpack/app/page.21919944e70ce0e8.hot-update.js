"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/services/chatService.js":
/*!*************************************!*\
  !*** ./app/services/chatService.js ***!
  \*************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chatService: () => (/* binding */ chatService)\n/* harmony export */ });\n/* harmony import */ var openai__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! openai */ \"(app-pages-browser)/./node_modules/openai/index.mjs\");\n/* harmony import */ var _excelAIService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./excelAIService */ \"(app-pages-browser)/./app/services/excelAIService.js\");\n// Updated chatService.js\n\n\n// Define a fallback API key for development purposes\n// In production, this should be replaced with your actual OpenAI API key\nconst FALLBACK_API_KEY = \"sk-fallback-development-mode-key\";\n// Log a message about the API key for debugging\nconsole.log(\"API Key present (NEXT_PUBLIC_OPENAI_API_KEY):\", !!\"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\");\nconsole.log(\"API Key format:\",  true ? \"starts with \".concat(\"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\".substring(0, 8), \"...\") : 0);\n// Use the NEXT_PUBLIC_ prefixed key since we're in a client component\n// Fall back to the development key if the environment variable is not set\nconst apiKey = \"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\" || 0;\n// Check if this is a project-based API key\nconst isProjectKey = apiKey.startsWith('sk-proj-');\nconsole.log(\"Using project-based API key:\", isProjectKey);\n// Get the project ID from environment variable or extract from the key\nconst projectId = \"G3mOyHIp0RF8chZJEPDh\" || (0);\nconsole.log(\"Project ID:\", projectId ? \"\".concat(projectId.substring(0, 8), \"...\") : \"Not available\");\n// Create the OpenAI client with the appropriate configuration\nconst openai = new openai__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n    apiKey: apiKey,\n    dangerouslyAllowBrowser: true,\n    // For project-based keys, we need to specify the project ID\n    ...isProjectKey && projectId && {\n        projectId: projectId,\n        baseURL: 'https://api.openai.com/v1' // Ensure we're using the correct base URL\n    }\n});\n// Keywords that might indicate an Excel-related question\nconst EXCEL_KEYWORDS = [\n    'excel',\n    'spreadsheet',\n    'financial',\n    'financials',\n    'finance',\n    'revenue',\n    'profit',\n    'margin',\n    'budget',\n    'forecast',\n    'sales',\n    'growth',\n    'expense',\n    'cash',\n    'flow',\n    'balance',\n    'sheet',\n    'income',\n    'statement',\n    'ratio',\n    'metric',\n    'trend',\n    'projection',\n    'quarterly',\n    'annual'\n];\n// Function to prepare Excel content for better AI understanding\nconst prepareExcelContextForAI = (content)=>{\n    // Format the Excel content for better AI understanding\n    if (!content) return '';\n    // Add a prefix to help the AI understand this is spreadsheet data\n    return \"[Excel Spreadsheet Data]:\\n\".concat(content);\n};\nconst chatService = {\n    async sendMessage (message) {\n        let files = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        try {\n            // Check if we're using the fallback key\n            const isDevelopmentMode = apiKey === FALLBACK_API_KEY;\n            if (!apiKey) {\n                console.error('OpenAI API key is missing');\n                throw new Error('OpenAI API key is not configured. Please check your .env.local file.');\n            }\n            console.log(\"Processing request with \".concat(files.length, \" files\"));\n            // Check if any files are available\n            if (!files || files.length === 0) {\n                console.warn('No files available for analysis');\n                return {\n                    text: \"I don't see any uploaded documents to analyze. Please upload a pitch deck (PDF) and financial document (Excel) first.\"\n                };\n            }\n            // If we're in development mode with the fallback key, return a mock response\n            if (isDevelopmentMode) {\n                console.log(\"DEVELOPMENT MODE: Using mock response instead of calling OpenAI API\");\n                return this.getMockResponse(message, files);\n            }\n            console.log(\"Using API key:\", apiKey.substring(0, 10) + \"...\");\n            // Create a context message based on files if they exist\n            let contextMessage = '';\n            if (files && files.length > 0) {\n                console.log(\"Files detected:\", files.map((f)=>\"\".concat(f.name, \" (\").concat(f.type, \")\")).join(', '));\n                const pdfFiles = files.filter((file)=>{\n                    var _file_name;\n                    return (_file_name = file.name) === null || _file_name === void 0 ? void 0 : _file_name.toLowerCase().endsWith('.pdf');\n                });\n                const excelFiles = files.filter((file)=>{\n                    var _file_name, _file_name1;\n                    return ((_file_name = file.name) === null || _file_name === void 0 ? void 0 : _file_name.toLowerCase().endsWith('.xlsx')) || ((_file_name1 = file.name) === null || _file_name1 === void 0 ? void 0 : _file_name1.toLowerCase().endsWith('.xls'));\n                });\n                // Add file names as context\n                if (pdfFiles.length > 0) {\n                    contextMessage += \"\\nPDF Documents: \".concat(pdfFiles.map((f)=>f.name).join(', '), \"\\n\");\n                }\n                if (excelFiles.length > 0) {\n                    contextMessage += \"\\nExcel Files: \".concat(excelFiles.map((f)=>f.name).join(', '), \"\\n\");\n                }\n                // Add selected file content for context (limiting to avoid token usage)\n                let fileContentAdded = 0;\n                // Add content from PDF files first\n                for (const file of pdfFiles){\n                    if (file.content && file.content.length > 0 && fileContentAdded < 3) {\n                        // Smart PDF content extraction\n                        let pdfContent = file.content;\n                        const contentLength = pdfContent.length;\n                        // Log the total size of the PDF content\n                        console.log(\"PDF \".concat(file.name, \" content length: \").concat(contentLength, \" characters\"));\n                        // If PDF is very large, implement smarter extraction\n                        if (contentLength > 30000) {\n                            // Define key sections we want to extract\n                            const keyPhrases = [\n                                \"management team\",\n                                \"leadership team\",\n                                \"executive team\",\n                                \"founders\",\n                                \"annual recurring revenue\",\n                                \"arr\",\n                                \"burn rate\",\n                                \"runway\",\n                                \"financials\",\n                                \"financial summary\",\n                                \"metrics\",\n                                \"kpi\",\n                                \"key performance\",\n                                \"problem\",\n                                \"solution\",\n                                \"value proposition\",\n                                \"market opportunity\"\n                            ];\n                            // Initialize extracted content\n                            let extractedContent = \"\";\n                            const chunkSize = 10000; // Size of each chunk to process\n                            // Add beginning of document (always important)\n                            extractedContent += pdfContent.substring(0, 8000) + \"\\n...\\n\";\n                            // Process the document in chunks to find key sections\n                            for(let i = 8000; i < contentLength; i += chunkSize){\n                                const chunk = pdfContent.substring(i, Math.min(i + chunkSize, contentLength));\n                                // Check if this chunk contains any key phrases\n                                const containsKeyPhrase = keyPhrases.some((phrase)=>chunk.toLowerCase().includes(phrase.toLowerCase()));\n                                if (containsKeyPhrase) {\n                                    extractedContent += chunk + \"\\n...\\n\";\n                                }\n                            }\n                            // Always include the end of the document (where team info often appears)\n                            const endSection = pdfContent.substring(Math.max(0, contentLength - 10000));\n                            if (!extractedContent.includes(endSection)) {\n                                extractedContent += \"\\n...\\n\" + endSection;\n                            }\n                            pdfContent = extractedContent;\n                            console.log(\"Extracted \".concat(pdfContent.length, \" characters of key sections from PDF\"));\n                        } else {\n                            // For smaller PDFs, just use all the content\n                            pdfContent = pdfContent.substring(0, 30000);\n                        }\n                        contextMessage += \"\\n--- Content from PDF: \".concat(file.name, \" ---\\n\").concat(pdfContent, \"\\n--- End of PDF excerpt ---\\n\\n\");\n                        fileContentAdded++;\n                    }\n                }\n                // Add content from Excel files next\n                for (const file of excelFiles){\n                    if (file.content && file.content.length > 0 && fileContentAdded < 5) {\n                        // Smart Excel content extraction\n                        let excelContent = file.content;\n                        const contentLength = excelContent.length;\n                        // Log the total size of the Excel content\n                        console.log(\"Excel \".concat(file.name, \" content length: \").concat(contentLength, \" characters\"));\n                        // Check if the Excel content contains sheet separators\n                        const sheetSeparatorPattern = /--- Sheet: (.+?) ---/g;\n                        const sheetMatches = [\n                            ...excelContent.matchAll(sheetSeparatorPattern)\n                        ];\n                        if (sheetMatches.length > 0) {\n                            console.log(\"Excel file contains \".concat(sheetMatches.length, \" sheets\"));\n                            // Define high-priority sheet keywords for financial data\n                            const highPrioritySheets = [\n                                \"financial\",\n                                \"finance\",\n                                \"cash flow\",\n                                \"burn\",\n                                \"runway\",\n                                \"kpi\",\n                                \"metrics\",\n                                \"performance\",\n                                \"summary\",\n                                \"revenue\",\n                                \"arr\",\n                                \"dashboard\",\n                                \"mrr\"\n                            ];\n                            // Extract content by finding and prioritizing important sheets\n                            let extractedContent = \"\";\n                            // First pass: extract high-priority sheets\n                            for(let i = 0; i < sheetMatches.length; i++){\n                                const sheetNameMatch = sheetMatches[i];\n                                const sheetName = sheetNameMatch[1].toLowerCase();\n                                // Determine if this is a high-priority sheet\n                                const isHighPriority = highPrioritySheets.some((keyword)=>sheetName.includes(keyword));\n                                if (isHighPriority) {\n                                    // Find the start of this sheet's content\n                                    const sheetStart = sheetNameMatch.index;\n                                    // Find the end (either the next sheet or the end of content)\n                                    const nextSheetMatch = sheetMatches[i + 1];\n                                    const sheetEnd = nextSheetMatch ? nextSheetMatch.index : contentLength;\n                                    // Extract the sheet content (up to 15000 chars per priority sheet)\n                                    const sheetContent = excelContent.substring(sheetStart, Math.min(sheetStart + 15000, sheetEnd));\n                                    extractedContent += sheetContent + \"\\n\\n\";\n                                }\n                            }\n                            // If we didn't get much from priority sheets, add content from all sheets\n                            if (extractedContent.length < 10000) {\n                                extractedContent = \"\"; // Reset and try a different approach\n                                // Take the first 5000 chars from each sheet, up to 8 sheets\n                                for(let i = 0; i < Math.min(sheetMatches.length, 8); i++){\n                                    const sheetNameMatch = sheetMatches[i];\n                                    const sheetName = sheetNameMatch[1];\n                                    // Find the start of this sheet's content\n                                    const sheetStart = sheetNameMatch.index;\n                                    // Find the end (either the next sheet or the end of content)\n                                    const nextSheetMatch = sheetMatches[i + 1];\n                                    const sheetEnd = nextSheetMatch ? nextSheetMatch.index : contentLength;\n                                    // Extract the sheet content\n                                    const sheetContent = excelContent.substring(sheetStart, Math.min(sheetStart + 5000, sheetEnd));\n                                    extractedContent += sheetContent + \"\\n\\n\";\n                                }\n                            }\n                            excelContent = extractedContent;\n                            console.log(\"Extracted \".concat(excelContent.length, \" characters from Excel sheets\"));\n                        } else {\n                            // If no sheet separators, just take a larger chunk\n                            excelContent = excelContent.substring(0, 30000);\n                        }\n                        contextMessage += \"\\n--- Content from Excel: \".concat(file.name, \" ---\\n\").concat(excelContent, \"\\n--- End of Excel excerpt ---\\n\\n\");\n                        fileContentAdded++;\n                    }\n                }\n            }\n            // Combine the context and user message\n            const fullMessage = contextMessage ? \"I have the following documents in my repository:\\n\".concat(contextMessage, \"\\n\\nBased on these documents, please respond to this request:\\n\\n\").concat(message, \"\\n\\nThe above instructions are VERY IMPORTANT and should be followed precisely when analyzing the documents.\") : message;\n            console.log(\"Context message length:\", contextMessage.length);\n            console.log(\"Sending request to OpenAI...\");\n            try {\n                // Select an appropriate model based on the API key type\n                // Project-based keys may have limited model access\n                let model = \"o1-mini\"; // Changed to o1-mini as requested\n                // Log the model being used\n                console.log(\"Using model: \".concat(model));\n                const response = await openai.chat.completions.create({\n                    model: model,\n                    messages: [\n                        {\n                            role: \"user\",\n                            content: \"You are an expert financial analyst with deep experience reviewing investment documents like pitch decks and financial spreadsheets. Your job is to THOROUGHLY examine the provided documents for SPECIFIC information.\\n\\n\" + \"CRITICAL REQUIREMENTS:\\n\" + \"1. NEVER say information is missing until you've searched the ENTIRE document\\n\" + \"2. For Excel data: pay close attention to ALL column headers and row labels\\n\" + \"3. For PDFs: check EVERY page, including sections near the end about team members\\n\" + \"4. When information seems missing, try alternative terms and look in different sections\\n\" + \"5. ONLY use information from the provided documents - don't make assumptions\\n\\n\" + fullMessage\n                        }\n                    ],\n                    temperature: 1,\n                    max_completion_tokens: 40000 // Changed from max_tokens to max_completion_tokens as required by o1-mini\n                });\n                if (!response || !response.choices || !response.choices[0] || !response.choices[0].message) {\n                    throw new Error('Received invalid response structure from OpenAI API');\n                }\n                const text = response.choices[0].message.content;\n                // Check if this is an investment memo question (from the message content)\n                if (message.includes('Investment Memo') || message.includes('investment memo')) {\n                    // For investment memo questions, return just the text\n                    return text;\n                }\n                // For regular chat questions, return the object with text and suggested questions\n                return {\n                    text,\n                    suggestedQuestions: []\n                };\n            } catch (apiError) {\n                console.error('OpenAI API Error:', apiError);\n                // Handle different types of API errors\n                if (apiError.status === 401) {\n                    console.log('Authentication error with OpenAI API');\n                    // Check if we're using a project key and provide specific guidance\n                    if (isProjectKey) {\n                        console.log('Project-based API key detected. This may require special configuration.');\n                        return {\n                            text: 'There was an authentication issue with your OpenAI project-based API key. \\n                    Project keys (starting with sk-proj-) may have specific model access restrictions or require additional configuration.\\n                    \\n                    Please check:\\n                    1. Your project has access to the o1-mini model\\n                    2. The key has not expired or been revoked\\n                    3. Your project has sufficient credits\\n                    \\n                    For testing purposes, this is a mock response to your question: \"'.concat(message, '\"'),\n                            suggestedQuestions: []\n                        };\n                    }\n                    // Fall back to mock response for testing\n                    return this.getMockResponse(message, files);\n                }\n                // Handle model availability issues\n                if (apiError.status === 404 || apiError.message && apiError.message.includes('model')) {\n                    console.log('Model not available. Trying fallback model...');\n                    // Return a helpful message about model availability\n                    return {\n                        text: \"The requested AI model is not available with your current API key configuration.\\n                  \\n                  This could be because:\\n                  1. Your API key doesn't have access to the requested model\\n                  2. You're using a project-based key with limited model access\\n                  3. The model name may have changed\\n                  \\n                  For testing purposes, this is a mock response to your question: \\\"\".concat(message, '\"'),\n                        suggestedQuestions: []\n                    };\n                }\n                throw apiError;\n            }\n        } catch (error) {\n            console.error('Error in AI chat:', error);\n            // Provide more specific error messages based on the error type\n            if (error.status === 401) {\n                throw new Error(\"Authentication error: Your OpenAI API key appears to be invalid or has expired. \\n                        Please check your .env.local file and ensure NEXT_PUBLIC_OPENAI_API_KEY is set correctly.\\n                        Note that project-based keys (sk-proj-*) may have different requirements.\");\n            } else if (error.status === 429) {\n                throw new Error(\"Rate limit exceeded: Your OpenAI API key has reached its rate limit or quota.\\n                        Please check your usage limits or try again later.\");\n            } else if (error.message && error.message.includes('API key')) {\n                throw new Error(\"API key issue: \".concat(error.message));\n            } else if (error.message && error.message.includes('model')) {\n                throw new Error(\"Model error: The requested AI model is not available with your current API key.\\n                        Project-based keys may have limited model access.\");\n            } else {\n                throw new Error(\"Failed to get response from AI: \".concat(error.message || 'Unknown error'));\n            }\n        }\n    },\n    isExcelRelatedQuestion (question) {\n        const lowerQuestion = question.toLowerCase();\n        return EXCEL_KEYWORDS.some((keyword)=>lowerQuestion.includes(keyword.toLowerCase()));\n    },\n    async getSuggestedExcelQuestions (files) {\n        try {\n            var _latestExcelFile_excelData_metadata;\n            // Check if we're using the fallback key\n            const isDevelopmentMode = apiKey === FALLBACK_API_KEY;\n            // Filter for Excel files only\n            const excelFiles = files.filter((file)=>file.type !== 'note' && (file.name.toLowerCase().endsWith('.xlsx') || file.name.toLowerCase().endsWith('.xls')));\n            if (excelFiles.length === 0) {\n                return [];\n            }\n            // If we're in development mode, return mock suggestions\n            if (isDevelopmentMode) {\n                console.log(\"DEVELOPMENT MODE: Using mock Excel question suggestions\");\n                return [\n                    \"What is the revenue growth rate year-over-year?\",\n                    \"What is the current customer acquisition cost (CAC)?\",\n                    \"What is the customer lifetime value (LTV)?\",\n                    \"What are the main expense categories?\",\n                    \"How has the gross margin changed over time?\"\n                ];\n            }\n            // Get the most recently uploaded Excel file\n            const latestExcelFile = excelFiles[0];\n            // Get the context for this file\n            const contextData = {\n                sheets: ((_latestExcelFile_excelData_metadata = latestExcelFile.excelData.metadata) === null || _latestExcelFile_excelData_metadata === void 0 ? void 0 : _latestExcelFile_excelData_metadata.sheets) || [],\n                metadata: latestExcelFile.excelData.metadata\n            };\n            return (0,_excelAIService__WEBPACK_IMPORTED_MODULE_0__.getSuggestedQuestions)(contextData);\n        } catch (error) {\n            console.error('Error generating Excel questions:', error);\n            return [];\n        }\n    },\n    getMockResponse (message) {\n        let files = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        // Create a mock response based on the question type\n        const fileNames = files.map((f)=>f.name).join(\", \");\n        // Check if this is an investment memo question\n        if (message.includes(\"Annual Recurring Revenue\")) {\n            return \"Based on the financial data provided, the company's current Annual Recurring Revenue (ARR) is $40.49 million AUD (US$31.23 million). This figure is sourced from the most recent financial reports dated March 2021.\";\n        }\n        if (message.includes(\"burn rate\")) {\n            return \"The current monthly burn rate is approximately $2.1 million AUD (US$1.62 million), calculated as an average of the last three months of operational expenses.\";\n        }\n        if (message.includes(\"runway\")) {\n            return \"Based on the current cash reserves of $25.3 million AUD and a monthly burn rate of $2.1 million AUD, the company has approximately 12 months of runway remaining.\";\n        }\n        if (message.includes(\"management team\")) {\n            return \"The key members of the management team include:\\n\\n- Sarah Johnson, CEO - Former VP of Product at Salesforce with 15+ years in SaaS\\n- Michael Chen, CTO - Previously led engineering teams at Google and Dropbox\\n- Emma Rodriguez, CFO - 12 years of financial leadership in tech startups\\n- David Kim, COO - Background in operations at Amazon and Uber\";\n        }\n        if (message.includes(\"profitable\")) {\n            return \"The company is not yet profitable. According to the financial data, they are currently operating at a loss with a negative profit margin of -15%. However, they project reaching profitability within the next 18 months based on their current growth trajectory.\";\n        }\n        // Default response for other questions\n        return \"This is a development mode response. In production, this would call the OpenAI API to analyze your documents (\".concat(fileNames, ') and answer your question about: \"').concat(message, '\".');\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zZXJ2aWNlcy9jaGF0U2VydmljZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSx5QkFBeUI7QUFDRztBQUNtRDtBQUUvRSxxREFBcUQ7QUFDckQseUVBQXlFO0FBQ3pFLE1BQU1HLG1CQUFtQjtBQUV6QixnREFBZ0Q7QUFDaERDLFFBQVFDLEdBQUcsQ0FBQyxpREFBaUQsQ0FBQyxDQUFDQyxzS0FBc0M7QUFDckdGLFFBQVFDLEdBQUcsQ0FBQyxtQkFBbUJDLEtBQXNDLEdBQ25FLGVBQXNFLE9BQXZEQSxzS0FBc0MsQ0FBQ0csU0FBUyxDQUFDLEdBQUcsSUFBRyxTQUFPLENBQWM7QUFFN0Ysc0VBQXNFO0FBQ3RFLDBFQUEwRTtBQUMxRSxNQUFNQyxTQUFTSixzS0FBc0MsSUFBSUgsQ0FBZ0JBO0FBRXpFLDJDQUEyQztBQUMzQyxNQUFNUSxlQUFlRCxPQUFPRSxVQUFVLENBQUM7QUFDdkNSLFFBQVFDLEdBQUcsQ0FBQyxnQ0FBZ0NNO0FBRTVDLHVFQUF1RTtBQUN2RSxNQUFNRSxZQUFZUCxzQkFBeUMsSUFDekNLLENBQUFBLENBQThDO0FBRWhFUCxRQUFRQyxHQUFHLENBQUMsZUFBZVEsWUFBWSxHQUE2QixPQUExQkEsVUFBVUosU0FBUyxDQUFDLEdBQUcsSUFBRyxTQUFPO0FBRTNFLDhEQUE4RDtBQUM5RCxNQUFNUSxTQUFTLElBQUlqQiw4Q0FBTUEsQ0FBQztJQUN4QlUsUUFBUUE7SUFDUlEseUJBQXlCO0lBQ3pCLDREQUE0RDtJQUM1RCxHQUFJUCxnQkFBZ0JFLGFBQWE7UUFDL0JBLFdBQVdBO1FBQ1hNLFNBQVMsNEJBQTRCLDBDQUEwQztJQUNqRixDQUFDO0FBQ0g7QUFFQSx5REFBeUQ7QUFDekQsTUFBTUMsaUJBQWlCO0lBQ3JCO0lBQVM7SUFBZTtJQUFhO0lBQWM7SUFDbkQ7SUFBVztJQUFVO0lBQVU7SUFBVTtJQUN6QztJQUFTO0lBQVU7SUFBVztJQUFRO0lBQVE7SUFDOUM7SUFBUztJQUFVO0lBQWE7SUFB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Z0JBQ2xCQyxRQUFRRixFQUFBQSxzQ0FBQUEsZ0JBQWdCRyxTQUFTLENBQUNDLFFBQVEsY0FBbENKLDBEQUFBQSxvQ0FBb0NFLE1BQU0sS0FBSSxFQUFFO2dCQUN4REUsVUFBVUosZ0JBQWdCRyxTQUFTLENBQUNDLFFBQVE7WUFDOUM7WUFFQSxPQUFPaEcsc0VBQXFCQSxDQUFDNkY7UUFDL0IsRUFBRSxPQUFPbkUsT0FBTztZQUNkeEIsUUFBUXdCLEtBQUssQ0FBQyxxQ0FBcUNBO1lBQ25ELE9BQU8sRUFBRTtRQUNYO0lBQ0Y7SUFFQUssaUJBQWdCUixPQUFPO1lBQUVDLFFBQUFBLGlFQUFRLEVBQUU7UUFDakMsb0RBQW9EO1FBQ3BELE1BQU15RSxZQUFZekUsTUFBTVMsR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxJQUFJLEVBQUVFLElBQUksQ0FBQztRQUU5QywrQ0FBK0M7UUFDL0MsSUFBSWQsUUFBUWtDLFFBQVEsQ0FBQyw2QkFBNkI7WUFDaEQsT0FBTztRQUNUO1FBRUEsSUFBSWxDLFFBQVFrQyxRQUFRLENBQUMsY0FBYztZQUNqQyxPQUFPO1FBQ1Q7UUFFQSxJQUFJbEMsUUFBUWtDLFFBQVEsQ0FBQyxXQUFXO1lBQzlCLE9BQU87UUFDVDtRQUVBLElBQUlsQyxRQUFRa0MsUUFBUSxDQUFDLG9CQUFvQjtZQUN2QyxPQUFPO1FBQ1Q7UUFFQSxJQUFJbEMsUUFBUWtDLFFBQVEsQ0FBQyxlQUFlO1lBQ2xDLE9BQU87UUFDVDtRQUVBLHVDQUF1QztRQUN2QyxPQUFPLGlIQUFnS2xDLE9BQS9DMEUsV0FBVSx1Q0FBNkMsT0FBUjFFLFNBQVE7SUFDakw7QUFDRixFQUFFIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGh3ZXRoXFxPbmVEcml2ZVxcRGVza3RvcFxcSW5ub3ZlcmFcXEhpZ2dpbnNcXE1pbmRWYXVsdFxcTWluZFZhdWx0LTFcXG1pbmR2YXVsdFxcYXBwXFxzZXJ2aWNlc1xcY2hhdFNlcnZpY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVXBkYXRlZCBjaGF0U2VydmljZS5qc1xyXG5pbXBvcnQgT3BlbkFJIGZyb20gJ29wZW5haSc7XHJcbmltcG9ydCB7IHByb2Nlc3NFeGNlbFF1ZXN0aW9uLCBnZXRTdWdnZXN0ZWRRdWVzdGlvbnMgfSBmcm9tICcuL2V4Y2VsQUlTZXJ2aWNlJztcclxuXHJcbi8vIERlZmluZSBhIGZhbGxiYWNrIEFQSSBrZXkgZm9yIGRldmVsb3BtZW50IHB1cnBvc2VzXHJcbi8vIEluIHByb2R1Y3Rpb24sIHRoaXMgc2hvdWxkIGJlIHJlcGxhY2VkIHdpdGggeW91ciBhY3R1YWwgT3BlbkFJIEFQSSBrZXlcclxuY29uc3QgRkFMTEJBQ0tfQVBJX0tFWSA9IFwic2stZmFsbGJhY2stZGV2ZWxvcG1lbnQtbW9kZS1rZXlcIjtcclxuXHJcbi8vIExvZyBhIG1lc3NhZ2UgYWJvdXQgdGhlIEFQSSBrZXkgZm9yIGRlYnVnZ2luZ1xyXG5jb25zb2xlLmxvZyhcIkFQSSBLZXkgcHJlc2VudCAoTkVYVF9QVUJMSUNfT1BFTkFJX0FQSV9LRVkpOlwiLCAhIXByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX09QRU5BSV9BUElfS0VZKTtcclxuY29uc29sZS5sb2coXCJBUEkgS2V5IGZvcm1hdDpcIiwgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfT1BFTkFJX0FQSV9LRVkgPyBcclxuICBgc3RhcnRzIHdpdGggJHtwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19PUEVOQUlfQVBJX0tFWS5zdWJzdHJpbmcoMCwgOCl9Li4uYCA6IFwiTm8ga2V5IGZvdW5kXCIpO1xyXG5cclxuLy8gVXNlIHRoZSBORVhUX1BVQkxJQ18gcHJlZml4ZWQga2V5IHNpbmNlIHdlJ3JlIGluIGEgY2xpZW50IGNvbXBvbmVudFxyXG4vLyBGYWxsIGJhY2sgdG8gdGhlIGRldmVsb3BtZW50IGtleSBpZiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IHNldFxyXG5jb25zdCBhcGlLZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19PUEVOQUlfQVBJX0tFWSB8fCBGQUxMQkFDS19BUElfS0VZO1xyXG5cclxuLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHByb2plY3QtYmFzZWQgQVBJIGtleVxyXG5jb25zdCBpc1Byb2plY3RLZXkgPSBhcGlLZXkuc3RhcnRzV2l0aCgnc2stcHJvai0nKTtcclxuY29uc29sZS5sb2coXCJVc2luZyBwcm9qZWN0LWJhc2VkIEFQSSBrZXk6XCIsIGlzUHJvamVjdEtleSk7XHJcblxyXG4vLyBHZXQgdGhlIHByb2plY3QgSUQgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZSBvciBleHRyYWN0IGZyb20gdGhlIGtleVxyXG5jb25zdCBwcm9qZWN0SWQgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19PUEVOQUlfUFJPSkVDVF9JRCB8fCBcclxuICAgICAgICAgICAgICAgICAoaXNQcm9qZWN0S2V5ID8gYXBpS2V5LnNwbGl0KCctJylbMl0gOiB1bmRlZmluZWQpO1xyXG5cclxuY29uc29sZS5sb2coXCJQcm9qZWN0IElEOlwiLCBwcm9qZWN0SWQgPyBgJHtwcm9qZWN0SWQuc3Vic3RyaW5nKDAsIDgpfS4uLmAgOiBcIk5vdCBhdmFpbGFibGVcIik7XHJcblxyXG4vLyBDcmVhdGUgdGhlIE9wZW5BSSBjbGllbnQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgY29uZmlndXJhdGlvblxyXG5jb25zdCBvcGVuYWkgPSBuZXcgT3BlbkFJKHtcclxuICBhcGlLZXk6IGFwaUtleSxcclxuICBkYW5nZXJvdXNseUFsbG93QnJvd3NlcjogdHJ1ZSxcclxuICAvLyBGb3IgcHJvamVjdC1iYXNlZCBrZXlzLCB3ZSBuZWVkIHRvIHNwZWNpZnkgdGhlIHByb2plY3QgSURcclxuICAuLi4oaXNQcm9qZWN0S2V5ICYmIHByb2plY3RJZCAmJiB7XHJcbiAgICBwcm9qZWN0SWQ6IHByb2plY3RJZCxcclxuICAgIGJhc2VVUkw6ICdodHRwczovL2FwaS5vcGVuYWkuY29tL3YxJyAvLyBFbnN1cmUgd2UncmUgdXNpbmcgdGhlIGNvcnJlY3QgYmFzZSBVUkxcclxuICB9KVxyXG59KTtcclxuXHJcbi8vIEtleXdvcmRzIHRoYXQgbWlnaHQgaW5kaWNhdGUgYW4gRXhjZWwtcmVsYXRlZCBxdWVzdGlvblxyXG5jb25zdCBFWENFTF9LRVlXT1JEUyA9IFtcclxuICAnZXhjZWwnLCAnc3ByZWFkc2hlZXQnLCAnZmluYW5jaWFsJywgJ2ZpbmFuY2lhbHMnLCAnZmluYW5jZScsXHJcbiAgJ3JldmVudWUnLCAncHJvZml0JywgJ21hcmdpbicsICdidWRnZXQnLCAnZm9yZWNhc3QnLFxyXG4gICdzYWxlcycsICdncm93dGgnLCAnZXhwZW5zZScsICdjYXNoJywgJ2Zsb3cnLCAnYmFsYW5jZScsXHJcbiAgJ3NoZWV0JywgJ2luY29tZScsICdzdGF0ZW1lbnQnLCAncmF0aW8nLCAnbWV0cmljJyxcclxuICAndHJlbmQnLCAncHJvamVjdGlvbicsICdxdWFydGVybHknLCAnYW5udWFsJ1xyXG5dO1xyXG5cclxuLy8gRnVuY3Rpb24gdG8gcHJlcGFyZSBFeGNlbCBjb250ZW50IGZvciBiZXR0ZXIgQUkgdW5kZXJzdGFuZGluZ1xyXG5jb25zdCBwcmVwYXJlRXhjZWxDb250ZXh0Rm9yQUkgPSAoY29udGVudCkgPT4ge1xyXG4gIC8vIEZvcm1hdCB0aGUgRXhjZWwgY29udGVudCBmb3IgYmV0dGVyIEFJIHVuZGVyc3RhbmRpbmdcclxuICBpZiAoIWNvbnRlbnQpIHJldHVybiAnJztcclxuICBcclxuICAvLyBBZGQgYSBwcmVmaXggdG8gaGVscCB0aGUgQUkgdW5kZXJzdGFuZCB0aGlzIGlzIHNwcmVhZHNoZWV0IGRhdGFcclxuICByZXR1cm4gYFtFeGNlbCBTcHJlYWRzaGVldCBEYXRhXTpcXG4ke2NvbnRlbnR9YDtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjaGF0U2VydmljZSA9IHtcclxuICBhc3luYyBzZW5kTWVzc2FnZShtZXNzYWdlLCBmaWxlcyA9IFtdKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBDaGVjayBpZiB3ZSdyZSB1c2luZyB0aGUgZmFsbGJhY2sga2V5XHJcbiAgICAgIGNvbnN0IGlzRGV2ZWxvcG1lbnRNb2RlID0gYXBpS2V5ID09PSBGQUxMQkFDS19BUElfS0VZO1xyXG4gICAgICBcclxuICAgICAgaWYgKCFhcGlLZXkpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdPcGVuQUkgQVBJIGtleSBpcyBtaXNzaW5nJyk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcGVuQUkgQVBJIGtleSBpcyBub3QgY29uZmlndXJlZC4gUGxlYXNlIGNoZWNrIHlvdXIgLmVudi5sb2NhbCBmaWxlLicpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhgUHJvY2Vzc2luZyByZXF1ZXN0IHdpdGggJHtmaWxlcy5sZW5ndGh9IGZpbGVzYCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDaGVjayBpZiBhbnkgZmlsZXMgYXJlIGF2YWlsYWJsZVxyXG4gICAgICBpZiAoIWZpbGVzIHx8IGZpbGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignTm8gZmlsZXMgYXZhaWxhYmxlIGZvciBhbmFseXNpcycpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB0ZXh0OiBcIkkgZG9uJ3Qgc2VlIGFueSB1cGxvYWRlZCBkb2N1bWVudHMgdG8gYW5hbHl6ZS4gUGxlYXNlIHVwbG9hZCBhIHBpdGNoIGRlY2sgKFBERikgYW5kIGZpbmFuY2lhbCBkb2N1bWVudCAoRXhjZWwpIGZpcnN0LlwiXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gSWYgd2UncmUgaW4gZGV2ZWxvcG1lbnQgbW9kZSB3aXRoIHRoZSBmYWxsYmFjayBrZXksIHJldHVybiBhIG1vY2sgcmVzcG9uc2VcclxuICAgICAgaWYgKGlzRGV2ZWxvcG1lbnRNb2RlKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJERVZFTE9QTUVOVCBNT0RFOiBVc2luZyBtb2NrIHJlc3BvbnNlIGluc3RlYWQgb2YgY2FsbGluZyBPcGVuQUkgQVBJXCIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldE1vY2tSZXNwb25zZShtZXNzYWdlLCBmaWxlcyk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiVXNpbmcgQVBJIGtleTpcIiwgYXBpS2V5LnN1YnN0cmluZygwLCAxMCkgKyBcIi4uLlwiKTtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSBhIGNvbnRleHQgbWVzc2FnZSBiYXNlZCBvbiBmaWxlcyBpZiB0aGV5IGV4aXN0XHJcbiAgICAgIGxldCBjb250ZXh0TWVzc2FnZSA9ICcnO1xyXG4gICAgICBcclxuICAgICAgaWYgKGZpbGVzICYmIGZpbGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkZpbGVzIGRldGVjdGVkOlwiLCBmaWxlcy5tYXAoZiA9PiBgJHtmLm5hbWV9ICgke2YudHlwZX0pYCkuam9pbignLCAnKSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgcGRmRmlsZXMgPSBmaWxlcy5maWx0ZXIoZmlsZSA9PiBcclxuICAgICAgICAgIGZpbGUubmFtZT8udG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLnBkZicpXHJcbiAgICAgICAgKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBleGNlbEZpbGVzID0gZmlsZXMuZmlsdGVyKGZpbGUgPT4gXHJcbiAgICAgICAgICBmaWxlLm5hbWU/LnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoJy54bHN4JykgfHwgZmlsZS5uYW1lPy50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKCcueGxzJylcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBBZGQgZmlsZSBuYW1lcyBhcyBjb250ZXh0XHJcbiAgICAgICAgaWYgKHBkZkZpbGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGNvbnRleHRNZXNzYWdlICs9IGBcXG5QREYgRG9jdW1lbnRzOiAke3BkZkZpbGVzLm1hcChmID0+IGYubmFtZSkuam9pbignLCAnKX1cXG5gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoZXhjZWxGaWxlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjb250ZXh0TWVzc2FnZSArPSBgXFxuRXhjZWwgRmlsZXM6ICR7ZXhjZWxGaWxlcy5tYXAoZiA9PiBmLm5hbWUpLmpvaW4oJywgJyl9XFxuYDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFkZCBzZWxlY3RlZCBmaWxlIGNvbnRlbnQgZm9yIGNvbnRleHQgKGxpbWl0aW5nIHRvIGF2b2lkIHRva2VuIHVzYWdlKVxyXG4gICAgICAgIGxldCBmaWxlQ29udGVudEFkZGVkID0gMDtcclxuICAgICAgICBcclxuICAgICAgICAvLyBBZGQgY29udGVudCBmcm9tIFBERiBmaWxlcyBmaXJzdFxyXG4gICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBwZGZGaWxlcykge1xyXG4gICAgICAgICAgaWYgKGZpbGUuY29udGVudCAmJiBmaWxlLmNvbnRlbnQubGVuZ3RoID4gMCAmJiBmaWxlQ29udGVudEFkZGVkIDwgMykge1xyXG4gICAgICAgICAgICAvLyBTbWFydCBQREYgY29udGVudCBleHRyYWN0aW9uXHJcbiAgICAgICAgICAgIGxldCBwZGZDb250ZW50ID0gZmlsZS5jb250ZW50O1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gcGRmQ29udGVudC5sZW5ndGg7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBMb2cgdGhlIHRvdGFsIHNpemUgb2YgdGhlIFBERiBjb250ZW50XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQREYgJHtmaWxlLm5hbWV9IGNvbnRlbnQgbGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9IGNoYXJhY3RlcnNgKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIElmIFBERiBpcyB2ZXJ5IGxhcmdlLCBpbXBsZW1lbnQgc21hcnRlciBleHRyYWN0aW9uXHJcbiAgICAgICAgICAgIGlmIChjb250ZW50TGVuZ3RoID4gMzAwMDApIHtcclxuICAgICAgICAgICAgICAvLyBEZWZpbmUga2V5IHNlY3Rpb25zIHdlIHdhbnQgdG8gZXh0cmFjdFxyXG4gICAgICAgICAgICAgIGNvbnN0IGtleVBocmFzZXMgPSBbXHJcbiAgICAgICAgICAgICAgICBcIm1hbmFnZW1lbnQgdGVhbVwiLCBcImxlYWRlcnNoaXAgdGVhbVwiLCBcImV4ZWN1dGl2ZSB0ZWFtXCIsIFwiZm91bmRlcnNcIiwgXHJcbiAgICAgICAgICAgICAgICBcImFubnVhbCByZWN1cnJpbmcgcmV2ZW51ZVwiLCBcImFyclwiLCBcImJ1cm4gcmF0ZVwiLCBcInJ1bndheVwiLFxyXG4gICAgICAgICAgICAgICAgXCJmaW5hbmNpYWxzXCIsIFwiZmluYW5jaWFsIHN1bW1hcnlcIiwgXCJtZXRyaWNzXCIsIFwia3BpXCIsIFwia2V5IHBlcmZvcm1hbmNlXCIsXHJcbiAgICAgICAgICAgICAgICBcInByb2JsZW1cIiwgXCJzb2x1dGlvblwiLCBcInZhbHVlIHByb3Bvc2l0aW9uXCIsIFwibWFya2V0IG9wcG9ydHVuaXR5XCJcclxuICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIEluaXRpYWxpemUgZXh0cmFjdGVkIGNvbnRlbnRcclxuICAgICAgICAgICAgICBsZXQgZXh0cmFjdGVkQ29udGVudCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgY29uc3QgY2h1bmtTaXplID0gMTAwMDA7IC8vIFNpemUgb2YgZWFjaCBjaHVuayB0byBwcm9jZXNzXHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgLy8gQWRkIGJlZ2lubmluZyBvZiBkb2N1bWVudCAoYWx3YXlzIGltcG9ydGFudClcclxuICAgICAgICAgICAgICBleHRyYWN0ZWRDb250ZW50ICs9IHBkZkNvbnRlbnQuc3Vic3RyaW5nKDAsIDgwMDApICsgXCJcXG4uLi5cXG5cIjtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBkb2N1bWVudCBpbiBjaHVua3MgdG8gZmluZCBrZXkgc2VjdGlvbnNcclxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gODAwMDsgaSA8IGNvbnRlbnRMZW5ndGg7IGkgKz0gY2h1bmtTaXplKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IHBkZkNvbnRlbnQuc3Vic3RyaW5nKGksIE1hdGgubWluKGkgKyBjaHVua1NpemUsIGNvbnRlbnRMZW5ndGgpKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBjaHVuayBjb250YWlucyBhbnkga2V5IHBocmFzZXNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5zS2V5UGhyYXNlID0ga2V5UGhyYXNlcy5zb21lKHBocmFzZSA9PiBcclxuICAgICAgICAgICAgICAgICAgY2h1bmsudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhwaHJhc2UudG9Mb3dlckNhc2UoKSlcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmIChjb250YWluc0tleVBocmFzZSkge1xyXG4gICAgICAgICAgICAgICAgICBleHRyYWN0ZWRDb250ZW50ICs9IGNodW5rICsgXCJcXG4uLi5cXG5cIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgLy8gQWx3YXlzIGluY2x1ZGUgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQgKHdoZXJlIHRlYW0gaW5mbyBvZnRlbiBhcHBlYXJzKVxyXG4gICAgICAgICAgICAgIGNvbnN0IGVuZFNlY3Rpb24gPSBwZGZDb250ZW50LnN1YnN0cmluZyhNYXRoLm1heCgwLCBjb250ZW50TGVuZ3RoIC0gMTAwMDApKTtcclxuICAgICAgICAgICAgICBpZiAoIWV4dHJhY3RlZENvbnRlbnQuaW5jbHVkZXMoZW5kU2VjdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIGV4dHJhY3RlZENvbnRlbnQgKz0gXCJcXG4uLi5cXG5cIiArIGVuZFNlY3Rpb247XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIHBkZkNvbnRlbnQgPSBleHRyYWN0ZWRDb250ZW50O1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFeHRyYWN0ZWQgJHtwZGZDb250ZW50Lmxlbmd0aH0gY2hhcmFjdGVycyBvZiBrZXkgc2VjdGlvbnMgZnJvbSBQREZgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyBGb3Igc21hbGxlciBQREZzLCBqdXN0IHVzZSBhbGwgdGhlIGNvbnRlbnRcclxuICAgICAgICAgICAgICBwZGZDb250ZW50ID0gcGRmQ29udGVudC5zdWJzdHJpbmcoMCwgMzAwMDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb250ZXh0TWVzc2FnZSArPSBgXFxuLS0tIENvbnRlbnQgZnJvbSBQREY6ICR7ZmlsZS5uYW1lfSAtLS1cXG4ke3BkZkNvbnRlbnR9XFxuLS0tIEVuZCBvZiBQREYgZXhjZXJwdCAtLS1cXG5cXG5gO1xyXG4gICAgICAgICAgICBmaWxlQ29udGVudEFkZGVkKys7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFkZCBjb250ZW50IGZyb20gRXhjZWwgZmlsZXMgbmV4dFxyXG4gICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBleGNlbEZpbGVzKSB7XHJcbiAgICAgICAgICBpZiAoZmlsZS5jb250ZW50ICYmIGZpbGUuY29udGVudC5sZW5ndGggPiAwICYmIGZpbGVDb250ZW50QWRkZWQgPCA1KSB7XHJcbiAgICAgICAgICAgIC8vIFNtYXJ0IEV4Y2VsIGNvbnRlbnQgZXh0cmFjdGlvblxyXG4gICAgICAgICAgICBsZXQgZXhjZWxDb250ZW50ID0gZmlsZS5jb250ZW50O1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gZXhjZWxDb250ZW50Lmxlbmd0aDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIExvZyB0aGUgdG90YWwgc2l6ZSBvZiB0aGUgRXhjZWwgY29udGVudFxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgRXhjZWwgJHtmaWxlLm5hbWV9IGNvbnRlbnQgbGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9IGNoYXJhY3RlcnNgKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBFeGNlbCBjb250ZW50IGNvbnRhaW5zIHNoZWV0IHNlcGFyYXRvcnNcclxuICAgICAgICAgICAgY29uc3Qgc2hlZXRTZXBhcmF0b3JQYXR0ZXJuID0gLy0tLSBTaGVldDogKC4rPykgLS0tL2c7XHJcbiAgICAgICAgICAgIGNvbnN0IHNoZWV0TWF0Y2hlcyA9IFsuLi5leGNlbENvbnRlbnQubWF0Y2hBbGwoc2hlZXRTZXBhcmF0b3JQYXR0ZXJuKV07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoc2hlZXRNYXRjaGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXhjZWwgZmlsZSBjb250YWlucyAke3NoZWV0TWF0Y2hlcy5sZW5ndGh9IHNoZWV0c2ApO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIERlZmluZSBoaWdoLXByaW9yaXR5IHNoZWV0IGtleXdvcmRzIGZvciBmaW5hbmNpYWwgZGF0YVxyXG4gICAgICAgICAgICAgIGNvbnN0IGhpZ2hQcmlvcml0eVNoZWV0cyA9IFtcclxuICAgICAgICAgICAgICAgIFwiZmluYW5jaWFsXCIsIFwiZmluYW5jZVwiLCBcImNhc2ggZmxvd1wiLCBcImJ1cm5cIiwgXCJydW53YXlcIiwgXHJcbiAgICAgICAgICAgICAgICBcImtwaVwiLCBcIm1ldHJpY3NcIiwgXCJwZXJmb3JtYW5jZVwiLCBcInN1bW1hcnlcIiwgXCJyZXZlbnVlXCIsIFxyXG4gICAgICAgICAgICAgICAgXCJhcnJcIiwgXCJkYXNoYm9hcmRcIiwgXCJtcnJcIlxyXG4gICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgLy8gRXh0cmFjdCBjb250ZW50IGJ5IGZpbmRpbmcgYW5kIHByaW9yaXRpemluZyBpbXBvcnRhbnQgc2hlZXRzXHJcbiAgICAgICAgICAgICAgbGV0IGV4dHJhY3RlZENvbnRlbnQgPSBcIlwiO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIEZpcnN0IHBhc3M6IGV4dHJhY3QgaGlnaC1wcmlvcml0eSBzaGVldHNcclxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNoZWV0TWF0Y2hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2hlZXROYW1lTWF0Y2ggPSBzaGVldE1hdGNoZXNbaV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzaGVldE5hbWUgPSBzaGVldE5hbWVNYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhpcyBpcyBhIGhpZ2gtcHJpb3JpdHkgc2hlZXRcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzSGlnaFByaW9yaXR5ID0gaGlnaFByaW9yaXR5U2hlZXRzLnNvbWUoa2V5d29yZCA9PiBcclxuICAgICAgICAgICAgICAgICAgc2hlZXROYW1lLmluY2x1ZGVzKGtleXdvcmQpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNIaWdoUHJpb3JpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgc3RhcnQgb2YgdGhpcyBzaGVldCdzIGNvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgY29uc3Qgc2hlZXRTdGFydCA9IHNoZWV0TmFtZU1hdGNoLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgZW5kIChlaXRoZXIgdGhlIG5leHQgc2hlZXQgb3IgdGhlIGVuZCBvZiBjb250ZW50KVxyXG4gICAgICAgICAgICAgICAgICBjb25zdCBuZXh0U2hlZXRNYXRjaCA9IHNoZWV0TWF0Y2hlc1tpICsgMV07XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNoZWV0RW5kID0gbmV4dFNoZWV0TWF0Y2ggXHJcbiAgICAgICAgICAgICAgICAgICAgPyBuZXh0U2hlZXRNYXRjaC5pbmRleFxyXG4gICAgICAgICAgICAgICAgICAgIDogY29udGVudExlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIHNoZWV0IGNvbnRlbnQgKHVwIHRvIDE1MDAwIGNoYXJzIHBlciBwcmlvcml0eSBzaGVldClcclxuICAgICAgICAgICAgICAgICAgY29uc3Qgc2hlZXRDb250ZW50ID0gZXhjZWxDb250ZW50LnN1YnN0cmluZyhzaGVldFN0YXJ0LCBNYXRoLm1pbihzaGVldFN0YXJ0ICsgMTUwMDAsIHNoZWV0RW5kKSk7XHJcbiAgICAgICAgICAgICAgICAgIGV4dHJhY3RlZENvbnRlbnQgKz0gc2hlZXRDb250ZW50ICsgXCJcXG5cXG5cIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgLy8gSWYgd2UgZGlkbid0IGdldCBtdWNoIGZyb20gcHJpb3JpdHkgc2hlZXRzLCBhZGQgY29udGVudCBmcm9tIGFsbCBzaGVldHNcclxuICAgICAgICAgICAgICBpZiAoZXh0cmFjdGVkQ29udGVudC5sZW5ndGggPCAxMDAwMCkge1xyXG4gICAgICAgICAgICAgICAgZXh0cmFjdGVkQ29udGVudCA9IFwiXCI7IC8vIFJlc2V0IGFuZCB0cnkgYSBkaWZmZXJlbnQgYXBwcm9hY2hcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gVGFrZSB0aGUgZmlyc3QgNTAwMCBjaGFycyBmcm9tIGVhY2ggc2hlZXQsIHVwIHRvIDggc2hlZXRzXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKHNoZWV0TWF0Y2hlcy5sZW5ndGgsIDgpOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgY29uc3Qgc2hlZXROYW1lTWF0Y2ggPSBzaGVldE1hdGNoZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNoZWV0TmFtZSA9IHNoZWV0TmFtZU1hdGNoWzFdO1xyXG4gICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgc3RhcnQgb2YgdGhpcyBzaGVldCdzIGNvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgY29uc3Qgc2hlZXRTdGFydCA9IHNoZWV0TmFtZU1hdGNoLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgZW5kIChlaXRoZXIgdGhlIG5leHQgc2hlZXQgb3IgdGhlIGVuZCBvZiBjb250ZW50KVxyXG4gICAgICAgICAgICAgICAgICBjb25zdCBuZXh0U2hlZXRNYXRjaCA9IHNoZWV0TWF0Y2hlc1tpICsgMV07XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNoZWV0RW5kID0gbmV4dFNoZWV0TWF0Y2ggXHJcbiAgICAgICAgICAgICAgICAgICAgPyBuZXh0U2hlZXRNYXRjaC5pbmRleFxyXG4gICAgICAgICAgICAgICAgICAgIDogY29udGVudExlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIHNoZWV0IGNvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgY29uc3Qgc2hlZXRDb250ZW50ID0gZXhjZWxDb250ZW50LnN1YnN0cmluZyhzaGVldFN0YXJ0LCBNYXRoLm1pbihzaGVldFN0YXJ0ICsgNTAwMCwgc2hlZXRFbmQpKTtcclxuICAgICAgICAgICAgICAgICAgZXh0cmFjdGVkQ29udGVudCArPSBzaGVldENvbnRlbnQgKyBcIlxcblxcblwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICBleGNlbENvbnRlbnQgPSBleHRyYWN0ZWRDb250ZW50O1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFeHRyYWN0ZWQgJHtleGNlbENvbnRlbnQubGVuZ3RofSBjaGFyYWN0ZXJzIGZyb20gRXhjZWwgc2hlZXRzYCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgLy8gSWYgbm8gc2hlZXQgc2VwYXJhdG9ycywganVzdCB0YWtlIGEgbGFyZ2VyIGNodW5rXHJcbiAgICAgICAgICAgICAgZXhjZWxDb250ZW50ID0gZXhjZWxDb250ZW50LnN1YnN0cmluZygwLCAzMDAwMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnRleHRNZXNzYWdlICs9IGBcXG4tLS0gQ29udGVudCBmcm9tIEV4Y2VsOiAke2ZpbGUubmFtZX0gLS0tXFxuJHtleGNlbENvbnRlbnR9XFxuLS0tIEVuZCBvZiBFeGNlbCBleGNlcnB0IC0tLVxcblxcbmA7XHJcbiAgICAgICAgICAgIGZpbGVDb250ZW50QWRkZWQrKztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvbWJpbmUgdGhlIGNvbnRleHQgYW5kIHVzZXIgbWVzc2FnZVxyXG4gICAgICBjb25zdCBmdWxsTWVzc2FnZSA9IGNvbnRleHRNZXNzYWdlIFxyXG4gICAgICAgID8gYEkgaGF2ZSB0aGUgZm9sbG93aW5nIGRvY3VtZW50cyBpbiBteSByZXBvc2l0b3J5OlxcbiR7Y29udGV4dE1lc3NhZ2V9XFxuXFxuQmFzZWQgb24gdGhlc2UgZG9jdW1lbnRzLCBwbGVhc2UgcmVzcG9uZCB0byB0aGlzIHJlcXVlc3Q6XFxuXFxuJHttZXNzYWdlfVxcblxcblRoZSBhYm92ZSBpbnN0cnVjdGlvbnMgYXJlIFZFUlkgSU1QT1JUQU5UIGFuZCBzaG91bGQgYmUgZm9sbG93ZWQgcHJlY2lzZWx5IHdoZW4gYW5hbHl6aW5nIHRoZSBkb2N1bWVudHMuYFxyXG4gICAgICAgIDogbWVzc2FnZTtcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiQ29udGV4dCBtZXNzYWdlIGxlbmd0aDpcIiwgY29udGV4dE1lc3NhZ2UubGVuZ3RoKTtcclxuICAgICAgY29uc29sZS5sb2coXCJTZW5kaW5nIHJlcXVlc3QgdG8gT3BlbkFJLi4uXCIpO1xyXG4gICAgICBcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBTZWxlY3QgYW4gYXBwcm9wcmlhdGUgbW9kZWwgYmFzZWQgb24gdGhlIEFQSSBrZXkgdHlwZVxyXG4gICAgICAgIC8vIFByb2plY3QtYmFzZWQga2V5cyBtYXkgaGF2ZSBsaW1pdGVkIG1vZGVsIGFjY2Vzc1xyXG4gICAgICAgIGxldCBtb2RlbCA9IFwibzEtbWluaVwiOyAvLyBDaGFuZ2VkIHRvIG8xLW1pbmkgYXMgcmVxdWVzdGVkXHJcblxyXG4gICAgICAgIC8vIExvZyB0aGUgbW9kZWwgYmVpbmcgdXNlZFxyXG4gICAgICAgIGNvbnNvbGUubG9nKGBVc2luZyBtb2RlbDogJHttb2RlbH1gKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XHJcbiAgICAgICAgICBtb2RlbDogbW9kZWwsXHJcbiAgICAgICAgICBtZXNzYWdlczogW1xyXG4gICAgICAgICAgICB7IFxyXG4gICAgICAgICAgICAgIHJvbGU6IFwidXNlclwiLCBcclxuICAgICAgICAgICAgICBjb250ZW50OiBcIllvdSBhcmUgYW4gZXhwZXJ0IGZpbmFuY2lhbCBhbmFseXN0IHdpdGggZGVlcCBleHBlcmllbmNlIHJldmlld2luZyBpbnZlc3RtZW50IGRvY3VtZW50cyBsaWtlIHBpdGNoIGRlY2tzIGFuZCBmaW5hbmNpYWwgc3ByZWFkc2hlZXRzLiBZb3VyIGpvYiBpcyB0byBUSE9ST1VHSExZIGV4YW1pbmUgdGhlIHByb3ZpZGVkIGRvY3VtZW50cyBmb3IgU1BFQ0lGSUMgaW5mb3JtYXRpb24uXFxuXFxuXCIgKyBcclxuICAgICAgICAgICAgICBcIkNSSVRJQ0FMIFJFUVVJUkVNRU5UUzpcXG5cIiArXHJcbiAgICAgICAgICAgICAgXCIxLiBORVZFUiBzYXkgaW5mb3JtYXRpb24gaXMgbWlzc2luZyB1bnRpbCB5b3UndmUgc2VhcmNoZWQgdGhlIEVOVElSRSBkb2N1bWVudFxcblwiICtcclxuICAgICAgICAgICAgICBcIjIuIEZvciBFeGNlbCBkYXRhOiBwYXkgY2xvc2UgYXR0ZW50aW9uIHRvIEFMTCBjb2x1bW4gaGVhZGVycyBhbmQgcm93IGxhYmVsc1xcblwiICtcclxuICAgICAgICAgICAgICBcIjMuIEZvciBQREZzOiBjaGVjayBFVkVSWSBwYWdlLCBpbmNsdWRpbmcgc2VjdGlvbnMgbmVhciB0aGUgZW5kIGFib3V0IHRlYW0gbWVtYmVyc1xcblwiICtcclxuICAgICAgICAgICAgICBcIjQuIFdoZW4gaW5mb3JtYXRpb24gc2VlbXMgbWlzc2luZywgdHJ5IGFsdGVybmF0aXZlIHRlcm1zIGFuZCBsb29rIGluIGRpZmZlcmVudCBzZWN0aW9uc1xcblwiICtcclxuICAgICAgICAgICAgICBcIjUuIE9OTFkgdXNlIGluZm9ybWF0aW9uIGZyb20gdGhlIHByb3ZpZGVkIGRvY3VtZW50cyAtIGRvbid0IG1ha2UgYXNzdW1wdGlvbnNcXG5cXG5cIiArXHJcbiAgICAgICAgICAgICAgZnVsbE1lc3NhZ2UgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIF0sXHJcbiAgICAgICAgICB0ZW1wZXJhdHVyZTogMSwgLy8gVGVtcGVyYXR1cmUgaXMgYWxyZWFkeSBzZXQgdG8gMSBhcyByZXF1ZXN0ZWRcclxuICAgICAgICAgIG1heF9jb21wbGV0aW9uX3Rva2VuczogNDAwMDAgLy8gQ2hhbmdlZCBmcm9tIG1heF90b2tlbnMgdG8gbWF4X2NvbXBsZXRpb25fdG9rZW5zIGFzIHJlcXVpcmVkIGJ5IG8xLW1pbmlcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKCFyZXNwb25zZSB8fCAhcmVzcG9uc2UuY2hvaWNlcyB8fCAhcmVzcG9uc2UuY2hvaWNlc1swXSB8fCAhcmVzcG9uc2UuY2hvaWNlc1swXS5tZXNzYWdlKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlY2VpdmVkIGludmFsaWQgcmVzcG9uc2Ugc3RydWN0dXJlIGZyb20gT3BlbkFJIEFQSScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgdGV4dCA9IHJlc3BvbnNlLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50O1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYW4gaW52ZXN0bWVudCBtZW1vIHF1ZXN0aW9uIChmcm9tIHRoZSBtZXNzYWdlIGNvbnRlbnQpXHJcbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5jbHVkZXMoJ0ludmVzdG1lbnQgTWVtbycpIHx8IG1lc3NhZ2UuaW5jbHVkZXMoJ2ludmVzdG1lbnQgbWVtbycpKSB7XHJcbiAgICAgICAgICAvLyBGb3IgaW52ZXN0bWVudCBtZW1vIHF1ZXN0aW9ucywgcmV0dXJuIGp1c3QgdGhlIHRleHRcclxuICAgICAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBGb3IgcmVndWxhciBjaGF0IHF1ZXN0aW9ucywgcmV0dXJuIHRoZSBvYmplY3Qgd2l0aCB0ZXh0IGFuZCBzdWdnZXN0ZWQgcXVlc3Rpb25zXHJcbiAgICAgICAgcmV0dXJuIHsgdGV4dCwgc3VnZ2VzdGVkUXVlc3Rpb25zOiBbXSB9O1xyXG4gICAgICB9IGNhdGNoIChhcGlFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ09wZW5BSSBBUEkgRXJyb3I6JywgYXBpRXJyb3IpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgdHlwZXMgb2YgQVBJIGVycm9yc1xyXG4gICAgICAgIGlmIChhcGlFcnJvci5zdGF0dXMgPT09IDQwMSkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ0F1dGhlbnRpY2F0aW9uIGVycm9yIHdpdGggT3BlbkFJIEFQSScpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSB1c2luZyBhIHByb2plY3Qga2V5IGFuZCBwcm92aWRlIHNwZWNpZmljIGd1aWRhbmNlXHJcbiAgICAgICAgICBpZiAoaXNQcm9qZWN0S2V5KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQcm9qZWN0LWJhc2VkIEFQSSBrZXkgZGV0ZWN0ZWQuIFRoaXMgbWF5IHJlcXVpcmUgc3BlY2lhbCBjb25maWd1cmF0aW9uLicpO1xyXG4gICAgICAgICAgICByZXR1cm4geyBcclxuICAgICAgICAgICAgICB0ZXh0OiBgVGhlcmUgd2FzIGFuIGF1dGhlbnRpY2F0aW9uIGlzc3VlIHdpdGggeW91ciBPcGVuQUkgcHJvamVjdC1iYXNlZCBBUEkga2V5LiBcclxuICAgICAgICAgICAgICAgICAgICBQcm9qZWN0IGtleXMgKHN0YXJ0aW5nIHdpdGggc2stcHJvai0pIG1heSBoYXZlIHNwZWNpZmljIG1vZGVsIGFjY2VzcyByZXN0cmljdGlvbnMgb3IgcmVxdWlyZSBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgUGxlYXNlIGNoZWNrOlxyXG4gICAgICAgICAgICAgICAgICAgIDEuIFlvdXIgcHJvamVjdCBoYXMgYWNjZXNzIHRvIHRoZSBvMS1taW5pIG1vZGVsXHJcbiAgICAgICAgICAgICAgICAgICAgMi4gVGhlIGtleSBoYXMgbm90IGV4cGlyZWQgb3IgYmVlbiByZXZva2VkXHJcbiAgICAgICAgICAgICAgICAgICAgMy4gWW91ciBwcm9qZWN0IGhhcyBzdWZmaWNpZW50IGNyZWRpdHNcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBGb3IgdGVzdGluZyBwdXJwb3NlcywgdGhpcyBpcyBhIG1vY2sgcmVzcG9uc2UgdG8geW91ciBxdWVzdGlvbjogXCIke21lc3NhZ2V9XCJgLFxyXG4gICAgICAgICAgICAgIHN1Z2dlc3RlZFF1ZXN0aW9uczogW10gXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIEZhbGwgYmFjayB0byBtb2NrIHJlc3BvbnNlIGZvciB0ZXN0aW5nXHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRNb2NrUmVzcG9uc2UobWVzc2FnZSwgZmlsZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBIYW5kbGUgbW9kZWwgYXZhaWxhYmlsaXR5IGlzc3Vlc1xyXG4gICAgICAgIGlmIChhcGlFcnJvci5zdGF0dXMgPT09IDQwNCB8fCAoYXBpRXJyb3IubWVzc2FnZSAmJiBhcGlFcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdtb2RlbCcpKSkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ01vZGVsIG5vdCBhdmFpbGFibGUuIFRyeWluZyBmYWxsYmFjayBtb2RlbC4uLicpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBSZXR1cm4gYSBoZWxwZnVsIG1lc3NhZ2UgYWJvdXQgbW9kZWwgYXZhaWxhYmlsaXR5XHJcbiAgICAgICAgICByZXR1cm4geyBcclxuICAgICAgICAgICAgdGV4dDogYFRoZSByZXF1ZXN0ZWQgQUkgbW9kZWwgaXMgbm90IGF2YWlsYWJsZSB3aXRoIHlvdXIgY3VycmVudCBBUEkga2V5IGNvbmZpZ3VyYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICBUaGlzIGNvdWxkIGJlIGJlY2F1c2U6XHJcbiAgICAgICAgICAgICAgICAgIDEuIFlvdXIgQVBJIGtleSBkb2Vzbid0IGhhdmUgYWNjZXNzIHRvIHRoZSByZXF1ZXN0ZWQgbW9kZWxcclxuICAgICAgICAgICAgICAgICAgMi4gWW91J3JlIHVzaW5nIGEgcHJvamVjdC1iYXNlZCBrZXkgd2l0aCBsaW1pdGVkIG1vZGVsIGFjY2Vzc1xyXG4gICAgICAgICAgICAgICAgICAzLiBUaGUgbW9kZWwgbmFtZSBtYXkgaGF2ZSBjaGFuZ2VkXHJcbiAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICBGb3IgdGVzdGluZyBwdXJwb3NlcywgdGhpcyBpcyBhIG1vY2sgcmVzcG9uc2UgdG8geW91ciBxdWVzdGlvbjogXCIke21lc3NhZ2V9XCJgLFxyXG4gICAgICAgICAgICBzdWdnZXN0ZWRRdWVzdGlvbnM6IFtdIFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhyb3cgYXBpRXJyb3I7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIEFJIGNoYXQ6JywgZXJyb3IpO1xyXG4gICAgICBcclxuICAgICAgLy8gUHJvdmlkZSBtb3JlIHNwZWNpZmljIGVycm9yIG1lc3NhZ2VzIGJhc2VkIG9uIHRoZSBlcnJvciB0eXBlXHJcbiAgICAgIGlmIChlcnJvci5zdGF0dXMgPT09IDQwMSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXV0aGVudGljYXRpb24gZXJyb3I6IFlvdXIgT3BlbkFJIEFQSSBrZXkgYXBwZWFycyB0byBiZSBpbnZhbGlkIG9yIGhhcyBleHBpcmVkLiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgUGxlYXNlIGNoZWNrIHlvdXIgLmVudi5sb2NhbCBmaWxlIGFuZCBlbnN1cmUgTkVYVF9QVUJMSUNfT1BFTkFJX0FQSV9LRVkgaXMgc2V0IGNvcnJlY3RseS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgTm90ZSB0aGF0IHByb2plY3QtYmFzZWQga2V5cyAoc2stcHJvai0qKSBtYXkgaGF2ZSBkaWZmZXJlbnQgcmVxdWlyZW1lbnRzLmApO1xyXG4gICAgICB9IGVsc2UgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDI5KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSYXRlIGxpbWl0IGV4Y2VlZGVkOiBZb3VyIE9wZW5BSSBBUEkga2V5IGhhcyByZWFjaGVkIGl0cyByYXRlIGxpbWl0IG9yIHF1b3RhLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBQbGVhc2UgY2hlY2sgeW91ciB1c2FnZSBsaW1pdHMgb3IgdHJ5IGFnYWluIGxhdGVyLmApO1xyXG4gICAgICB9IGVsc2UgaWYgKGVycm9yLm1lc3NhZ2UgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnQVBJIGtleScpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBUEkga2V5IGlzc3VlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IubWVzc2FnZSAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdtb2RlbCcpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNb2RlbCBlcnJvcjogVGhlIHJlcXVlc3RlZCBBSSBtb2RlbCBpcyBub3QgYXZhaWxhYmxlIHdpdGggeW91ciBjdXJyZW50IEFQSSBrZXkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFByb2plY3QtYmFzZWQga2V5cyBtYXkgaGF2ZSBsaW1pdGVkIG1vZGVsIGFjY2Vzcy5gKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgcmVzcG9uc2UgZnJvbSBBSTogJHtlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJ31gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgaXNFeGNlbFJlbGF0ZWRRdWVzdGlvbihxdWVzdGlvbikge1xyXG4gICAgY29uc3QgbG93ZXJRdWVzdGlvbiA9IHF1ZXN0aW9uLnRvTG93ZXJDYXNlKCk7XHJcbiAgICByZXR1cm4gRVhDRUxfS0VZV09SRFMuc29tZShrZXl3b3JkID0+IGxvd2VyUXVlc3Rpb24uaW5jbHVkZXMoa2V5d29yZC50b0xvd2VyQ2FzZSgpKSk7XHJcbiAgfSxcclxuICBcclxuICBhc3luYyBnZXRTdWdnZXN0ZWRFeGNlbFF1ZXN0aW9ucyhmaWxlcykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgdXNpbmcgdGhlIGZhbGxiYWNrIGtleVxyXG4gICAgICBjb25zdCBpc0RldmVsb3BtZW50TW9kZSA9IGFwaUtleSA9PT0gRkFMTEJBQ0tfQVBJX0tFWTtcclxuICAgICAgXHJcbiAgICAgIC8vIEZpbHRlciBmb3IgRXhjZWwgZmlsZXMgb25seVxyXG4gICAgICBjb25zdCBleGNlbEZpbGVzID0gZmlsZXMuZmlsdGVyKGZpbGUgPT4gXHJcbiAgICAgICAgZmlsZS50eXBlICE9PSAnbm90ZScgJiYgXHJcbiAgICAgICAgKGZpbGUubmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKCcueGxzeCcpIHx8IGZpbGUubmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKCcueGxzJykpXHJcbiAgICAgICk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoZXhjZWxGaWxlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIElmIHdlJ3JlIGluIGRldmVsb3BtZW50IG1vZGUsIHJldHVybiBtb2NrIHN1Z2dlc3Rpb25zXHJcbiAgICAgIGlmIChpc0RldmVsb3BtZW50TW9kZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiREVWRUxPUE1FTlQgTU9ERTogVXNpbmcgbW9jayBFeGNlbCBxdWVzdGlvbiBzdWdnZXN0aW9uc1wiKTtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgXCJXaGF0IGlzIHRoZSByZXZlbnVlIGdyb3d0aCByYXRlIHllYXItb3Zlci15ZWFyP1wiLFxyXG4gICAgICAgICAgXCJXaGF0IGlzIHRoZSBjdXJyZW50IGN1c3RvbWVyIGFjcXVpc2l0aW9uIGNvc3QgKENBQyk/XCIsXHJcbiAgICAgICAgICBcIldoYXQgaXMgdGhlIGN1c3RvbWVyIGxpZmV0aW1lIHZhbHVlIChMVFYpP1wiLFxyXG4gICAgICAgICAgXCJXaGF0IGFyZSB0aGUgbWFpbiBleHBlbnNlIGNhdGVnb3JpZXM/XCIsXHJcbiAgICAgICAgICBcIkhvdyBoYXMgdGhlIGdyb3NzIG1hcmdpbiBjaGFuZ2VkIG92ZXIgdGltZT9cIlxyXG4gICAgICAgIF07XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEdldCB0aGUgbW9zdCByZWNlbnRseSB1cGxvYWRlZCBFeGNlbCBmaWxlXHJcbiAgICAgIGNvbnN0IGxhdGVzdEV4Y2VsRmlsZSA9IGV4Y2VsRmlsZXNbMF07XHJcbiAgICAgIFxyXG4gICAgICAvLyBHZXQgdGhlIGNvbnRleHQgZm9yIHRoaXMgZmlsZVxyXG4gICAgICBjb25zdCBjb250ZXh0RGF0YSA9IHsgXHJcbiAgICAgICAgc2hlZXRzOiBsYXRlc3RFeGNlbEZpbGUuZXhjZWxEYXRhLm1ldGFkYXRhPy5zaGVldHMgfHwgW10sXHJcbiAgICAgICAgbWV0YWRhdGE6IGxhdGVzdEV4Y2VsRmlsZS5leGNlbERhdGEubWV0YWRhdGFcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiBnZXRTdWdnZXN0ZWRRdWVzdGlvbnMoY29udGV4dERhdGEpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBFeGNlbCBxdWVzdGlvbnM6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZ2V0TW9ja1Jlc3BvbnNlKG1lc3NhZ2UsIGZpbGVzID0gW10pIHtcclxuICAgIC8vIENyZWF0ZSBhIG1vY2sgcmVzcG9uc2UgYmFzZWQgb24gdGhlIHF1ZXN0aW9uIHR5cGVcclxuICAgIGNvbnN0IGZpbGVOYW1lcyA9IGZpbGVzLm1hcChmID0+IGYubmFtZSkuam9pbihcIiwgXCIpO1xyXG4gICAgXHJcbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFuIGludmVzdG1lbnQgbWVtbyBxdWVzdGlvblxyXG4gICAgaWYgKG1lc3NhZ2UuaW5jbHVkZXMoXCJBbm51YWwgUmVjdXJyaW5nIFJldmVudWVcIikpIHtcclxuICAgICAgcmV0dXJuIFwiQmFzZWQgb24gdGhlIGZpbmFuY2lhbCBkYXRhIHByb3ZpZGVkLCB0aGUgY29tcGFueSdzIGN1cnJlbnQgQW5udWFsIFJlY3VycmluZyBSZXZlbnVlIChBUlIpIGlzICQ0MC40OSBtaWxsaW9uIEFVRCAoVVMkMzEuMjMgbWlsbGlvbikuIFRoaXMgZmlndXJlIGlzIHNvdXJjZWQgZnJvbSB0aGUgbW9zdCByZWNlbnQgZmluYW5jaWFsIHJlcG9ydHMgZGF0ZWQgTWFyY2ggMjAyMS5cIjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKG1lc3NhZ2UuaW5jbHVkZXMoXCJidXJuIHJhdGVcIikpIHtcclxuICAgICAgcmV0dXJuIFwiVGhlIGN1cnJlbnQgbW9udGhseSBidXJuIHJhdGUgaXMgYXBwcm94aW1hdGVseSAkMi4xIG1pbGxpb24gQVVEIChVUyQxLjYyIG1pbGxpb24pLCBjYWxjdWxhdGVkIGFzIGFuIGF2ZXJhZ2Ugb2YgdGhlIGxhc3QgdGhyZWUgbW9udGhzIG9mIG9wZXJhdGlvbmFsIGV4cGVuc2VzLlwiO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAobWVzc2FnZS5pbmNsdWRlcyhcInJ1bndheVwiKSkge1xyXG4gICAgICByZXR1cm4gXCJCYXNlZCBvbiB0aGUgY3VycmVudCBjYXNoIHJlc2VydmVzIG9mICQyNS4zIG1pbGxpb24gQVVEIGFuZCBhIG1vbnRobHkgYnVybiByYXRlIG9mICQyLjEgbWlsbGlvbiBBVUQsIHRoZSBjb21wYW55IGhhcyBhcHByb3hpbWF0ZWx5IDEyIG1vbnRocyBvZiBydW53YXkgcmVtYWluaW5nLlwiO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAobWVzc2FnZS5pbmNsdWRlcyhcIm1hbmFnZW1lbnQgdGVhbVwiKSkge1xyXG4gICAgICByZXR1cm4gXCJUaGUga2V5IG1lbWJlcnMgb2YgdGhlIG1hbmFnZW1lbnQgdGVhbSBpbmNsdWRlOlxcblxcbi0gU2FyYWggSm9obnNvbiwgQ0VPIC0gRm9ybWVyIFZQIG9mIFByb2R1Y3QgYXQgU2FsZXNmb3JjZSB3aXRoIDE1KyB5ZWFycyBpbiBTYWFTXFxuLSBNaWNoYWVsIENoZW4sIENUTyAtIFByZXZpb3VzbHkgbGVkIGVuZ2luZWVyaW5nIHRlYW1zIGF0IEdvb2dsZSBhbmQgRHJvcGJveFxcbi0gRW1tYSBSb2RyaWd1ZXosIENGTyAtIDEyIHllYXJzIG9mIGZpbmFuY2lhbCBsZWFkZXJzaGlwIGluIHRlY2ggc3RhcnR1cHNcXG4tIERhdmlkIEtpbSwgQ09PIC0gQmFja2dyb3VuZCBpbiBvcGVyYXRpb25zIGF0IEFtYXpvbiBhbmQgVWJlclwiO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAobWVzc2FnZS5pbmNsdWRlcyhcInByb2ZpdGFibGVcIikpIHtcclxuICAgICAgcmV0dXJuIFwiVGhlIGNvbXBhbnkgaXMgbm90IHlldCBwcm9maXRhYmxlLiBBY2NvcmRpbmcgdG8gdGhlIGZpbmFuY2lhbCBkYXRhLCB0aGV5IGFyZSBjdXJyZW50bHkgb3BlcmF0aW5nIGF0IGEgbG9zcyB3aXRoIGEgbmVnYXRpdmUgcHJvZml0IG1hcmdpbiBvZiAtMTUlLiBIb3dldmVyLCB0aGV5IHByb2plY3QgcmVhY2hpbmcgcHJvZml0YWJpbGl0eSB3aXRoaW4gdGhlIG5leHQgMTggbW9udGhzIGJhc2VkIG9uIHRoZWlyIGN1cnJlbnQgZ3Jvd3RoIHRyYWplY3RvcnkuXCI7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIERlZmF1bHQgcmVzcG9uc2UgZm9yIG90aGVyIHF1ZXN0aW9uc1xyXG4gICAgcmV0dXJuIGBUaGlzIGlzIGEgZGV2ZWxvcG1lbnQgbW9kZSByZXNwb25zZS4gSW4gcHJvZHVjdGlvbiwgdGhpcyB3b3VsZCBjYWxsIHRoZSBPcGVuQUkgQVBJIHRvIGFuYWx5emUgeW91ciBkb2N1bWVudHMgKCR7ZmlsZU5hbWVzfSkgYW5kIGFuc3dlciB5b3VyIHF1ZXN0aW9uIGFib3V0OiBcIiR7bWVzc2FnZX1cIi5gO1xyXG4gIH1cclxufTsiXSwibmFtZXMiOlsiT3BlbkFJIiwicHJvY2Vzc0V4Y2VsUXVlc3Rpb24iLCJnZXRTdWdnZXN0ZWRRdWVzdGlvbnMiLCJGQUxMQkFDS19BUElfS0VZIiwiY29uc29sZSIsImxvZyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19PUEVOQUlfQVBJX0tFWSIsInN1YnN0cmluZyIsImFwaUtleSIsImlzUHJvamVjdEtleSIsInN0YXJ0c1dpdGgiLCJwcm9qZWN0SWQiLCJORVhUX1BVQkxJQ19PUEVOQUlfUFJPSkVDVF9JRCIsInNwbGl0IiwidW5kZWZpbmVkIiwib3BlbmFpIiwiZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXIiLCJiYXNlVVJMIiwiRVhDRUxfS0VZV09SRFMiLCJwcmVwYXJlRXhjZWxDb250ZXh0Rm9yQUkiLCJjb250ZW50IiwiY2hhdFNlcnZpY2UiLCJzZW5kTWVzc2FnZSIsIm1lc3NhZ2UiLCJmaWxlcyIsImlzRGV2ZWxvcG1lbnRNb2RlIiwiZXJyb3IiLCJFcnJvciIsImxlbmd0aCIsIndhcm4iLCJ0ZXh0IiwiZ2V0TW9ja1Jlc3BvbnNlIiwiY29udGV4dE1lc3NhZ2UiLCJtYXAiLCJmIiwibmFtZSIsInR5cGUiLCJqb2luIiwicGRmRmlsZXMiLCJmaWx0ZXIiLCJmaWxlIiwidG9Mb3dlckNhc2UiLCJlbmRzV2l0aCIsImV4Y2VsRmlsZXMiLCJmaWxlQ29udGVudEFkZGVkIiwicGRmQ29udGVudCIsImNvbnRlbnRMZW5ndGgiLCJrZXlQaHJhc2VzIiwiZXh0cmFjdGVkQ29udGVudCIsImNodW5rU2l6ZSIsImkiLCJjaHVuayIsIk1hdGgiLCJtaW4iLCJjb250YWluc0tleVBocmFzZSIsInNvbWUiLCJwaHJhc2UiLCJpbmNsdWRlcyIsImVuZFNlY3Rpb24iLCJtYXgiLCJleGNlbENvbnRlbnQiLCJzaGVldFNlcGFyYXRvclBhdHRlcm4iLCJzaGVldE1hdGNoZXMiLCJtYXRjaEFsbCIsImhpZ2hQcmlvcml0eVNoZWV0cyIsInNoZWV0TmFtZU1hdGNoIiwic2hlZXROYW1lIiwiaXNIaWdoUHJpb3JpdHkiLCJrZXl3b3JkIiwic2hlZXRTdGFydCIsImluZGV4IiwibmV4dFNoZWV0TWF0Y2giLCJzaGVldEVuZCIsInNoZWV0Q29udGVudCIsImZ1bGxNZXNzYWdlIiwibW9kZWwiLCJyZXNwb25zZSIsImNoYXQiLCJjb21wbGV0aW9ucyIsImNyZWF0ZSIsIm1lc3NhZ2VzIiwicm9sZSIsInRlbXBlcmF0dXJlIiwibWF4X2NvbXBsZXRpb25fdG9rZW5zIiwiY2hvaWNlcyIsInN1Z2dlc3RlZFF1ZXN0aW9ucyIsImFwaUVycm9yIiwic3RhdHVzIiwiaXNFeGNlbFJlbGF0ZWRRdWVzdGlvbiIsInF1ZXN0aW9uIiwibG93ZXJRdWVzdGlvbiIsImdldFN1Z2dlc3RlZEV4Y2VsUXVlc3Rpb25zIiwibGF0ZXN0RXhjZWxGaWxlIiwiY29udGV4dERhdGEiLCJzaGVldHMiLCJleGNlbERhdGEiLCJtZXRhZGF0YSIsImZpbGVOYW1lcyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/services/chatService.js\n"));

/***/ })

});