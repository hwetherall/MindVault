import { useState } from 'react';
import { Answer, DeepDiveQuestion } from '../utils/types';
import { chatService } from '../../../../services/chatService';

interface UseDeepDiveProps {
  files: any[];
  questions: DeepDiveQuestion[];
  onComplete?: (passed: boolean) => void;
}

interface UseDeepDiveReturn {
  isAnalyzing: boolean;
  answers: Record<string, Answer>;
  error: string | null;
  expandedAnswers: Record<string, boolean>;
  editingId: string | null;
  editedAnswer: string;
  setEditedAnswer: (answer: string) => void;
  toggleAnswer: (id: string) => void;
  handleEdit: (id: string) => void;
  handleSave: (id: string) => void;
  analyzeDocuments: () => Promise<void>;
  regenerateAnswer: (id: string) => Promise<void>;
}

/**
 * Custom hook for managing deep dive state and operations
 */
export function useDeepDive({
  files,
  questions,
  onComplete
}: UseDeepDiveProps): UseDeepDiveReturn {
  const [isAnalyzing, setIsAnalyzing] = useState<boolean>(false);
  const [answers, setAnswers] = useState<Record<string, Answer>>({});
  const [error, setError] = useState<string | null>(null);
  const [expandedAnswers, setExpandedAnswers] = useState<Record<string, boolean>>({});
  const [editingId, setEditingId] = useState<string | null>(null);
  const [editedAnswer, setEditedAnswer] = useState<string>('');

  /**
   * Toggles the expansion state of an answer
   */
  const toggleAnswer = (id: string) => {
    setExpandedAnswers(prev => ({
      ...prev,
      [id]: !prev[id]
    }));
  };

  /**
   * Opens the editor for an answer
   */
  const handleEdit = (id: string) => {
    if (!id) {
      setEditingId(null);
      setEditedAnswer('');
      return;
    }
    
    setEditingId(id);
    setEditedAnswer(answers[id]?.content || '');
  };

  /**
   * Saves the edited answer
   */
  const handleSave = (id: string) => {
    if (editedAnswer.trim()) {
      const updatedAnswer = {
        content: editedAnswer,
        isEdited: true
      };
      
      setAnswers(prev => ({
        ...prev,
        [id]: updatedAnswer
      }));
    }
    
    setEditingId(null);
    setEditedAnswer('');
  };

  /**
   * Generates a prompt for a specific deep dive question
   */
  const getPromptForQuestion = (id: string): string => {
    const question = questions.find(q => q.id === id);
    if (!question) return '';
    
    return `Analyze the provided documents and answer the following question:
${question.question}

${question.description ? `Additional context: ${question.description}` : ''}

Format your response with:
- A detailed analysis
- Specific data points from the documents
- Recommendations where applicable
`;
  };

  /**
   * Analyzes documents to generate answers for all questions
   */
  const analyzeDocuments = async () => {
    if (files.length === 0) {
      setError('Please upload at least one document to analyze');
      return;
    }

    setIsAnalyzing(true);
    setError(null);
    
    try {
      // In a real implementation, you would use chatService to generate answers
      // This is a mock implementation
      const mockAnswers: Record<string, Answer> = {};
      
      for (const question of questions) {
        // Simulate API call delay
        await new Promise(resolve => setTimeout(resolve, 500));
        
        mockAnswers[question.id] = {
          content: `This is a placeholder answer for the question: "${question.question}". 
          In a real implementation, this would be generated by analyzing the uploaded documents.`,
          isEdited: false
        };
      }
      
      setAnswers(mockAnswers);
      
      if (onComplete) {
        onComplete(true);
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An unknown error occurred');
    } finally {
      setIsAnalyzing(false);
    }
  };

  /**
   * Regenerates a specific answer
   */
  const regenerateAnswer = async (id: string) => {
    const question = questions.find(q => q.id === id);
    if (!question) return;
    
    try {
      // Mock implementation - would call chat service in a real app
      const regeneratedAnswer = {
        content: `This is a regenerated answer for: "${question.question}".
        It would normally be created by analyzing the documents with an updated prompt.`,
        isEdited: false
      };
      
      setAnswers(prev => ({
        ...prev,
        [id]: regeneratedAnswer
      }));
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred while regenerating the answer');
    }
  };

  return {
    isAnalyzing,
    answers,
    error,
    expandedAnswers,
    editingId,
    editedAnswer,
    setEditedAnswer,
    toggleAnswer,
    handleEdit,
    handleSave,
    analyzeDocuments,
    regenerateAnswer
  };
} 